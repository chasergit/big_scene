<!DOCTYPE HTML>
<html>
<head>
<title>GEAR</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="shortcut icon" href="./images/favicon.png" type="image/x-icon" />
<link href="./css/style.css" rel="stylesheet" type="text/css">
</head>


<body>


<div id="project" style="font-family:tahoma;">


<div id="voice_status" class="voice_status" style="display:block;">Micro off</div>
<div id="status_i_ray_sphere" class="status_i_ray_sphere"></div>
<div id="status_i_ray_AABB" class="status_i_ray_AABB"></div>
<div class="health_common" style="display:block;"><div class="health_pad"><div class="health_value"></div></div></div>
<div class="ammo_common"><div class="ammo_count">30</div><div class="ammo_title">Bullets</div></div>
<div class="grenade_common"><div class="grenade_count">4</div><div class="grenade_title">Grenades</div></div>
<div id="statistic" class="statistic">


<table class="loop_time" cellpadding="0px" cellspacing="0px">
<tr><td>TOTAL:</td><td>JS:</td><td>RENDER</td></tr>
<tr><td id="total_frame"></td><td id="loop_js_time"></td><td id="loop_render"></td></tr>
</table>


<div id="section_pass" class="section_pass">&nbsp;</div>
<table class="my_pos" cellpadding="0px" cellspacing="0px">
<tr><td>POSITION:</td><td id="my_pos_x"></td><td id="my_pos_y"></td><td id="my_pos_z"></td></tr>
</table>
<table class="section_100" cellpadding="0px" cellspacing="0px">
<tr><td>SECTION&nbsp;100:</td><td id="section_100_x"></td><td id="section_100_z"></td></tr>
</table>
<div class="raycast">Raycast: <span id="raycast"></span></div>
<div class="sprites">Sprites: <span id="sprites"></span></div>
<div class="closest_point">Closest: <span id="closest_point"></span></div>
<div class="shadow_ground"><div id="shadow_ground_text_1"></div><div id="shadow_ground_text_2">&nbsp;</div></div>
</div>


<div id="loading" style="position:absolute;display:block;top:50%;width:100%;text-align:center;font-family:arial;font-size:40px;color:#ffffff;text-shadow:1px 1px 4px #393342;">LOADED <span id="loading_amount" style="font-family:arial;font-size:40px;"></span></div>
<div id="begin" style="cursor:pointer;position:absolute;display:none;top:50%;width:100%;text-align:center;font-family:arial;font-size:40px;color:#ffffff;text-shadow:1px 1px 4px #393342;">START</div>
<canvas id="canvas" style="display:block;"></canvas>
</div>


<script type="importmap">
{
"imports":{
"three": "./js/0_three/three_172.js",
"three/addons/": "./js/0_three/"
}
}
</script>


<script type="module">


"use strict"


import * as THREE from "three";
import Stats from "./js/stats/stats.js";
import GPUStatsPanel from "./js/stats/GPUStatsPanel.js";
import * as SkeletonUtils from "three/addons/utils/SkeletonUtils.js";
import * as THREE_BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";
import * as THREE_OBJLoader from "three/addons/loaders/OBJLoader.js"; // MODIFIED
import * as THREE_FBXLoader from "three/addons/loaders/FBXLoader.js"; // MODIFIED
import * as THREE_RGBELoader from "three/addons/loaders/RGBELoader.js";
import * as THREE_UltraHDRLoader from "three/addons/loaders/UltraHDRLoader.js";
import {LightProbeHelper} from "three/addons/helpers/LightProbeHelper.js";
import {LightProbeGenerator} from "three/addons/lights/LightProbeGenerator.js";
import {PositionalAudioHelper} from "three/addons/helpers/PositionalAudioHelper.js";


import {EffectComposer} from "three/addons/postprocessing/EffectComposer.js";
import {RenderPass} from "three/addons/postprocessing/RenderPass.js";
import {ShaderPass} from "three/addons/postprocessing/ShaderPass.js"; // MODIFIED
import {UnrealBloomPass} from "three/addons/postprocessing/UnrealBloomPass.js";
import {FXAAShader} from "three/addons/shaders/FXAAShader.js";


import underwater_shader from "./shaders/underwater_pass.js";
import underwater_ripples_shader from "./shaders/underwater_ripples_pass.js";
import correction_shader from "./shaders/correction_pass.js";
import {materials_duplicates_remover} from "./js/utils/materials_duplicates_remover.js";
import {lightMap} from "./js/utils/lightMap.js";
import {intersection_ray_AABB} from "./js/ray/intersection_ray_AABB.js";
import {intersection_ray_sphere} from "./js/ray/intersection_ray_sphere.js";
import {intersection_ray_triangle} from "./js/ray/intersection_ray_triangle.js";
import {closest_point_same_side,closest_point_to_segment,closest_point_to_sides,closest_point_to_triangle,closest_point_search,closest_point_type_1,closest_point} from "./js/closest_point.js";
import {set_crosshair} from "./js/objects/crosshair.js";
import {set_sprite} from "./js/objects/sprite.js";


let renderer_stats_m=0;


let renderer_stats_canvas=document.createElement("canvas");
renderer_stats_canvas.id="renderer_stats";
renderer_stats_canvas.style.cssText="opacity:0.9;position:fixed;left:0px;top:48px;";
renderer_stats_canvas.width=120;
renderer_stats_canvas.height=85;


let renderer_stats_ctx=renderer_stats_canvas.getContext("2d");
renderer_stats_ctx.font="10px tahoma";
renderer_stats_ctx.translate(10,5);


function renderer_stats_reset(num){
renderer_stats_m=num;
renderer_stats_canvas.height+=40;
renderer_stats_ctx.font="10px tahoma";
renderer_stats_ctx.translate(10,5);
}


function renderer_stats_update(num){


if(num==0){ renderer_stats_update_big(); }
else{
if(num>renderer_stats_m){ renderer_stats_reset(num); }
renderer_stats_update_small(num);
}


}


function renderer_stats_r(v){
return String(v).replace(/\B(?=(\d{3})+(?!\d))/g,".");
}


function renderer_stats_update_big(){


renderer_stats_ctx.fillStyle="#1D467C";
renderer_stats_ctx.fillRect(-10,-5,renderer_stats_canvas.width,renderer_stats_canvas.height);
renderer_stats_ctx.fillStyle="#ffffff";


let item_1=renderer.info;
let item_2=item_1.render;
renderer_stats_ctx.fillText("GEOMETRIES: "+renderer_stats_r(item_1.memory.geometries),0,10);
renderer_stats_ctx.fillText("TEXTURES: "+renderer_stats_r(item_1.memory.textures),0,20);
renderer_stats_ctx.fillText("SHADERS: "+renderer_stats_r(item_1.programs.length),0,30);
renderer_stats_ctx.fillText("CALLS: "+renderer_stats_r(item_2.calls),0,40);
renderer_stats_ctx.fillText("TRIANGLES: "+renderer_stats_r(item_2.triangles),0,50);
renderer_stats_ctx.fillText("LINES: "+renderer_stats_r(item_2.lines),0,60);
renderer_stats_ctx.fillText("POINTS: "+renderer_stats_r(item_2.points),0,70);


}


function renderer_stats_update_small(num){


let item=renderer.info.render;
renderer_stats_ctx.fillText("CALLS: "+renderer_stats_r(item.calls),0,80+(40*(num-1)));
renderer_stats_ctx.fillText("TRIANGLES: "+renderer_stats_r(item.triangles),0,90+(40*(num-1)));
renderer_stats_ctx.fillText("LINES: "+renderer_stats_r(item.lines),0,100+(40*(num-1)));
renderer_stats_ctx.fillText("POINTS: "+renderer_stats_r(item.points),0,110+(40*(num-1)));


}
let shadow_ground_type=[];


function shadow_ground_set_type(){
shadow_ground_type[1]=[0,0,1,50,2,140,0+shadow_ground_size,0];
shadow_ground_type[1]=[
-1-shadow_ground_size,100,-shadow_ground_size,50,1-shadow_ground_size,100,
-1,50,0,50,1,50,
-1+shadow_ground_size,100,shadow_ground_size,50,1+shadow_ground_size,100
];
}


let shadow_ground_size=1024; 
let shadow_ground_square=500; 
let shadow_ground_border=Math.ceil(shadow_ground_size/2048*10); 
let shadow_ground_sleep=400; 
let shadow_ground_now=1; // 
let shadow_ground_texture;
let shadow_ground_texture_1;
let shadow_ground_texture_2;
let shadow_ground_tex;
shadow_ground_set_type();


let shadow_ground_chunk_total=16; 
let shadow_ground_chunk_now=0; 
let shadow_ground_chunk_pixels=shadow_ground_size*(shadow_ground_size/shadow_ground_chunk_total); 


let shadow_ground_pixel=Number((shadow_ground_size/shadow_ground_square).toFixed(2));
let shadow_ground_start=0; 
let shadow_ground_end=0;
let shadow_ground_f=[]; 
let shadow_ground_m=0;
let shadow_ground_b=new Uint32Array(shadow_ground_size*4*shadow_ground_border);
let shadow_ground_bn=0;
let shadow_ground_total=0;
let shadow_ground_pixels=0;
let shadow_ground_time_2=0;
let shadow_ground_time_3=0;
let shadow_ground_time_4=0;
let shadow_ground_breaks_2="";
let shadow_ground_breaks_3="";
let shadow_ground_breaks_4="";
let shadow_ground_breaks_5="";
let shadow_ground_breaks_6="";
let shadow_ground_w=0;
let shadow_ground_px=-999; 
let shadow_ground_pz=0; 
let shadow_ground_nx=0; 
let shadow_ground_nz=0; 
let shadow_ground_mx=0; 
let shadow_ground_mz=0; 
let shadow_ground_v=0;
let shadow_ground_n=0;
let shadow_ground_a=new Int32Array();
let shadow_ground_i=0;
let shadow_ground_a_num=0;


let shadow_ground_cell=[];


let shadow_ground_ways=[
[-4,-3],[-3,-3],[-2,-3],[-1,-3],[0,-3],[1,-3],[2,-3],[3,-3],
[-4,-2],[-3,-2],[-2,-2],[-1,-2],[0,-2],[1,-2],[2,-2],[3,-2],
[-4,-1],[-3,-1],[-2,-1],[-1,-1],[0,-1],[1,-1],[2,-1],[3,-1],
[-4,0],[-3,0],[-2,0],[-1,0],[0,0],[1,0],[2,0],[3,0],
[-4,1],[-3,1],[-2,1],[-1,1],[0,1],[1,1],[2,1],[3,1],
[-4,2],[-3,2],[-2,2],[-1,2],[0,2],[1,2],[2,2],[3,2],
[-4,3],[-3,3],[-2,3],[-1,3],[0,3],[1,3],[2,3],[3,3],
[-4,4],[-3,4],[-2,4],[-1,4],[0,4],[1,4],[2,4],[3,4],
];


shadow_ground_ways=[
[-3,-2],[-2,-2],[-1,-2],[0,-2],[1,-2],[2,-2],
[-3,-1],[-2,-1],[-1,-1],[0,-1],[1,-1],[2,-1],
[-3,0],[-2,0],[-1,0],[0,0],[1,0],[2,0],
[-3,1],[-2,1],[-1,1],[0,1],[1,1],[2,1],
[-3,2],[-2,2],[-1,2],[0,2],[1,2],[2,2],
[-3,3],[-2,3],[-1,3],[0,3],[1,3],[2,3],
];


let shadow_ground_ways_max=shadow_ground_ways.length;


function shadow_ground_init(){


// МАССИВ РАМКИ


let n=0;
for(let i=0;i<shadow_ground_size;i++){
for(let j=0;j<shadow_ground_border;j++){
shadow_ground_b[n]=i+j*shadow_ground_size;
n++;
shadow_ground_b[n]=i+shadow_ground_size+shadow_ground_size*shadow_ground_size-shadow_ground_size*shadow_ground_border+j*shadow_ground_size;
n++;
shadow_ground_b[n]=j+i*shadow_ground_size;
n++;
shadow_ground_b[n]=j+shadow_ground_size-shadow_ground_border+i*shadow_ground_size;
n++;
}
}


let r={};
shadow_ground_b=shadow_ground_b.filter(i=>r.hasOwnProperty(i)?!1:r[i]=!0);


shadow_ground_texture_1=new Uint8Array(shadow_ground_size*shadow_ground_size).fill(255);
shadow_ground_texture_2=new Uint8Array(shadow_ground_size*shadow_ground_size).fill(255);


tex["shadow_ground_1"]=new THREE.DataTexture(shadow_ground_texture_1,shadow_ground_size,shadow_ground_size,THREE.RedFormat,THREE.UnsignedByteType);
tex["shadow_ground_1"].minFilter=THREE.LinearMipmapLinearFilter;
tex["shadow_ground_1"].magFilter=THREE.LinearFilter;
tex["shadow_ground_1"].generateMipmaps=true;
tex["shadow_ground_1"].flipY=true;
tex["shadow_ground_1"].needsUpdate=true;


tex["shadow_ground_2"]=new THREE.DataTexture(shadow_ground_texture_2,shadow_ground_size,shadow_ground_size,THREE.RedFormat,THREE.UnsignedByteType);
tex["shadow_ground_2"].minFilter=THREE.LinearMipmapLinearFilter;
tex["shadow_ground_2"].magFilter=THREE.LinearFilter;
tex["shadow_ground_2"].generateMipmaps=true;
tex["shadow_ground_2"].flipY=true;
tex["shadow_ground_2"].needsUpdate=true;


tex["shadow_ground_chunk"]=new THREE.DataTexture(new Uint8Array(shadow_ground_chunk_pixels),shadow_ground_size,shadow_ground_size/shadow_ground_chunk_total,THREE.RedFormat,THREE.UnsignedByteType);
tex["shadow_ground_chunk"].minFilter=THREE.LinearFilter;
//tex["shadow_ground_chunk"].magFilter=THREE.LinearFilter;
tex["shadow_ground_chunk"].generateMipmaps=false;


shadow_ground_texture=shadow_ground_texture_1;
shadow_ground_tex=tex["shadow_ground_1"];


}


shadow_ground_f[0]=function(){


shadow_ground_nx=Math.floor(camera.position.x/62.5);
shadow_ground_nz=Math.floor(camera.position.z/62.5);


shadow_ground_w=0;


if(camera.position.x>shadow_ground_px*62.5+62.5+31.25){ shadow_ground_w=1; }
if(camera.position.z<shadow_ground_pz*62.5-31.25){ shadow_ground_w=2; }
if(camera.position.x<shadow_ground_px*62.5-62.5){ shadow_ground_w=3; }
if(camera.position.z>shadow_ground_pz*62.5+62.5){ shadow_ground_w=4; }
if(shadow_ground_w>0){ shadow_ground_m=1; }


}


shadow_ground_f[1]=function(){
document.getElementById("shadow_ground_text_2").innerHTML="SHADOW GENERATION";
shadow_ground_start=performance.now();
shadow_ground_texture.fill(255);
shadow_ground_mx=-shadow_ground_nx*shadow_ground_size/8+shadow_ground_size/2;
shadow_ground_mz=-shadow_ground_nz*shadow_ground_size/8+shadow_ground_size/8*3;
shadow_ground_px=shadow_ground_nx;
shadow_ground_pz=shadow_ground_nz;
shadow_ground_total=0;
shadow_ground_pixels=0;
shadow_ground_a_num=0;
shadow_ground_chunk_now=0;
shadow_ground_time_2=0;
shadow_ground_time_3=0;
shadow_ground_time_4=0;
shadow_ground_breaks_2="";
shadow_ground_breaks_3="";
shadow_ground_breaks_4="";
shadow_ground_breaks_5="";
shadow_ground_breaks_6="";
shadow_ground_m=2;


for(let n=0;n<shadow_ground_ways_max;n++){
let cell_name=(shadow_ground_px+shadow_ground_ways[n][0])+"_"+(shadow_ground_pz+shadow_ground_ways[n][1]);
let item=shadow_ground_cell[cell_name];
if(item!=undefined){ shadow_ground_total+=item.length; }
}


shadow_ground_a=new Int32Array(shadow_ground_total);
shadow_ground_total/=3;


}


shadow_ground_f[2]=function(){


let started=performance.now();


for(let n=shadow_ground_n;n<shadow_ground_ways_max;n++){


let cell_name=(shadow_ground_px+shadow_ground_ways[shadow_ground_n][0])+"_"+(shadow_ground_pz+shadow_ground_ways[shadow_ground_n][1]);


let item=shadow_ground_cell[cell_name];


if(item!=undefined){
let max=item.length;
for(let i=0;i<max;i++){
shadow_ground_a[i+shadow_ground_a_num]=item[i];
}
shadow_ground_a_num+=max;
}


shadow_ground_n=n+1;
if(performance.now()-started>2){ shadow_ground_breaks_2+=(performance.now()-started).toFixed(1)+" "; break; }


}


shadow_ground_time_2+=performance.now()-started;


if(shadow_ground_n>shadow_ground_ways_max-1){
shadow_ground_n=0;
shadow_ground_m=3;
}


}


shadow_ground_f[3]=function(){


let started=performance.now();


while(true){


let max_1=shadow_ground_i+250*3;
if(max_1>shadow_ground_a.length){
max_1=shadow_ground_a.length;
}


for(let n=shadow_ground_i;n<max_1;n+=3){
shadow_ground_v=shadow_ground_a[n]+shadow_ground_size*shadow_ground_a[n+1]+shadow_ground_mx+shadow_ground_size*shadow_ground_mz;
let data=shadow_ground_type[1];
let max_2=data.length;
for(let j=0;j<max_2;j+=2){
shadow_ground_texture[shadow_ground_v+data[j]]=data[j+1];
shadow_ground_pixels++;
}
}


if(max_1==shadow_ground_a.length){
shadow_ground_i=0;
shadow_ground_a=new Int32Array();
shadow_ground_m=4;
break;
}
else{
shadow_ground_i+=250*3;
}


if(performance.now()-started>5){ shadow_ground_breaks_3+=(performance.now()-started).toFixed(1)+" "; break; }


}


shadow_ground_time_3+=performance.now()-started;


}


shadow_ground_f[4]=function(){


let started=performance.now();


while(true){


let max=shadow_ground_bn+100000;
if(shadow_ground_bn+100000>shadow_ground_b.length){
max=shadow_ground_b.length;
}


for(let n=shadow_ground_bn;n<max;n++){
shadow_ground_texture[shadow_ground_b[n]]=255;
}


if(max==shadow_ground_b.length){
shadow_ground_bn=0;
shadow_ground_m=5;
break;
}
else{
shadow_ground_bn+=100000;
}


if(performance.now()-started>5){ shadow_ground_breaks_4+=(performance.now()-started).toFixed(1)+" "; break; }


}


shadow_ground_time_4+=performance.now()-started;


}





shadow_ground_f[5]=function(){


let started=performance.now();
tex["shadow_ground_chunk"].image.data=shadow_ground_texture.slice(shadow_ground_chunk_now*shadow_ground_chunk_pixels,(shadow_ground_chunk_now+1)*shadow_ground_chunk_pixels);
shadow_ground_breaks_5+=(performance.now()-started).toFixed(1)+" ";


started=performance.now();
renderer.copyTextureToTexture({x:0,y:shadow_ground_size-shadow_ground_size/shadow_ground_chunk_total-shadow_ground_chunk_now*shadow_ground_size/shadow_ground_chunk_total},tex["shadow_ground_chunk"],shadow_ground_tex);
shadow_ground_breaks_6+=(performance.now()-started).toFixed(1)+" ";


shadow_ground_chunk_now++;


if(shadow_ground_chunk_now==shadow_ground_chunk_total){
shadow_ground_m=6;
}


}


shadow_ground_f[6]=function(){


mat["terrain"].uniforms.shadowGroundOffset.value[0]=-shadow_ground_nx*0.125+0.5;
mat["terrain"].uniforms.shadowGroundOffset.value[1]=shadow_ground_nz*0.125-0.375;


if(shadow_ground_now==1){
shadow_ground_now=2;
shadow_ground_texture=shadow_ground_texture_1;
shadow_ground_tex=tex["shadow_ground_1"];
mat["terrain"].uniforms.shadowGroundMap.value=tex["shadow_ground_2"];
}
else{
shadow_ground_now=1;
shadow_ground_texture=shadow_ground_texture_2;
shadow_ground_tex=tex["shadow_ground_2"];
mat["terrain"].uniforms.shadowGroundMap.value=tex["shadow_ground_1"];
}


shadow_ground_m=7;
shadow_ground_end=performance.now();


}


shadow_ground_f[7]=function(){


if(performance.now()-shadow_ground_end>shadow_ground_sleep){
document.getElementById("shadow_ground_text_2").innerHTML="&nbsp;";
let text="Shadow way: "+shadow_ground_w+" Shadow time: "+Math.ceil(shadow_ground_end-shadow_ground_start)+" "+"px "+shadow_ground_px+" pz "+shadow_ground_pz;
text+="<br>Grass: "+shadow_ground_total+" / "+total_grass+" | Pixels "+shadow_ground_pixels;
text+="<br>[2] "+shadow_ground_time_2.toFixed(2)+" Breaks: "+shadow_ground_breaks_2;
text+="<br>[3] "+shadow_ground_time_3.toFixed(2)+" Breaks: "+shadow_ground_breaks_3;
text+="<br>[4] "+shadow_ground_time_4.toFixed(2)+" Breaks: "+shadow_ground_breaks_4;
text+="<br>[5] "+shadow_ground_breaks_5;
text+="<br>[6] "+shadow_ground_breaks_6;
document.getElementById("shadow_ground_text_1").innerHTML=text;
shadow_ground_m=0;
}


}


//setTimeout("player.position.z=-6.40;",8000);
//setTimeout("gravity=0;player.position.y=20;",2000);
//setTimeout("speed=0.2;",2000);
"use strict"


/*
160721 START OF DEVELOPMENT
160821 FIRST VERSION
020424 NOW TRANSMITTING ALL PARAMETERS IS MANDATORY TO AVOID CONFUSSION
210424 ADDED DynamicsCompressor. HELPS REMOVE LOUD SOUND WHEN MULTIPLE SOUNDS PLAY AT THE SAME TIME
220424 WE MANAGED TO REDUCE THE RAM USAGE WHEN USING CONVOLVER EFFECTS WITH A LARGE MIX WITH NORMAL SOUND.
FOR EXAMPLE, WE NEEDED 100 SOUNDS OF SHOT WITH ECHO EFFECT. IF WE CREATE 100 SEPARATE CONVOLVER ECHO EFFECTS, THEN THIS WILL BE ABOUT 1GB OF MEMORY.
AND IF YOU CREATE ONE ECHO EFFECT AND SIMPLY ATTACH 100 VOLUME CONTROLS TO IT, THEN 10MB.


LAUNCHING ONE SOUND WITH AND WITHOUT EFFECT TAKES 0.10 ms, 10 SOUNDS 0.50 ms, 20 SOUNDS 0.90 ms
BUT THIS IS IF YOU LAUNCH ALL 20 SOUNDS AT THE SAME TIME, AND SINCE THIS IS UNLIKELY, IT IS NORMAL.
disconnect TAKES 0 ms
WHEN CREATING A NEW FUNCTION, DO NOT FORGET TO CLEAR delete music_fade_in[name]; delete music_fade_out[name]; delete sounds_fade_in[name]; delete sounds_fade_out[name];
*/


let music_speed=1; // OVERALL MUSIC SPEED
let sounds_speed=1; // GENERAL SPEED OF SOUNDS
let music_status=1; // 0 - PAUSED, 1 - RUNNING
let sounds_status=1; // 0 - PAUSED, 1 - RUNNING


// DATA


let sound=[]; // SOUNDS IN BUFFER
let music=[]; // MUSIC PLAYING NOW
let music_fade_in=[]; // MUSIC WITH SMOOTH ENTRY
let music_fade_out=[]; // MUSIC WITH SMOOTH OUTPUT
let sounds_fade_in=[]; // SOUND WITH SMOOTH ENTRY
let sounds_fade_out=[]; // SOUND WITH SMOOTH OUTPUT
let sounds=[]; // SOUNDS PLAYING NOW
let sound_n=0; // SOUND COUNTER FOR CREATING DIFFERENT SOUND NAMES
let music_effect=[]; // EFFECTS FOR MUSIC
let sound_effect=[]; // EFFECTS FOR SOUNDS


// CONTEXT


window.AudioContext=window.AudioContext || window.webkitAudioContext;
let sounds_context=new AudioContext();
let sounds_destination=sounds_context.destination;
let sounds_listener=sounds_context.listener;


// GENERAL VOLUMES


let menu_volume=sounds_context.createGain();
menu_volume.gain.value=1; // GENERAL MENU VOLUME
menu_volume.connect(sounds_destination);
let music_volume=sounds_context.createGain();
music_volume.gain.value=1; // OVERALL MUSIC VOLUME
music_volume.connect(sounds_destination);
let sounds_volume=sounds_context.createGain();
sounds_volume.gain.value=1; // OVERALL SPEED OF SOUNDS
const compressor = sounds_context.createDynamicsCompressor();
/*
compressor.threshold.setValueAtTime(-50, sounds_context.currentTime);
compressor.knee.setValueAtTime(40, sounds_context.currentTime);
compressor.ratio.setValueAtTime(12, sounds_context.currentTime);
compressor.attack.setValueAtTime(0, sounds_context.currentTime);
compressor.release.setValueAtTime(0.25, sounds_context.currentTime);
*/
/*
compressor.threshold.setValueAtTime(-5.0,sounds_context.currentTime); // In Decibels
compressor.knee.setValueAtTime(0,sounds_context.currentTime); // In Decibels
compressor.ratio.setValueAtTime(40.0, sounds_context.currentTime); // In Decibels
compressor.attack.setValueAtTime(0.001, sounds_context.currentTime); // Time is seconds
compressor.release.setValueAtTime(0.1, sounds_context.currentTime); // Time is seconds
*/
/*
compressor.threshold.value = -50; // Threshold
compressor.knee.value = 40; // Soft/hard compression mode
compressor.ratio.value = 12; // Compression ratio
compressor.attack.value = 0.003; // Rise time
compressor.release.value = 0.25; // Decay time
*/
compressor.connect(sounds_destination);
//sounds_volume.connect(sounds_destination);
sounds_volume.connect(compressor);


// CREATE A FILTER AND VOLUMES IN ADVANCE SO WE DON'T HAVE TO CREATE EVERY TIME AND THERE ARE LESS FPS JUMPS


let sounds_biquad_i=[];
let sounds_panner_i=[];
let sounds_volume_f=[];
let sounds_volume_i=[];
let sounds_volume_n=0;


function sounds_volume_gen(amount){


let max=sounds_volume_n+amount;
for(let n=sounds_volume_n;n<max;n++){
sounds_biquad_i[n]=sounds_context.createBiquadFilter();
sounds_biquad_i[n].type="lowpass";
sounds_volume_i[n]=sounds_context.createGain();
sounds_volume_i[n].volume=1;
sounds_volume_i[n].gain.value=1;
sounds_panner_i[n]=sounds_context.createPanner();
sounds_panner_i[n].panningModel="HRTF";
sounds_panner_i[n].connect(sounds_volume_i[n]);
sounds_volume_f.push(n);
sounds_volume_n++;
}


}


// CREATE EFFECTS IN ADVANCE, BECAUSE CREATING ONE EFFECT TAKES 1-30 MS


function music_effects_gen(){


for(let n=0;n<sounds_total;n++){
let item=sounds_list[n];
if(item[1].match(/sounds\/effects/)){
music_effect[item[0]]=sounds_context.createConvolver();
music_effect[item[0]].buffer=sound[item[0]];
music_effect[item[0]].connect(music_volume);
}
}


}


function sounds_effects_gen(){


for(let n=0;n<sounds_total;n++){
let item=sounds_list[n];
if(item[1].match(/sounds\/effects/)){
sound_effect[item[0]]=sounds_context.createConvolver();
sound_effect[item[0]].buffer=sound[item[0]];
sound_effect[item[0]].connect(sounds_volume);
}
}


}


// ____________________ 3D LISTENER UPDATE ____________________


function sounds_listener_update(){


let p=camera.matrixWorld.elements,q=camera.quaternion,qx=qx,qy=qy,qz=qz,qw=qw;
sounds_listener.positionX.value=p[12];
sounds_listener.positionY.value=p[13];
sounds_listener.positionZ.value=p[14];
sounds_listener.forwardX.value=-qy*qw+qz*-qx+qx*-qz+qw*-qy;
sounds_listener.forwardY.value=qx*qw+qz*-qy-qw*-qx+qy*-qz;
sounds_listener.forwardZ.value=-qw*qw+qz*-qz-qy*-qy-qx*-qx;


}


// ____________________ 3D SOUND ORIENTATION UPDATE ____________________


// 100 UPDATES IN 0.8MS, 50 IN 0.4MS, 20 IN 0.2MS, 10 IN 0.1MS


function sounds_panner_update(item,sound_panner){


let p=item.matrixWorld.elements,q=item.quaternion,qx=qx,qy=qy,qz=qz,qw=qw;
sound_panner.positionX.value=p[12];
sound_panner.positionY.value=p[13];
sound_panner.positionZ.value=p[14];
sound_panner.orientationX.value=qy*qw-qz*-qx-qx*-qz-qw*-qy;
sound_panner.orientationY.value=-qx*qw-qz*-qy+qw*-qx-qy*-qz;
sound_panner.orientationZ.value=qw*qw-qz*-qz+qy*-qy+qx*-qx;


}


// ____________________ CHANGING THE GENERAL MENU VOLUME LEVEL ____________________


function menu_volume_set(v){


menu_volume.gain.setTargetAtTime(Number(v),sounds_context.currentTime,0.01);


}


// ____________________ PLAY SOUND IN MENU ____________________


function menu_play(track,volume,speed){


// track - WHAT SOUND TO PLAY
// volume - VOLUME // speed - PLAYBACK SPEED


let menu_sound=sounds_context.createBufferSource();
menu_sound.buffer=sound[track];
menu_sound.playbackRate.value=speed;
menu_sound.gain_i=sounds_context.createGain();
menu_sound.gain_i.gain.value=volume;
menu_sound.gain_i.connect(menu_volume);
menu_sound.connect(menu_sound.gain_i);
menu_sound.onended=function(){ this.disconnect(); this.gain_i.disconnect(); this.gain_i=null; }
menu_sound.start();


}


// ____________________ CHANGING THE OVERALL MUSIC VOLUME ____________________


function music_volume_set(v){


music_volume.gain.setTargetAtTime(Number(v),sounds_context.currentTime,0.01);


}


// ____________________ CHANGING THE OVERALL SPEED OF MUSIC ____________________


function music_speed_set(v){


music_speed=Number(v);


for(let name in music){
try{ music[name].playbackRate.value=music[name].speed*music_speed; }
catch(e){}
}


}


// ____________________ PLAY MUSIC ____________________


function music_play(name,track,loop,effect,speed,detune,volume){


// name - YOU CAN SPECIFY YOUR OWN MUSIC NAME OR null
// track - WHAT MUSIC TO PLAY
// loop - ENDLESS SOUND true OR ONE-TIME false
// effect - EFFECT NAME OR false
// speed - SPEED // detune - PITCH // volume - VOLUME

sound_n++;
let name_c;
if(name==null){ name_c=track+"_"+sound_n; }
else{ name_c=name; music_delete_fast(name); }
music[name_c]=sounds_context.createBufferSource();
let item=music[name_c];
item.buffer=sound[track];
item.loop=loop;
item.speed=speed;
item.detune.value=detune;
item.playbackRate.value=speed*music_speed*music_status;
item.gain_i=sounds_context.createGain();
item.gain_i.gain.value=volume;
item.volume=volume;
if(effect){
item.gain_i.connect(music_effect[effect]);
}
else{
item.gain_i.connect(music_volume);
}
item.connect(item.gain_i);
// onended FIRES WHEN stop() IS CALLED AND WHEN THE SOUND ENDS AND WHEN THE VALUE OF start(999) IS GREATER THAN THE DURATION OF THE SOUND
item.onended=function(){
try{
delete music_fade_in[name_c];
delete music_fade_out[name_c];
music[name_c].disconnect();
music[name_c].gain_i.disconnect();
music[name_c].gain_i=null;
delete music[name_c];
}
catch(e){}
}
item.start();
return name_c;


}


// ____________________ PAUSE ONE MUSIC OR ALL ____________________


function music_pause(name){


if(name){
try{ music[name].playbackRate.value=0; return true; }
catch(e){ return false; }
}
else{
music_status=0;
for(let name in music){
try{ music[name].playbackRate.value=0; }
catch(e){}
}
}


}


// ____________________ RESUME ONE MUSIC OR ALL ____________________


function music_resume(name){


if(name){
try{ music[name].playbackRate.value=music[name].speed*music_speed; return true; }
catch(e){ return false; }
}
else{
music_status=1;
for(let name in music){
try{ music[name].playbackRate.value=music[name].speed*music_speed; }
catch(e){}
}
}


}


// ____________________ DELETE ONE MUSIC OR ALL - AT ONCE AND POSSIBLY WITH A WHEEZE ____________________


function music_delete_fast(name){


if(name){
try{ delete music_fade_in[name]; delete music_fade_out[name]; music[name].onended=null; music[name].stop(); music[name].disconnect(); music[name].gain_i.disconnect(); music[name].gain_i=null; delete music[name]; return true; }
catch(e){ return false; }
}
else{
music_fade_in=[];
music_fade_out=[];
for(let name in music){
try{ music[name].onended=null; music[name].stop(); music[name].disconnect(); music[name].gain_i.disconnect(); music[name].gain_i=null; delete music[name]; }
catch(e){}
}
}


}


// ____________________ DELETE ONE MUSIC OR ALL - SLOWLY AND WITHOUT WHEEZING ____________________


function music_delete_slow(name,time){


// name - MUSIC NAME FROM ARRAY music. OR "all" - ALL
// time - HOW LONG TO EXECUTE IN SECONDS. OR LEAVE BLANK, THEN THE DEFAULT TIME IS 0.01 SECOND


if(time<0.01){ time=0.01; }
if(name!="all"){
try{
delete music_fade_in[name];
delete music_fade_out[name];
music[name].gain_i.gain.setTargetAtTime(0,sounds_context.currentTime,time);
music[name].stop(sounds_context.currentTime+time);
return true;
}
catch(e){ return false; }
}
else{
music_fade_in=[];
music_fade_out=[];
for(let name in music){
try{
music[name].gain_i.gain.setTargetAtTime(0,sounds_context.currentTime,time);
music[name].stop(sounds_context.currentTime+time);
}
catch(e){}
}
}


}


// ____________________ SMOOTH MUSIC ENTRY ____________________


function music_fade_in_set(name,time,volume,speed){


// name - NAME OF MUSIC FROM ARRAY music, OR "all" - ALL
// time - HOW LONG TO EXECUTE IN MILLISECONDS. IF WHEEZING APPEARS, THEN SET MORE
// volume - SMOOTH ENTRY TO THE SPECIFIED VOLUME, OR -1, IE MUSIC WAS PAUSED AND NOW WE NEED TO RETURN THE VOLUME TO THE SAME VOLUME AS IT WAS
// speed - SPEED

if(name!="all"){
if(!music[name]){ return false; }
try{
music[name].speed=speed;
music[name].playbackRate.value=speed*music_speed*music_status;
}
catch(e){}
delete music_fade_in[name];
delete music_fade_out[name];
music_fade_in[name]={};
let item=music_fade_in[name];
item.time_total=time;
item.time_elapsed=0;
try{
item.volume_first=music[name].volume;
item.volume_in=volume-item.volume_first;
item.volume_to=volume;
if(volume<item.volume_first){ item.volume_in=0; }
if(volume==-1){ item.volume_in=item.volume_first; item.volume_first=0; item.volume_to=item.volume_in; }
return true;
}
catch(e){ delete music_fade_in[name]; return false; }
}
else{
music_fade_in=[];
music_fade_out=[];
for(let name in music){
try{
music[name].speed=speed;
music[name].playbackRate.value=speed*music_speed*music_status;
}
catch(e){}
music_fade_in[name]={};
let item=music_fade_in[name];
item.time_total=time;
item.time_elapsed=0;
try{
item.volume_first=music[name].volume;
item.volume_in=volume-item.volume_first;
item.volume_to=volume;
if(volume<item.volume_first){ item.volume_in=0; }
if(volume==-1){ item.volume_in=item.volume_first; item.volume_first=0; item.volume_to=item.volume_in; }
}
catch(e){ delete music_fade_in[name]; }
}
}


}


function music_fade_in_update(){


for(let name in music_fade_in){


let item=music_fade_in[name];
item.time_elapsed+=delta;
let volume=item.volume_first+item.volume_in*(item.time_elapsed/item.time_total);
if(volume>item.volume_to){ volume=item.volume_to; }
if(item.time_elapsed>=item.time_total){ volume=item.volume_to; delete music_fade_in[name]; }
try{
music[name].volume=volume;
music[name].gain_i.gain.value=volume;
}
catch(e){}


}


}


// ____________________ SMOOTH MUSIC OUTPUT ____________________


function music_fade_out_set(name,time,action){


// name - NAME OF MUSIC FROM ARRAY music, OR "all" - ALL
// time - HOW LONG TO COMPLETE IN MILLISECONDS. IF WHEEZING APPEARS, THEN SET MORE
// action - ACTION AT END: 0 - NOTHING, 1 - PAUSE, 2 - DELETE

if(name!="all"){
if(!music[name]){ return false; }
delete music_fade_in[name];
delete music_fade_out[name];
music_fade_out[name]={};
let item=music_fade_out[name];
item.time_total=time;
item.time_elapsed=0;
item.action=action;
try{ item.volume=music[name].volume; return true; }
catch(e){ delete music_fade_out[name]; return false; }
}
else{
music_fade_in=[];
music_fade_out=[];
for(let name in music){
music_fade_out[name]={};
let item=music_fade_out[name];
item.time_total=time;
item.time_elapsed=0;
item.action=action;
try{ item.volume=music[name].volume; }
catch(e){ delete music_fade_out[name]; }
}
}

}


function music_fade_out_update(){


for(let name in music_fade_out){


let item=music_fade_out[name];
item.time_elapsed+=delta;
let volume=item.volume*(1-item.time_elapsed/item.time_total);
if(0>volume){ volume=0; }
try{
music[name].volume=volume;
music[name].gain_i.gain.value=volume;
}
catch(e){}
if(item.time_elapsed>=item.time_total){
delete music_fade_out[name];
if(item.action==1){ music[name].playbackRate.value=0; }
if(item.action==2){ music_delete_fast(name); }
}


}


}


// ____________________ CHANGING THE OVERALL SOUND VOLUME ____________________


function sounds_volume_set(v){


sounds_volume.gain.setTargetAtTime(Number(v),sounds_context.currentTime,0.01);


}


// ____________________ CHANGING THE OVERALL SPEED OF SOUNDS ____________________


function sounds_speed_set(v){


sounds_speed=Number(v);


for(let name in sounds){
try{ sounds[name].playbackRate.value=sounds[name].speed*sounds_speed; }
catch(e){}
}


}


// ____________________ PLAY 2D OR 3D SOUND ____________________


function sounds_play(name,track,loop,effect,speed,detune,volume,frequency,type,distance,object,coneInnerAngle,coneOuterAngle,coneOuterGain,refDistance,rolloffFactor){


// name - YOU CAN SPECIFY YOUR OWN SOUND NAME OR null
// track - WHAT SOUND TO PLAY
// loop - ENDLESS SOUND true OR ONE-TIME false
// effect - EFFECT NAME OR false
// speed - SPEED // detune - PITCH, FOR EXAMPLE, FOR SOUND BEHIND A WALL OR IN THE DISTANCE
// volume - VOLUME // frequency - FREQUENCY, FOR EXAMPLE, FOR SOUND BEHIND A WALL OR IN THE DISTANCE. IF YOU DO NOT PLAN TO CHANGE, THEN false
// object - FOR 3D SOUND WE TRANSMIT MESH OR SOMETHING SIMILAR. IF 2D, THEN false
// coneInnerAngle - INNER CORNER. DEFAULT 360
// coneOuterAngle - OUTER CORNER WHEN YOU ARE BEHIND THE SOUNDING OBJECT. DEFAULT 360
// coneOuterGain - OUTER CORNER VOLUME LEVEL WHEN YOU ARE BEHIND THE SOUNDING OBJECT - OUTER CORNER. 0-1. DEFAULT 0
// refDistance - DISTANCE FROM WHICH THE SOUND WILL DECREASE. DEFAULT 1
// rolloffFactor - HOW FAST THE SOUND VOLUME SHOULD DECREASE, STARTING FROM refDistance. DEFAULT 1


sound_n++;
let name_c;
if(name==null){ name_c=track+"_"+sound_n; }
else{ name_c=name; sounds_delete_fast(name); }
sounds[name_c]=sounds_context.createBufferSource();
let item=sounds[name_c];
item.buffer=sound[track];
item.loop=loop;
item.speed=speed;
item.detune.value=detune;
item.playbackRate.value=speed*sounds_speed*sounds_status;
let volume_n=sounds_volume_f.pop();
if(volume_n==undefined){ sounds_volume_gen(10); volume_n=sounds_volume_f.pop(); console.log("Few sounds_volume_f. Changed to: "+sounds_volume_n); }
let volume_g=sounds_volume_i[volume_n];
volume_g.volume=volume;
volume_g.gain.value=volume;


if(effect){


if(frequency===false){
volume_g.connect(sound_effect[effect]);
}
else{
sounds_biquad_i[volume_n].connect(sound_effect[effect]);
volume_g.connect(sounds_biquad_i[volume_n]);
}


}
else{


if(frequency===false){
volume_g.connect(sounds_volume);
}
else{
sounds_biquad_i[volume_n].connect(sounds_volume);
volume_g.connect(sounds_biquad_i[volume_n]);
}


}


if(frequency!==false){ sounds_biquad_i[volume_n].frequency.value=frequency; }


if(object){
let panner=sounds_panner_i[volume_n];
panner.coneInnerAngle=coneInnerAngle;
panner.coneOuterAngle=coneOuterAngle;
panner.coneOuterGain=coneOuterGain;
panner.refDistance=refDistance;
panner.rolloffFactor=rolloffFactor;
// IMMEDIATELY UPDATE THE SOUND POSITION
sounds_panner_update(object,panner);
item.connect(panner);
}
else{
item.connect(volume_g);
}


item.n=volume_n;
// onended FIRES WHEN stop() IS CALLED AND WHEN THE SOUND ENDS AND WHEN THE VALUE OF start(999) IS GREATER THAN THE DURATION OF THE SOUND
item.onended=function(){
try{
delete sounds_fade_in[name_c];
delete sounds_fade_out[name_c];
sounds[name_c].disconnect();
sounds_volume_i[sounds[name_c].n].disconnect();
sounds_biquad_i[sounds[name_c].n].disconnect();
sounds_volume_f.push(sounds[name_c].n);
delete sounds[name_c];
}
catch(e){}
}
item.start();
return name_c;


}


// ____________________ PAUSE ONE SOUND OR ALL ____________________


function sounds_pause(name){


if(name){
try{ sounds[name].playbackRate.value=0; return true; }
catch(e){ return false; }
}
else{
sounds_status=0;
for(let name in sounds){
try{ sounds[name].playbackRate.value=0; }
catch(e){}
}
}


}


// ____________________ RESUME ONE SOUND OR ALL ____________________


function sounds_resume(name){


if(name){
try{ sounds[name].playbackRate.value=sounds[name].speed*sounds_speed; return true; }
catch(e){ return false; }
}
else{
sounds_status=1;
for(let name in sounds){
try{ sounds[name].playbackRate.value=sounds[name].speed*sounds_speed;}
catch(e){}
}
}


}


// ____________________ REMOVE ONE SOUND OR ALL - AT ONCE AND POSSIBLY WITH A WHEEZING SOUND ____________________


function sounds_delete_fast(name){


if(name){
try{ delete sounds_fade_in[name]; delete sounds_fade_out[name]; sounds[name].onended=null; sounds[name].stop(); sounds[name].disconnect(); sounds_volume_i[sounds[name].n].disconnect(); sounds_volume_f.push(sounds[name].n); delete sounds[name]; return true; }
catch(e){ return false; }
}
else{
sounds_fade_in=[];
sounds_fade_out=[];
for(let name in sounds){
try{ sounds[name].onended=null; sounds[name].stop(); sounds[name].disconnect(); sounds_volume_i[sounds[name].n].disconnect(); sounds_volume_f.push(sounds[name].n); delete sounds[name]; }
catch(e){}
}
}


}


// ____________________ REMOVE ONE SOUND OR ALL - SLOWLY AND WITHOUT WHEEZING ____________________


function sounds_delete_slow(name,time){


// name - SOUND NAME FROM sounds ARRAY. OR "all" - ALL
// time - HOW LONG TO EXECUTE IN SECONDS. OR LEAVE BLANK, THEN THE DEFAULT TIME IS 0.01 SECOND


if(time<0.01){ time=0.01; }
if(name!="all"){
try{
delete sounds_fade_in[name];
delete sounds_fade_out[name];
sounds_volume_i[sounds[name].n].gain.setTargetAtTime(0,sounds_context.currentTime,time);
sounds[name].stop(sounds_context.currentTime+time);
return true;
}
catch(e){ return false; }
}
else{
sounds_fade_in=[];
sounds_fade_out=[];
for(let name in sounds){
try{
sounds_volume_i[sounds[name].n].gain.setTargetAtTime(0,sounds_context.currentTime,time);
sounds[name].stop(sounds_context.currentTime+time);
}
catch(e){}
}
}


}


// ____________________ SMOOTH SOUND ENTRY ____________________


function sounds_fade_in_set(name,time,volume,speed){


// name - NAME OF SOUND FROM ARRAY sounds, OR "all" - ALL
// time - HOW LONG TO EXECUTE IN MILLISECONDS. IF WHEEZING APPEARS, THEN SET MORE
// volume - SMOOTH ENTRY TO THE SPECIFIED VOLUME, OR -1, IE THE SOUND WAS PAUSED AND NOW WE NEED TO RETURN THE VOLUME TO THE SAME ONE AS IT WAS
// speed - SPEED

if(name!="all"){
if(!sounds[name]){ return false; }
try{
sounds[name].speed=speed;
sounds[name].playbackRate.value=speed*sounds_speed*sounds_status;
}
catch(e){}
delete sounds_fade_in[name];
delete sounds_fade_out[name];
sounds_fade_in[name]={};
let item=sounds_fade_in[name];
item.time_total=time;
item.time_elapsed=0;
try{
item.volume_first=sounds_volume_i[sounds[name].n].volume;
item.volume_in=volume-item.volume_first;
item.volume_to=volume;
if(volume<item.volume_first){ item.volume_in=0; }
if(volume==-1){ item.volume_in=item.volume_first; item.volume_first=0; item.volume_to=item.volume_in; }
return true;
}
catch(e){ delete sounds_fade_in[name]; return false; }
}
else{
sounds_fade_in=[];
sounds_fade_out=[];
for(let name in sounds){
try{
sounds[name].speed=speed;
sounds[name].playbackRate.value=speed*sounds_speed*sounds_status;
}
catch(e){}
sounds_fade_in[name]={};
let item=sounds_fade_in[name];
item.time_total=time;
item.time_elapsed=0;
try{
item.volume_first=sounds_volume_i[sounds[name].n].volume;
item.volume_in=volume-item.volume_first;
item.volume_to=volume;
if(volume<item.volume_first){ item.volume_in=0; }
if(volume==-1){ item.volume_in=item.volume_first; item.volume_first=0; item.volume_to=item.volume_in; }
}
catch(e){ delete sounds_fade_in[name]; }
}
}


}


function sounds_fade_in_update(){


for(let name in sounds_fade_in){


let item=sounds_fade_in[name];
item.time_elapsed+=delta;
let volume=item.volume_first+item.volume_in*(item.time_elapsed/item.time_total);
if(volume>item.volume_to){ volume=item.volume_to; }
if(item.time_elapsed>=item.time_total){ volume=item.volume_to; delete sounds_fade_in[name]; }
try{
sounds_volume_i[sounds[name].n].volume=volume;
sounds_volume_i[sounds[name].n].gain.value=volume;
}
catch(e){}


}


}


// ____________________ SMOOTH SOUND OUTPUT OF ONE OR ALL ____________________


function sounds_fade_out_set(name,time,action){


// name - NAME OF SOUND FROM ARRAY sounds, OR "all" - ALL
// time - HOW LONG TO COMPLETE IN MILLISECONDS. IF WHEEZING APPEARS, THEN SET MORE
// action - ACTION AT END: 0 - NOTHING, 1 - PAUSE, 2 - DELETE

if(name!="all"){
if(!sounds[name]){ return false; }
delete sounds_fade_in[name];
delete sounds_fade_out[name];
sounds_fade_out[name]={};
let item=sounds_fade_out[name];
item.time_total=time;
item.time_elapsed=0;
item.action=action;
try{ item.volume=sounds_volume_i[sounds[name].n].volume; return true; }
catch(e){ delete sounds_fade_out[name]; return false; }
}
else{
sounds_fade_in=[];
sounds_fade_out=[];
for(let name in sounds){
sounds_fade_out[name]={};
let item=sounds_fade_out[name];
item.time_total=time;
item.time_elapsed=0;
item.action=action;
try{ item.volume=sounds_volume_i[sounds[name].n].volume; }
catch(e){ delete sounds_fade_out[name]; }
}
}

}


function sounds_fade_out_update(){


for(let name in sounds_fade_out){


let item=sounds_fade_out[name];
item.time_elapsed+=delta;
let volume=item.volume*(1-item.time_elapsed/item.time_total);
if(0>volume){ volume=0; }
try{
sounds_volume_i[sounds[name].n].volume=volume;
sounds_volume_i[sounds[name].n].gain.value=volume;
}
catch(e){}
if(item.time_elapsed>=item.time_total){
delete sounds_fade_out[name];
if(item.action==1){ sounds[name].playbackRate.value=0; }
if(item.action==2){ sounds_delete_fast(name); }
}


}


}let fogColor=[Number((128/255).toFixed(2)),Number((174/255).toFixed(2)),Number((197/255).toFixed(2))];


let ambient;
let hemiLight;
let sun;


let sun_offset_distance=500; 
let sun_shadow_dection_distance=20;
let sun_direction=new THREE.Vector3();
let sun_section_x=-Infinity;
let sun_section_z=-Infinity;
// POSTPROCESS
let sun_clip_position=new THREE.Vector4();
let sun_3d_position={x:0,y:0,z:0};
let sun_2d_position={x:0,y:0};


function set_lights(){


ambient=new THREE.AmbientLight(0x7c94b2,3.0);
scene.add(ambient);
scene_2.children.push(ambient);


scene.fog=new THREE.Fog(0x96bbc8,200,750);


sun=new THREE.DirectionalLight(0xFFEBAE,5.4);
sun.position.set(60,100,60);
sun.castShadow=true;
sun.shadow.mapSize.width=2048; 
sun.shadow.mapSize.height=2048; 
sun.shadow.camera.near=1.0;
sun.shadow.camera.far=2000;
sun.shadow.camera.left=-200;
sun.shadow.camera.right=200;
sun.shadow.camera.top=200;
sun.shadow.camera.bottom=-200;
sun.shadow.bias=-0.00004;
sun.shadow.radius=0.2; // 1 - DEFAULT
sun.shadow.blurSamples=2; // 8 - DEFAULT
sun.shadow.needsUpdate=true;
sun.shadow.autoUpdate=true;
scene.add(sun);
scene_2.children.push(sun);


sun_direction.set(sun.position.x,sun.position.y,sun.position.z).normalize();


let dhelper=new THREE.DirectionalLightHelper(sun,1);
//scene.add(dhelper);


let shadow_camera=new THREE.CameraHelper(sun.shadow.camera);
//scene.add(shadow_camera);


//hemiLight=new THREE.HemisphereLight(0xFEEFC2,0x444444,3);
//hemiLight.position.set(0,2,0);
//scene.add(hemiLight);


//let hemiLightHelper=new THREE.HemisphereLightHelper(hemiLight,0.2);
//scene.add(hemiLightHelper);


}


function sun_direction_upadte(){
	
	
let dir=camera.matrixWorld.elements;
sun_direction.set(-dir[8],-dir[9],-dir[10]);
sun_position_update_now();


}


function sun_position_update(){


let sun_now_section_x=Math.floor(camera.position.x/2);
let sun_now_section_z=Math.floor(camera.position.z/2);


let distance=Math.sqrt((sun_section_x-camera.position.x)**2+(sun_section_z-camera.position.z)**2);


if(distance>sun_shadow_dection_distance){
sun_position_update_now();
}


}


function sun_position_update_now(){
	
	
sun_section_x=camera.position.x;
sun_section_z=camera.position.z;
sun.position.set(sun_direction.x,sun_direction.y,sun_direction.z).multiplyScalar(sun_offset_distance);	
sun.position.add(camera.position);
sun.target.position.set(camera.position.x,camera.position.y,camera.position.z);
sun.target.updateMatrixWorld();
sun.shadow.camera.updateMatrixWorld();
sun.shadow.camera.updateProjectionMatrix();	


}


function sun_clip_position_update(){
	
	
sun_clip_position.set(sun_direction.x,sun_direction.y,sun_direction.z,0);	
sun_clip_position.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
sun_clip_position.x=(sun_clip_position.x/sun_clip_position.w+1)/2;
sun_clip_position.y=(sun_clip_position.y/sun_clip_position.w+1)/2;
let sun_visible=sun_clip_position.z>0;
sun_3d_position.x=sun_visible?sun_clip_position.x:-1;
sun_3d_position.y=sun_visible?sun_clip_position.y:-1;
sun_3d_position.z=sun_visible?sun_clip_position.z:-1;
sun_2d_position.x=(sun_clip_position.x*2-1)*screen_aspect_ratio;
sun_2d_position.y=sun_clip_position.y*2-1;

	
}

"use strict"


let sounds_list=[


// ____________________ EFFECTS ____________________


//["name","./sounds/effects/name.mp3"],


// ____________________ MENU ____________________


//["name","./sounds/menu/name.mp3"],


// ____________________ MUSIC ____________________


//["name","./sounds/music/name.mp3"],


// ____________________ SOUNDS ____________________


//["name","./sounds/sounds/name.mp3"],
["shader_changed","./sounds/sounds/sound_level_complete_1star.mp3"],
["run_grass","./sounds/sounds/run_grass.mp3"],
["gun","./sounds/sounds/gun.mp3"],


];
"use strict"


//____________________ TEXTURE AND MODEL LOADER ____________________


let loader_textures_show=1; // 0 - DO NOT DISPLAY TEXTURE LIST IN CONSOLE, 1 - DISPLAY
let loader_models_show=1; // 0 - DO NOT DISPLAY THE LIST OF MODELS IN THE CONSOLE, 1 - DISPLAY
let loader_sounds_show=1; // 0 - DO NOT DISPLAY THE LIST OF SOUNDS IN THE CONSOLE, 1 - DISPLAY


let loader_total=0; // HOW MUCH SHOULD WE LOAD?
let loader_loaded=0; // HOW MUCH IS LOADED
let loader_textures_loaded=0; // HOW MANY TEXTURES ARE LOADED
let loader_models_loaded=0; // HOW MANY MODELS ARE LOADED
let loader_sounds_loaded=0; // HOW MANY SOUNDS LOADED
let loader_errors=0; // 0 - NO ERRORS, 1 - THERE ARE


//____________________ DOWNLOAD MANAGER ____________________


let loadingManager=new THREE.LoadingManager();


loadingManager.onError=function(item,loaded,total){
loader_errors=1;
console.log("%c"+item,"font-weight:bold;color:#ff0000");
loadingManager=function(){};
}


//____________________ DOWNLOAD COUNTER ____________________


loadingManager.itemStart=function(item){
loader_total++;
}


loadingManager.onProgress=function(item,loaded,total){


let found=0;


if(item.match(/(\.jpe?g($|\?)|\.png($|\?)|\.gif($|\?)|\.bmp($|\?)|\.dds($|\?)|\.hdr($|\?))/gi)){
found=1;
loader_textures_loaded++;
if(loader_textures_show){ console.log("%c"+item,"font-weight:bold;color:#004090"); }
}


if(item.match(/(\.obj($|\?)|\.fbx($|\?)|\.gltf($|\?)|\.glb($|\?)|\.bin($|\?))/gi)){
found=1;
loader_models_loaded++;
if(loader_models_show){ console.log("%c"+item,"font-weight:bold;color:#448A44"); }
}


if(item.match(/(\.ogg($|\?)|\.mp3($|\?)|\.wav($|\?))/gi)){
found=1;
loader_sounds_loaded++;
if(loader_sounds_show){ console.log("%c"+item,"font-weight:bold;color:#A73CEE"); }
}


if(found==0){ console.log("%c ADD THIS FILE FORMAT: "+item+" ","background:#ff0000;color:#ffffff"); return; }


loader_loaded++;


};


//____________________ WE START THE FILE DOWNLOAD CHECK WHEN THE PAGE IS COMPLETELY LOADED ____________________


document.addEventListener("DOMContentLoaded",()=>{
loader_check();
});


//____________________ CHECKING FILE DOWNLOADING ____________________


function loader_check(){


document.getElementById("loading_amount").innerHTML=loader_loaded+"/"+loader_total;


if(loader_total==loader_loaded){
if(loader_errors){ document.getElementById("loading").innerHTML="Loading error"; }
else{
console.log("%c TEXTURE: "+loader_textures_loaded+" ","background:#222;font-weight:bold;color:#bada55");
console.log("%c MODELS: "+loader_models_loaded+" ","background:#222;font-weight:bold;color:#bada55");
console.log("%c SOUNDS: "+loader_sounds_loaded+" ","background:#222;font-weight:bold;color:#bada55");
console.log("%c TOTAL: "+loader_total+" ","background:#222;font-weight:bold;color:#bada55");
console.log("%c --> ALL LOADED <-- ","background:#222;font-weight:bold;color:#bada55;");
setTimeout(()=>{ init_core(); init_end(); },100);
}
return;
}


requestAnimationFrame(loader_check);


}


//____________________ SOUNDS ____________________


let sounds_total=sounds_list.length;


//____________________ SOUND LOADER ____________________


const sounds_loader=new THREE.FileLoader(loadingManager);
sounds_loader.setResponseType("arraybuffer");


for(let n=0;n<sounds_total;n++){


sounds_loader.load(sounds_list[n][1],function(buffer){
try{
const bufferCopy=buffer.slice(0);
sounds_context.decodeAudioData(bufferCopy,function(decoded_buffer){
sound[sounds_list[n][0]]=decoded_buffer;
});
}
catch(e){}
});


}let screen_width=screen.width;
let screen_height=screen.height;
let canvas_half_width=screen_width/2;
let canvas_half_height=screen_height/2;
let screen_resolution=[screen_width,screen_height];
let screen_aspect_ratio=screen_width/screen_height;
let screen_texel_size=[1.0/screen_width,1.0/screen_height];
let renderer_pixel_ratio=window.devicePixelRatio;


let vs=[]; 
let fs=[]; 
let mat=[];
let mesh=[];
let helper=[];
let dummy=[]; 
let uniforms=[]; 
let modules_to_resize=[];
let mixers=[];
let mixer=[];
let action=[];
let environment_main;


loadingManager.init_core=init_core;
loadingManager.init_end=init_end;


function key(which,to){
if(which==90 && voice_enabled==1){
if(to==1){ voice_start(); }
else{ voice_stop(); }
}
if(which==32 && jump_can==1){
jump_can=0;
player.velocity.y=6;
}
if(which==65){ go_left=to; }
if(which==87){ go_up=to; }
if(which==68){ go_right=to; }
if(which==83){ go_down=to; }


if(which==69 && !stop){
sun_direction_upadte();	
}


}


document.onkeydown=function(e){ key(event.keyCode,1); }
document.onkeyup=function(e){ key(event.keyCode,0); }


let canvas=document.getElementById("canvas");


let stats=new Stats();
document.getElementById("project").appendChild(stats.dom);


document.getElementById("project").appendChild(renderer_stats_canvas);


let clock=new THREE.Clock();
let delta=0;


let camera=new THREE.PerspectiveCamera(60,screen_aspect_ratio,0.05,1000);


let scene_hud=new THREE.Scene();
let camera_hud=new THREE.OrthographicCamera(screen_width/-2,screen_width/2,screen_height/2,screen_height/-2,0,1000000);
camera_hud.position.z=100000;


let scene_2=new THREE.Scene();


let renderer=new THREE.WebGLRenderer({canvas:canvas,antialias:true,alpha:true,premultipliedAlpha:true,logarithmicDepthBuffer:false});
renderer.setClearColor(0x000000,0); 
renderer.setSize(screen_width,screen_height);
renderer.setPixelRatio(renderer_pixel_ratio);
renderer.autoClear=false;
renderer.shadowMap.enabled=true;
renderer.shadowMap.type=THREE.VSMShadowMap;
//renderer.shadowMap.autoUpdate=false;
//renderer.shadowMap.needsUpdate=true;


let gpuPanel;
window.gpuPanel=gpuPanel=new GPUStatsPanel(renderer.getContext());
window.gpuPanel_shader_name=""; 
stats.addPanel(gpuPanel);


let scene=new THREE.Scene();


function on_window_resize(){


screen_width=canvas.width;
screen_height=canvas.height;
canvas_half_width=screen_width/2;
canvas_half_height=screen_height/2;
screen_resolution=[screen_width,screen_height];
screen_aspect_ratio=screen_width/screen_height;
screen_texel_size=[1.0/screen_width,1.0/screen_height];


camera.aspect=screen_aspect_ratio;
camera.updateProjectionMatrix();


camera_hud.left=screen_width/-2;
camera_hud.right=screen_width/2;
camera_hud.top=screen_height/2;
camera_hud.bottom=screen_height/-2;
camera_hud.updateProjectionMatrix();


renderer.setSize(screen_width,screen_height);


let max=modules_to_resize.length;
for(let n=0;n<max;n++){
modules_to_resize[n]();
}


}


renderer.info.autoReset=false;


let rtt_shadow=new THREE.WebGLRenderTarget(1024,1024,{format:THREE.RedFormat,type:THREE.UnsignedByteType,depthBuffer:false});


let render_pass=new RenderPass(scene,camera);


// ____________________ POSTPROCESSING ____________________


let composer_rtt=new THREE.WebGLRenderTarget(screen_width,screen_height);
composer_rtt.texture.type=THREE.HalfFloatType;
composer_rtt.texture.generateMipmaps=false;


let composer=new EffectComposer(renderer,composer_rtt);
composer.readBuffer.depthBuffer=true;
composer.readBuffer.depthTexture=new THREE.DepthTexture();
composer.readBuffer.depthTexture.type=THREE.FloatType;
composer.writeBuffer.depthBuffer=true;
composer.writeBuffer.depthTexture=new THREE.DepthTexture();
composer.writeBuffer.depthTexture.type=THREE.FloatType;


modules_to_resize.push(()=>{
composer.setSize(screen_width,screen_height);
});


let underwater_pass=new ShaderPass(underwater_shader);
let underwater_ripples_pass=new ShaderPass(underwater_ripples_shader);


let unrealbloom_pass=new UnrealBloomPass({x:screen_width,y:screen_height},0,0,0);
unrealbloom_pass.threshold=5;
unrealbloom_pass.strength=0.7;
unrealbloom_pass.radius=0;


modules_to_resize.push(()=>{
unrealbloom_pass.setSize(screen_width,screen_height);
});


let correction_pass=new ShaderPass(correction_shader);
correction_pass.material.uniforms.color.value=[1,1,1];
correction_pass.material.uniforms.saturation.value=1.2;
correction_pass.material.uniforms.vibrance.value=0.0;
correction_pass.material.uniforms.gamma.value=1.0;
correction_pass.material.uniforms.brightness.value=0.0;
correction_pass.material.uniforms.contrast.value=0.1;
correction_pass.material.uniforms.vignette.value=0.0;


let fxaa_pass=new ShaderPass(FXAAShader);
fxaa_pass.material.uniforms.resolution.value.x=1/(screen_width*renderer_pixel_ratio);
fxaa_pass.material.uniforms.resolution.value.y=1/(screen_height*renderer_pixel_ratio);


modules_to_resize.push(()=>{
fxaa_pass.material.uniforms.resolution.value.x=1/(screen_width*renderer_pixel_ratio);
fxaa_pass.material.uniforms.resolution.value.y=1/(screen_height*renderer_pixel_ratio);
});


composer.addPass(render_pass);
composer.addPass(underwater_pass);
composer.addPass(underwater_ripples_pass);
composer.addPass(correction_pass);
composer.addPass(unrealbloom_pass);
composer.addPass(fxaa_pass);


let gun_light=new THREE.PointLight(0xffc000,0.0,3.0,1.0);
gun_light.position.set(0.01,0.003,-0.001);
let gunh=new THREE.PointLightHelper(gun_light,0.001);
scene.add(gunh);


let ghj=new THREE.PointLight(0xffc000,1.0,3.0,1.0);
ghj.position.set(-1.34,2.35,-19.38);
scene.add(ghj);


document.addEventListener("mousedown",()=>{


if(gun_light.intensity==0){
sounds_play(null,"gun",false,false,1,0,1,false,"","");
gun_light.intensity=5;
setTimeout(()=>{ gun_light.intensity=0; },50);
}


},false);


let audioLoader=new THREE.AudioLoader();


let go_left=0,go_right=0,go_up=0,go_down=0;
let player={};
player.position={x:23,y:100,z:0.2};
player.direction={x:0,y:0,z:-1};
player.velocity={x:0,y:0,z:0};
player.angle={z:90,y:0};
player.speed=0.1;
let radian=Math.PI/180;
let go_half;


let go_lrc=Math.cos((player.angle.y)*radian)*player.speed;
let go_lrs=Math.sin((player.angle.y)*radian)*player.speed;
let go_udc=Math.cos((player.angle.y+90)*radian)*player.speed;
let go_uds=Math.sin((player.angle.y+90)*radian)*player.speed;



let start_time=Date.now();
let time=0;


let jump_can=1;
let gravity=1;
let pause=0;
let mouse_sensitive=0.12; 


gravity=0;
player.position.y=1.5;


let ray_floor=new THREE.Raycaster();
ray_floor.ray.direction.set(0,-1,0);
ray_floor.far=0.5;


let direction={x:0,y:0,z:0};


let section_100_x=-1;
let section_100_z=0;
let p_section_100_x=0;
let p_section_100_z=0;


let section_100_objects=[];
let ways_9=[[-1,-1],[0,-1],[1,-1],[-1,0],[0,0],[1,0],[-1,1],[0,1],[1,1]];
let ways_25=[
[-2,-2],[-1,-2],[0,-2],[1,-2],[2,-2],
[-2,-1],[-1,-1],[0,-1],[1,-1],[2,-1],
[-2,0],[-1,0],[0,0],[1,0],[2,0],
[-2,1],[-1,1],[0,1],[1,1],[2,1],
[-2,2],[-1,2],[0,2],[1,2],[2,2],
];


mesh["axes"]=new THREE.AxesHelper(100);
mesh["axes"].position.set(0,5,0);
scene.add(mesh["axes"]);


mesh["grid_100"]=new THREE.GridHelper(600,6,0x0000ff,0x00ff00);
mesh["grid_100"].position.set(0,2,0);
//scene.add(mesh["grid_100"]);


/*
let listener=new THREE.AudioListener();
camera.add(listener);


let positionalAudio=new THREE.PositionalAudio(listener);
positionalAudio.position.set(3,1,0);
positionalAudio.setRefDistance(1);
positionalAudio.setRolloffFactor(1);
positionalAudio.setDirectionalCone(180,230,0.1);
positionalAudio.loop=true;
let helper=new PositionalAudioHelper(positionalAudio,1.0);
positionalAudio.add(helper);
scene.add(positionalAudio);


positionalAudio.setBuffer(sound["run_grass"]);
*/

/*

positionalAudio.position.set(18,2,53);
setInterval("try{positionalAudio.position.z=53+Math.sin(performance.now()/100)*5;sounds_listener_update();sounds_panner_update(positionalAudio,sounds_panner_i[9],0);}catch(e){}",20);


sounds_delete_fast("bb");
positionalAudio.play();



sounds_delete_fast("bb");
positionalAudio.stop();
time_delta=0;
sounds_play("bb","run_grass",true,false,1,0,1,false,"","",positionalAudio,180,230,0.1,1,1);


let min=9090;
for(let z=0;z<100;z++){
let started=performance.now();
for(let n=0;n<1000;n++){
sounds_panner_update(positionalAudio,sounds_panner_i[9],0);
}
let elap=performance.now()-started;
if(min>elap){ min=elap; }
}
console.log(min);

*/



function fullscreen_pointerlock(){
if(!document.pointerLockElement){
try{
document.body.requestPointerLock();
}
catch(e){}
}
if(!document.fullscreenElement){ document.documentElement.requestFullscreen(); }
else if(document.exitFullscreen){ document.exitFullscreen(); }
}



document.addEventListener("mousemove",(event)=>{
if(document.pointerLockElement===document.body){ updatePosition(event); }
});



function updatePosition(event){


if(pause==1){ return; }


player.angle.z+=event.movementY*mouse_sensitive;
player.angle.y-=event.movementX*mouse_sensitive;


if(player.angle.z>170){ player.angle.z=170; }
if(10>player.angle.z){ player.angle.z=10; }


if(player.angle.y>360){ player.angle.y-=360; }
if(player.angle.y<0){ player.angle.y+=360; }


go_lrc=Math.cos(player.angle.y*radian)*player.speed;
go_lrs=Math.sin(player.angle.y*radian)*player.speed;
go_udc=Math.cos((player.angle.y+90)*radian)*player.speed;
go_uds=Math.sin((player.angle.y+90)*radian)*player.speed;


player.direction.x=Math.cos((-player.angle.y-90)*radian)*(Math.sin(player.angle.z*radian));
player.direction.y=Math.cos(player.angle.z*radian);
player.direction.z=Math.sin((-player.angle.y-90)*radian)*(Math.sin(player.angle.z*radian));
camera.lookAt(player.position.x+player.direction.x,player.position.y+player.direction.y,player.position.z+player.direction.z);


update_weapon_sway(event.movementX,event.movementY);


}


let cubeRenderTarget_lightProbe=new THREE.WebGLCubeRenderTarget(
256,{
depthBuffer:false,
format:THREE.RGBAFormat,
colorSpace:THREE.SRGBColorSpace
});


let cubeCamera_lightProbe=new THREE.CubeCamera(0.1,2000,cubeRenderTarget_lightProbe);
let lightProbe=new THREE.LightProbe();


function lightProbe_update(){
cubeCamera_lightProbe.position.copy(camera.position);
cubeCamera_lightProbe.update(renderer,scene);
lightProbe.copy(new THREE.LightProbeGenerator.fromCubeRenderTarget(renderer,cubeRenderTarget_lightProbe));
//lightProbe.copy(new THREE.LightProbeGenerator.fromCubeTexture(environment_main));
lightProbe.intensity=2;
lightProbe.position.copy(camera.position);
scene.add(lightProbe);
let helper=new THREE.LightProbeHelper(lightProbe,0.2);
helper.position.copy(camera.position);
scene.add(helper);
}


let particles_flare_a=[];


particles_flare_a.push({offset:[0,0,0],scale:[0.2,0.2],quaternion:[0,0,0,2],rotation:0,color:[1,0.4,1,5],blend:0,frame:[1,1,0,0],texture:1});
particles_flare_a.push({offset:[0,0,0],scale:[0.2,0.2],quaternion:[0,0,0,2],rotation:0,color:[1,0.4,1,5],blend:0,frame:[1,1,0,0],texture:1});
particles_flare_a.push({offset:[0,0,0],scale:[1,1],quaternion:[0,0,0,2],rotation:0,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:1});


particles_flare_a.push({offset:[-0.8,0.2,-8],scale:[0.2,0.2],quaternion:[0,0,0,2],rotation:0,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:1});
particles_flare_a.push({offset:[-0.8,0.2,-9],scale:[0.2,0.2],quaternion:[0,0,0,2],rotation:0,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:1});
particles_flare_a.push({offset:[-0.8,0.2,-10],scale:[0.2,0.2],quaternion:[0,0,0,2],rotation:0,color:[0,1,1,1],blend:0,frame:[1,1,0,0],texture:1});
particles_flare_a.push({offset:[-0.8,0.2,-11],scale:[0.2,0.2],quaternion:[0,0,0,2],rotation:0,color:[0,1,1,1],blend:0,frame:[1,1,0,0],texture:1});
particles_flare_a.push({offset:[-0.8,0.2,-12],scale:[0.2,0.2],quaternion:[0,0,0,2],rotation:0,color:[1,0.4,0,1],blend:0,frame:[1,1,0,0],texture:1});
particles_flare_a.push({offset:[-0.8,0.2,-13],scale:[0.2,0.2],quaternion:[0,0,0,2],rotation:0,color:[1,0.4,0,1],blend:0,frame:[1,1,0,0],texture:1});


particles_flare_a.push({offset:[-0.7,2.6,-19.6],scale:[1.0,1.0],quaternion:[0,0,0,2],rotation:0,color:[1,0.7,0,1],blend:0,frame:[1,1,0,0],texture:8});


particles_flare_a.push({offset:[-6.0,0.3,-16.9],scale:[0.5,0.5],quaternion:[0,0,0,2],rotation:0,color:[0,1,1,1],blend:0,frame:[1,1,0,0],texture:8});
particles_flare_a.push({offset:[-8.3,0.3,-16.9],scale:[0.5,0.5],quaternion:[0,0,0,2],rotation:0,color:[0,1,1,1],blend:0,frame:[1,1,0,0],texture:8});
particles_flare_a.push({offset:[-10.8,0.3,-16.9],scale:[0.5,0.5],quaternion:[0,0,0,2],rotation:0,color:[0,1,1,1],blend:0,frame:[1,1,0,0],texture:8});


function particles_glow_f(){
let y=particles_glow_a[0].origin[1]+Math.sin(time/1000)/6;
particles_glow_a[0].offset[1]=y;
particles_glow_a[1].offset[1]=y;
let p=particles_glow_a[2].origin;
let x=p[0]+Math.sin(time/1000)*10;
y=p[1]+Math.sin(time/500)*1;
let z=p[2]+Math.cos(time/1000)*10;
particles_glow_a[2].offset=[x,y,z];
particles_glow_a[3].offset=[x,y,z];
}


let particles_glow_a=[];


particles_glow_a.push({origin:[13,1.2,4],offset:[13,1,4],scale:[1,1],quaternion:[0,0,0,2],rotation:-0.002,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:5});
particles_glow_a.push({origin:[13,1.2,4],offset:[13,1,4],scale:[1,1],quaternion:[0,0,0,2],rotation:0.002,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:5});
particles_glow_a.push({origin:[24,1,52],offset:[13,1,4],scale:[5,5],quaternion:[0,0,0,2],rotation:-0.002,color:[1,0,1,1],blend:0,frame:[1,1,0,0],texture:5});
particles_glow_a.push({origin:[24,1,52],offset:[13,1,4],scale:[5,5],quaternion:[0,0,0,2],rotation:0.002,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:5});


let particles_other_a=[];


particles_other_a.push({offset:[9,1.5,1],scale:[1,1],quaternion:[0,0,0,3],rotation:-0.002,color:[0,0,0,1],blend:1,frame:[1,1,0,0],texture:0});
particles_other_a.push({offset:[9.5,1.5,1],scale:[1,1],quaternion:[0,0,0,3],rotation:-0.002,color:[0,0,0,1],blend:1,frame:[1,1,0,0],texture:0});
particles_other_a.push({offset:[9.5,1.5,0.5],scale:[1,1],quaternion:[0,0,0,3],rotation:-0.002,color:[1,0.8,0,1],blend:1,frame:[1,1,0,0],texture:0});
particles_other_a.push({offset:[10.0,1.5,1],scale:[1,1],quaternion:[0,0,0,3],rotation:-0.002,color:[0,0,0,1],blend:1,frame:[1,1,0,0],texture:0});
particles_other_a.push({offset:[9.5,1.5,1.5],scale:[1,1],quaternion:[0,0,0,3],rotation:-0.002,color:[1,0,0,1],blend:1,frame:[1,1,0,0],texture:0});


particles_other_a.push({offset:[9.5,1,-2],scale:[5,1],quaternion:[0,0.7,0,0.7],rotation:0.001,color:[1,1,1,1],blend:1.1,frame:[1,1,0,0],texture:3});


particles_other_a.push({offset:[7,1,10],scale:[1,1],quaternion:[0,0,0,3],rotation:-0.002,color:[1,1,1,1],blend:1,frame:[1,1,0,0],texture:6});


particles_other_a.push({offset:[7,1,6],scale:[4,4],quaternion:[0,0,0,3],rotation:0.001,color:[1,1,1,1],blend:1,frame:[1,1,0,0],texture:2});
particles_other_a.push({offset:[6,1,4],scale:[4,4],quaternion:[0,0,0,3],rotation:0.001,color:[1,1,1,1],blend:1,frame:[1,1,0,0],texture:2});
particles_other_a.push({offset:[7,1,4],scale:[4,4],quaternion:[0,0,0,3],rotation:0.001,color:[1,1,1,1],blend:1,frame:[1,1,0,0],texture:2});



particles_other_a.push({offset:[9.5,1,4.5],scale:[1,1],quaternion:[0,0,0,3],rotation:-0.002,color:[1,1,1,1],blend:1,frame:[1,1,0,0],texture:0});


particles_other_a.push({offset:[7,1,2],scale:[1,1],quaternion:[0,0,0,3],rotation:0.002,color:[1,1,0,1],blend:1,frame:[1,1,0,0],texture:0});
particles_other_a.push({offset:[7,1,2.5],scale:[1,1],quaternion:[0,0,0,3],rotation:0.001,color:[1,0,1,1],blend:1,frame:[1,1,0,0],texture:0});
particles_other_a.push({offset:[7,1,3],scale:[1,1],quaternion:[0,0,0,3],rotation:0.003,color:[0,1,1,1],blend:1,frame:[1,1,0,0],texture:0});


particles_other_a.push({offset:[-300,200,0],scale:[100,100],quaternion:[0,0,0,4],rotation:0,color:[1,1,1,1],blend:1,frame:[1,1,0,0],texture:0});


particles_other_a.push({offset:[-1.05,1.25,-8.5],scale:[0.2,1.0],quaternion:[0,0,0,4],rotation:0,color:[0,0.9,0.81,1],blend:0,frame:[1,1,0,0],texture:4});
particles_other_a.push({offset:[-1.05,1.25,-10.0],scale:[0.2,1.0],quaternion:[0,0,0,4],rotation:0,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:8});
particles_other_a.push({offset:[23,1.25,-2.6],scale:[0.4,10.],quaternion:[0,1,0,7],rotation:0,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:8});
particles_other_a.push({offset:[24,1.25,-6.5],scale:[0.4,10.],quaternion:[1,0,0,7],rotation:0,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:8});
particles_other_a.push({offset:[21,1.25,-4.5],scale:[0.4,4.],quaternion:[1,0,0,6],rotation:0,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:8});
particles_other_a.push({offset:[20,1.25,1.5],scale:[0.4,10.],quaternion:[0,0,1,6],rotation:0,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:8});
particles_other_a.push({offset:[20,1.0,1.5],scale:[0.4,10.],quaternion:[0,0,1,6],rotation:0,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:8});
particles_other_a.push({offset:[21,1.0,-3],scale:[0.4,0.4],quaternion:[0,0,1,3],rotation:0,color:[2.0,1,1,1],blend:0,frame:[1,1,0,0],texture:8});
particles_other_a.push({offset:[26,1.0,1.5],scale:[0.4,10.],quaternion:[0,1,0,6],rotation:0,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:8});
particles_other_a.push({offset:[20,3.0,1.5],scale:[0.4,10.],quaternion:[0,0,1,6],rotation:0,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:8});
particles_other_a.push({offset:[14.22,1.0,55.6],scale:[2.0,4.0],quaternion:[15.0,1.0,55.3,5],rotation:0,color:[1,1,1,1],blend:1,frame:[1,0.5,0,0],texture:9});
particles_other_a.push({offset:[21,1.0,1.5],scale:[0.1,10.],quaternion:[0,0,1,6],rotation:0,color:[1,1,1,0.5],blend:1,frame:[1,1,0,0],texture:2});
particles_other_a.push({offset:[24,1.25,-2.6],scale:[1.0,0.5],quaternion:[0,1,1,5],rotation:0.001,color:[1,1,1,1],blend:1,frame:[1,1,0,0],texture:0});
particles_other_a.push({offset:[-1.05,1.25,-13.0],scale:[0.2,1.0],quaternion:[0,0,0,4],rotation:0,color:[0,0.9,0.81,1],blend:0,frame:[1,1,0,0],texture:4});

particles_other_a.push({offset:[18,1.25,6],scale:[0.4,10.],quaternion:[0,0,1,6],rotation:0,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:13});


particles_other_a.push({offset:[-1.05,1.3,-10.75],scale:[1.2,0.8],quaternion:[0,0.7,0,0.7],rotation:0,color:[1,1,1,1],blend:0.8,frame:[1,1,0,0],texture:6});


particles_other_a.push({offset:[-0.1,1.7,13],scale:[2,1.4],quaternion:[0,0.7,0,0.7],rotation:0,color:[1,1,1,0.4],blend:0,frame:[1,1,0,0],texture:7});
particles_other_a.push({offset:[14.0,1.7,-5.1],scale:[2,1.4],quaternion:[0,0,0,1],rotation:0,color:[1,1,1,0.4],blend:0,frame:[1,1,0,0],texture:7});


particles_other_a.push({offset:[16,1.0,0],scale:[1.0,1.0],quaternion:[0,0,0,2],rotation:0,color:[1,1,1,1],blend:1,frame:[1,1,0,0],texture:10});
particles_other_a.push({offset:[16,1.5,0],scale:[1.0,0.25],quaternion:[0,0,0,2],rotation:0,color:[1,1,1,1],blend:1,frame:[1,1,0,0],texture:11});


particles_other_a.push({offset:[18,1.0,0],scale:[1.0,1.0],quaternion:[0,0,0,2],rotation:0.001,color:[1,1,1,1],blend:0,frame:[1,1,0,0],texture:12});


particles_other_a.push({offset:[35,0.0,72],scale:[2,2],quaternion:[0,0,0,3],rotation:0.001,color:[1,1,1,1],blend:1,frame:[1,1,0,0],texture:14});
particles_other_a.push({offset:[35,0.0,72],scale:[1.8,1.8],quaternion:[0,0,0,3],rotation:-0.001,color:[1,1,1,1],blend:1,frame:[1,1,0,0],texture:14});


let particles=[];


function particles_update(){



particles_other_a[18].offset[0]=24+Math.sin(time/500);



particles_other_a[25].frame[3]=-time/500;


particles_glow_f();


if(wolf_tail_bone){


let item_1=mesh["eye_1"].matrixWorld.elements;
let item_2=particles_flare_a[0].offset;
item_2[0]=item_1[12];
item_2[1]=item_1[13];
item_2[2]=item_1[14];


item_1=mesh["eye_2"].matrixWorld.elements;
item_2=particles_flare_a[1].offset;
item_2[0]=item_1[12];
item_2[1]=item_1[13];
item_2[2]=item_1[14];


for(let n=0;n<1;n++){
wolf_tail[0][0].multiplyMatrices(wolf_tail[0][1],wolf_tail[0][2]);
let item_1=wolf_tail[0][3];
let item_2=particles_flare_a[2].offset;
item_2[0]=item_1[12];
item_2[1]=item_1[13];
item_2[2]=item_1[14];
}


}


particles=[];


let max_particles_flare_a=particles_flare_a.length;
particles.length=max_particles_flare_a;
for(let n=0;n<max_particles_flare_a;n++){
particles[n]=particles_flare_a[n];
}


let max_particles_flare_a_particles_glow_a=max_particles_flare_a+particles_glow_a.length;
particles.length=max_particles_flare_a_particles_glow_a;
let i=0;
for(let n=max_particles_flare_a;n<max_particles_flare_a_particles_glow_a;n++){
particles[n]=particles_glow_a[i];
i++;
}


let max_particles_flare_a_particles_glow_a_particles_other_a=max_particles_flare_a_particles_glow_a+particles_other_a.length;
particles.length=max_particles_flare_a_particles_glow_a_particles_other_a;
i=0;
for(let n=max_particles_flare_a_particles_glow_a;n<max_particles_flare_a_particles_glow_a_particles_other_a;n++){
particles[n]=particles_other_a[i];
i++;
}


let count=particles.length;
let item=camera.position;
let x=item.x;
let y=item.y;
let z=item.z;


let n=count;
while(n--){
let item=particles[n].offset;
particles[n].d=Math.sqrt(Math.pow((x-item[0]),2)+Math.pow((y-item[1]),2)+Math.pow((z-item[2]),2));
}


particles.sort((a,b)=>b.d-a.d);


let offset=new Float32Array(count*3);
let scale=new Float32Array(count*2);
let quaternion=new Float32Array(count*4);
let rotation=new Float32Array(count);
let color=new Float32Array(count*4);
let blend=new Float32Array(count);
let frame=new Float32Array(count*4);
let texture=new Float32Array(count);


n=count;
while(n--){



let item=particles[n];
rotation[n]=item.rotation;
texture[n]=item.texture;
blend[n]=item.blend;



let zero=n*2;
let one=zero+1;
let i_scale=item.scale;
scale[zero]=i_scale[0];
scale[one]=i_scale[1];



zero=n*3;
one=zero+1;
let two=zero+2;
let i_offset=item.offset;
offset[zero]=i_offset[0];
offset[one]=i_offset[1];
offset[two]=i_offset[2];



zero=n*4;
one=zero+1;
two=zero+2;
let three=zero+3;
let i_color=item.color;
color[zero]=i_color[0];
color[one]=i_color[1];
color[two]=i_color[2];
color[three]=i_color[3];
let i_quaternion=item.quaternion;
quaternion[zero]=i_quaternion[0];
quaternion[one]=i_quaternion[1];
quaternion[two]=i_quaternion[2];
quaternion[three]=i_quaternion[3];
let i_frame=item.frame;
frame[zero]=i_frame[0];
frame[one]=i_frame[1];
frame[two]=i_frame[2];
frame[three]=i_frame[3];


}



item=mesh["sprite"].geometry.attributes;
item.offset=new THREE.InstancedBufferAttribute(offset,3).setUsage(THREE.StreamDrawUsage);
item.scale=new THREE.InstancedBufferAttribute(scale,2).setUsage(THREE.StreamDrawUsage);
item.quaternion=new THREE.InstancedBufferAttribute(quaternion,4).setUsage(THREE.StreamDrawUsage);
item.rotation=new THREE.InstancedBufferAttribute(rotation,1).setUsage(THREE.StreamDrawUsage);
item.color=new THREE.InstancedBufferAttribute(color,4).setUsage(THREE.StreamDrawUsage);
item.blend=new THREE.InstancedBufferAttribute(blend,1).setUsage(THREE.StreamDrawUsage);
item.frame=new THREE.InstancedBufferAttribute(frame,4).setUsage(THREE.StreamDrawUsage);
item.texture=new THREE.InstancedBufferAttribute(texture,1).setUsage(THREE.StreamDrawUsage);



mesh["sprite"].geometry._maxInstanceCount=count;


}


function movePoint() {
let t=Date.now()*0.007;
mesh["rotate_sphere"].position.x=Math.sin(t*0.5)*0.5;
mesh["rotate_sphere"].position.y=Math.cos(t*0.5)*0.5+1;
mesh["rotate_sphere"].position.z=Math.cos(t*0.5)*0.5;
mesh["object_i_ray_sphere_2"].position.x=Math.sin(t*0.5)*0.5;
mesh["object_i_ray_sphere_2"].position.y=Math.cos(t*0.5)*0.5+1;
mesh["object_i_ray_sphere_2"].position.z=-3.5+Math.cos(t*0.5)*0.5;
}


mesh["green_cone"]=new THREE.Mesh(
new THREE.ConeGeometry(0.1,0.4,3),
new THREE.MeshLambertMaterial({color:0x009000})
);
mesh["green_cone"].geometry.translate(0,0.2,0);
mesh["green_cone"].geometry.rotateX(Math.PI/2);
mesh["green_cone"].position.set(0,1.5,0);
scene.add(mesh["green_cone"]);


let geometry=new THREE.BufferGeometry();


let vertices=new Float32Array([
-1,4,0,
-1,-4,0,
1,4,0,
]);


geometry.setAttribute('position',new THREE.BufferAttribute(vertices,3));
geometry.computeVertexNormals();
mesh["line"]=new THREE.Mesh(geometry,new THREE.MeshBasicMaterial());
scene.add(mesh["line"]);


mesh["player_ray"]=new THREE.Mesh(new THREE.SphereGeometry(0.10,3,3),new THREE.MeshNormalMaterial())
mesh["player_ray"].position.set(0,1,0);
scene.add(mesh["player_ray"]);


mesh["boxer"]=new THREE.Mesh(new THREE.PlaneGeometry(2,8,1),new THREE.MeshLambertMaterial({color:0xffc000,wireframe:true}));
//mesh["boxer"].position.set(0,0,0);
scene.add(mesh["boxer"]);


function walk(ray_a){
ray_i.hit=0;
ray_i.distance=Infinity;


let max_ray_a=ray_a.length;
for(let j=0;j<max_ray_a;j++){


let ray_p=ray_a[j].position.array;
let ray_c=ray_a[j].position.count/3*9;
let ray_n=ray_a[j].normal.array;


for(let i=0;i<ray_c;i+=9){
let a={x:ray_p[i],y:ray_p[i+1],z:ray_p[i+2]};
let c={x:ray_p[i+6],y:ray_p[i+7],z:ray_p[i+8]};
let ab={x:ray_p[i+3]-a.x,y:ray_p[i+4]-a.y,z:ray_p[i+5]-a.z};
let ac={x:c.x-a.x,y:c.y-a.y,z:c.z-a.z};
let normal={x:ab.y*ac.z-ab.z*ac.y,y:ab.z*ac.x-ab.x*ac.z,z:ab.x*ac.y-ab.y*ac.x};


let way={x:ray_n[i],y:ray_n[i+1],z:ray_n[i+2]};
ray_e.x=player.position.x+(-way.x*0.2);
//ray_e.y=player.position.y;
ray_e.z=player.position.z+(-way.z*0.2);


let qp={x:ray_b.x-ray_e.x,y:ray_b.y-ray_e.y,z:ray_b.z-ray_e.z};
let d=qp.x*normal.x+qp.y*normal.y+qp.z*normal.z;
if(d<=0){ continue; } // return false; НЕТ ВООБЩЕ ПЕРЕСЕЧЕНИЙ
let ap={x:ray_b.x-a.x,y:ray_b.y-a.y,z:ray_b.z-a.z};
let t=ap.x*normal.x+ap.y*normal.y+ap.z*normal.z;
if(t<0){ continue; }
if(t>d){ continue; }
let e={x:qp.y*ap.z-qp.z*ap.y,y:qp.z*ap.x-qp.x*ap.z,z:qp.x*ap.y-qp.y*ap.x};
let v=ac.x*e.x+ac.y*e.y+ac.z*e.z;
if(v<0 || v>d){ continue; }
let w=-(ab.x*e.x+ab.y*e.y+ab.z*e.z);
if(w<0 || v+w>d){ continue; }
let ood=1/d;
v*=ood;
w*=ood;
let u=1-v-w;
let au={x:a.x*u,y:a.y*u,z:a.z*u};
let bv={x:ray_p[i+3]*v,y:ray_p[i+4]*v,z:ray_p[i+5]*v};
let cw={x:c.x*w,y:c.y*w,z:c.z*w};
let cp={x:au.x+bv.x+cw.x,y:au.y+bv.y+cw.y,z:au.z+bv.z+cw.z};
let ray_i_d=Math.sqrt(Math.pow((ray_b.x-cp.x),2)+Math.pow((ray_b.y-cp.y),2)+Math.pow((ray_b.z-cp.z),2));
if(ray_i_d<ray_i.distance){
mesh["player_ray"].position.set(cp.x,cp.y,cp.z);
ray_i.distance=ray_i_d;
ray_i.point=cp;
ray_i.hit=1;
}
}
}
}


let cmax=0;


let total_frame_time=0;
let total_frame_time_max=0;
let total_frame_time_min=Infinity;
let total_frame_time_elapsed=0;


let loop_render_time=0;
let loop_render_time_max=0;
let loop_render_time_min=Infinity;
let loop_render_time_elapsed=0;


let shadow_ground_2_updated=1;


shadow_ground_px=-999; 
shadow_ground_pz=0; 


let mouse={x:0,y:0};
let smooth = 20; // Smoothness of rotation interpolation
let multiplier = 0.1; // Sensitivity multiplier for mouse input


mesh["weapon"]=new THREE.Mesh(new THREE.BoxGeometry(0.01,0.02,0.2),new THREE.MeshBasicMaterial({
color:0xff0000
}));
mesh["weapon"].geometry.translate(0,0.0,-0.1);
mesh["weapon"].position.set(0.1,-0.1,-0.2);
scene.add(mesh["weapon"]);
mesh["weapon"].parent=camera;


function onMouseMove(event){
mouse.x=(event.clientX/screen_width)*2-1;
mouse.y=-(event.clientY/screen_height)*2+1;
}


//document.addEventListener('mousemove', onMouseMove, false);


let hand_position=mesh["weapon"].position;
let hand_rotation=mesh["weapon"].rotation;


let hand_position_x_default=0.1;
let hand_position_x_range=0.05; 
let hand_position_x_min=hand_position_x_default-hand_position_x_range; 
let hand_position_x_max=hand_position_x_default+hand_position_x_range;
let hand_rotation_y_min=-0.2; 
let hand_rotation_y_max=0.2; 


let hand_position_y_default=-0.1; 
let hand_position_y_range=0.03; 
let hand_position_y_min=hand_position_y_default-hand_position_y_range; 
let hand_position_y_max=hand_position_y_default+hand_position_y_range; 
let hand_rotation_x_min=-0.1;
let hand_rotation_x_max=0.1; 


let hand_rotation_z_min=-0.05; 
let hand_rotation_z_max=0.05; 


let hand_go_intensity=0;
let hand_go_time=0;


let hand_sway_intensity=0;


function update_weapon_sway(x,y){


hand_sway_intensity+=0.1*(1.0-hand_go_intensity);


hand_position.x=Math.min(Math.max(hand_position.x,hand_position_x_min),hand_position_x_max);
hand_position.x-=x*0.0001*(1-Math.abs(hand_position.x-hand_position_x_default)/hand_position_x_range);
hand_position.x=Math.min(Math.max(hand_position.x,hand_position_x_min),hand_position_x_max);


hand_position.y=Math.min(Math.max(hand_position.y,hand_position_y_min),hand_position_y_max);
hand_position.y-=y*0.00002*(1-Math.abs(hand_position.y-hand_position_y_default)/hand_position_y_range);
hand_position.y=Math.min(Math.max(hand_position.y,hand_position_y_min),hand_position_y_max);


hand_rotation.x=Math.min(Math.max(hand_rotation.x,hand_rotation_x_min),hand_rotation_x_max);
hand_rotation.x+=y*0.001*(1-Math.abs(hand_rotation.x));
hand_rotation.x=Math.min(Math.max(hand_rotation.x,hand_rotation_x_min),hand_rotation_x_max);


hand_rotation.y=Math.min(Math.max(hand_rotation.y,hand_rotation_y_min),hand_rotation_y_max);
hand_rotation.y+=x*0.0002*(1-Math.abs(hand_rotation.y));
hand_rotation.y=Math.min(Math.max(hand_rotation.y,hand_rotation_y_min),hand_rotation_y_max);


hand_rotation.z=Math.min(Math.max(hand_rotation.z,hand_rotation_z_min),hand_rotation_z_max);
hand_rotation.z-=x*0.001*(1-Math.abs(hand_rotation.z));
hand_rotation.z=Math.min(Math.max(hand_rotation.z,hand_rotation_z_min),hand_rotation_z_max);


}


function updateWeaponSway(){


let hand_bob_move_x=0.02;
let hand_bob_move_y=0.01;
let hand_bob_frequency_x=0.1;
let hand_bob_frequency_y=0.2;
//hand_position.x+=Math.sin(hand_go_time*hand_bob_frequency_x)*hand_bob_move_x*hand_go_intensity;
// ОПУСКАЕМ ЧУТЬ НИЖЕ
//hand_position.y+=(0.01+Math.cos(hand_go_time*hand_bob_frequency_y)*hand_bob_move_y)*hand_go_intensity;
hand_position.x+=(hand_position_x_default-hand_position.x+Math.sin(hand_go_time*hand_bob_frequency_x)*hand_bob_move_x*hand_go_intensity)*(1.0-hand_sway_intensity);
// ОПУСКАЕМ ЧУТЬ НИЖЕ
hand_position.y+=(hand_position_y_default-hand_position.y+(-0.01-Math.cos(hand_go_time*hand_bob_frequency_y)*hand_bob_move_y)*hand_go_intensity)*(1.0-hand_sway_intensity);



let hand_default_move_x=0.001;
let hand_default_move_y=0.003;
let hand_default_frequency_x=0.001;
let hand_default_frequency_y=0.002;
//hand_position.x+=Math.sin(time*hand_default_frequency_x)*hand_default_move_x;
//hand_position.y+=-Math.sin(time*hand_default_frequency_y)*hand_default_move_y;
hand_position.x+=(hand_position_x_default-hand_position.x+Math.sin(time*hand_default_frequency_x)*hand_default_move_x)*(1.0-hand_go_intensity)*(1.0-hand_sway_intensity);
hand_position.y+=(hand_position_y_default-hand_position.y+Math.sin(time*hand_default_frequency_y)*hand_default_move_y)*(1.0-hand_go_intensity)*(1.0-hand_sway_intensity);


//let delta_2=Math.min(Math.max(delta,0),0.016);
let delta_2=0.016;
hand_position.x+=(hand_position_x_default-hand_position.x)*10*delta_2*(1.0-hand_go_intensity);
hand_position.y+=(hand_position_y_default-hand_position.y)*10*delta_2*(1.0-hand_go_intensity);
hand_rotation.x+=-hand_rotation.x*10*delta_2;
hand_rotation.y+=-hand_rotation.y*10*delta_2;
hand_rotation.z+=-hand_rotation.z*10*delta_2;


hand_position.x=Math.min(Math.max(hand_position.x,hand_position_x_min),hand_position_x_max);
hand_position.y=Math.min(Math.max(hand_position.y,hand_position_y_min),hand_position_y_max);
hand_rotation.x=Math.min(Math.max(hand_rotation.x,hand_rotation_x_min),hand_rotation_x_max);
hand_rotation.y=Math.min(Math.max(hand_rotation.y,hand_rotation_y_min),hand_rotation_y_max);
hand_rotation.z=Math.min(Math.max(hand_rotation.z,hand_rotation_z_min),hand_rotation_z_max);


}
function set_window(){


window.sun_direction=sun_direction;
window.camera=camera;
window.camera_hud=camera_hud;
window.tex=tex;
window.mat=mat;
window.vs=vs;
window.fs=fs;
window.mesh=mesh;
window.scene=scene;
window.scene_hud=scene_hud;
window.renderer=renderer;
window.underwater_pass=underwater_pass;
window.underwater_ripples_pass=underwater_ripples_pass;
window.correction_pass=correction_pass;
window.unrealbloom_pass=unrealbloom_pass;
window.THREE=THREE;
window.sun=sun;
window.ambient=ambient;
window.scene=scene;
window.scene_2=scene_2;
window.player=player;
window.intersection_ray_triangle=intersection_ray_triangle;
window.RGBELoader=RGBELoader;
window.voice_send=voice_send;
window.composer_rtt=composer_rtt;
window.composer=composer;
window.waterline_rtt=waterline_rtt;
window.water=water;


}


let scene_envMap_backed=new THREE.WebGLCubeRenderTarget(
1024,{
depthBuffer:false,
format:THREE.RGBAFormat,
colorSpace:THREE.SRGBColorSpace
});


let scene_envMap_camera=new THREE.CubeCamera(1,10,scene_envMap_backed);
let scene_envMap_scene=new THREE.Scene();


function SRGB_set(){


mat["terrain"].roughness=0.8;
mesh["terrain"].material=mat["terrain"];


let max_mat_sprite=mat["sprite"].uniforms.map.value.length;
for(let n=0;n<max_mat_sprite;n++){
mat["sprite"].uniforms.map.value[n].colorSpace=THREE.SRGBColorSpace;
mat["sprite"].uniforms.map.value[n].needsUpdate=true;
}


mesh["rock"].material.map.colorSpace=THREE.SRGBColorSpace;
mesh["rock"].material.map.needsUpdate=true;
mesh["wolf"].children[1].material.map.colorSpace=THREE.SRGBColorSpace;
mesh["wolf"].children[1].material.map.needsUpdate=true;
mesh["home"].castShadow=true;
mesh["home"].receiveShadow=true;
mesh["home001"].castShadow=true;
mesh["home001"].receiveShadow=true;


}


function init_core(){


let cube_texture_loader=new THREE.CubeTextureLoader(loadingManager);
cube_texture_loader.setPath("./images/sky/");
//let environment_texture=cube_texture_loader.load(["lf.jpg","rt.jpg","up.jpg","dn.jpg","ft.jpg","bk.jpg"]);
//let environment_texture=cube_texture_loader.load(["lf.png","rt.png","up.png","dn.png","ft.png","bk.png"]);
//let environment_texture=cube_texture_loader.load(["px.png","nx.png","py.png","ny.png","pz.png","nz.png"]);
//let environment_texture=cube_texture_loader.load(["px.jpg","nx.jpg","py.jpg","ny.jpg","pz.jpg","nz.jpg"]);
//let environment_texture=cube_texture_loader.load(["lf.jpg","rt.jpg","up.jpg","dn.jpg","ft.jpg","bk.jpg"],lightProbe_update);
//let environment_texture=cube_texture_loader.load(["px.jpg","nx.jpg","py.jpg","ny.jpg","pz.jpg","nz.jpg"],lightProbe_update);


THREE.ShaderLib.backgroundCube.fragmentShader=THREE.ShaderLib.backgroundCube.fragmentShader.replace(
"#include <tonemapping_fragment>",
`float toneMappingExposure=1.0;
const float StartCompression = 0.8 - 0.04;
const float Desaturation = 0.15;
gl_FragColor.rgb *= toneMappingExposure;
float x = min( gl_FragColor.r, min( gl_FragColor.g, gl_FragColor.b ) );
float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
gl_FragColor.rgb -= offset;
float peak = max( gl_FragColor.r, max( gl_FragColor.g, gl_FragColor.b ) );
if ( peak > StartCompression ){
float d = 1. - StartCompression;
float newPeak = 1. - d * d / ( peak + d - StartCompression );
gl_FragColor.rgb *= newPeak / peak;
float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
gl_FragColor.rgb=mix( gl_FragColor.rgb, vec3( newPeak ), g );
}`
);


scene.background=environment_main;
//scene.background=environment_texture;


scene_2.background=environment_main;


scene_envMap_scene.backgroundBlurriness=0.0;
scene_envMap_scene.background=environment_main;
scene_envMap_camera.update(renderer,scene_envMap_scene);


player.position.x=18.1;
player.position.y=1.8;
player.position.z=53.46;
player.angle.z=170;
player.angle.y=302;
updatePosition({movementX:2,movementY:1});
player.direction.x=Math.cos((-player.angle.y-90)*radian)*(Math.sin(player.angle.z*radian));
player.direction.y=Math.cos(player.angle.z*radian);
player.direction.z=Math.sin((-player.angle.y-90)*radian)*(Math.sin(player.angle.z*radian));
camera.lookAt(player.position.x+player.direction.x,player.position.y+player.direction.y,player.position.z+player.direction.z);


shadow_ground_init();


music_effects_gen();
sounds_effects_gen();
sounds_volume_gen(10);
set_lights();


lightMap.set_uv(mesh);



for(let i in mesh){
if(!mesh[i].material || !mesh[i].material.length){ continue; }
materials_duplicates_remover(mesh[i]);
}


lightMap.set_tex(mesh,tex); 


set_soldiers();
set_gun();


prosto_zapchasti();


instance_long();
instance_set();


set_flare();
set_sprite(THREE,mat,tex,vs,fs,mesh,scene);
set_pseudo();


set_crosshair(THREE,mat,tex,vs,fs,mesh,scene_hud);


water_set();


set_other();
SRGB_set();
press_q();


set_window();


}


function set_soldiers(){


mesh["soldier_attack_1"]=SkeletonUtils.clone(mesh["soldier"]);
mesh["soldier_attack_1"].animations=mesh["soldier"].animations;
mixer["soldier_attack_1"]=new THREE.AnimationMixer(mesh["soldier_attack_1"]);
action["soldier_attack_1"]=THREE.AnimationUtils.subclip(mesh["soldier_attack_1"].animations[0],'attack',0,100);
action["soldier_attack_1"]=mixer["soldier_attack_1"].clipAction(action["soldier_attack_1"]);
action["soldier_attack_1"].time=0;
action["soldier_attack_1"].play();
mixers.push(mixer["soldier_attack_1"]);
mesh["soldier_attack_1"].animations=[];
mesh["soldier_attack_1"].scale.set(0.025,0.025,0.025);
mesh["soldier_attack_1"].position.set(-2,0,-8);
mesh["soldier_attack_1"].rotation.y=0;
mesh["soldier_attack_1"].children[1].frustumCulled=false;
mesh["soldier_attack_1"].children[1].onAfterRender=function(){
this.frustumCulled=true;
this.onAfterRender=function(){};
}
scene.add(mesh["soldier_attack_1"]);


mesh["soldier_attack_2"]=SkeletonUtils.clone(mesh["soldier"]);
mesh["soldier_attack_2"].animations=mesh["soldier"].animations;
mixer["soldier_attack_2"]=new THREE.AnimationMixer(mesh["soldier_attack_2"]);
action["soldier_attack_2"]=THREE.AnimationUtils.subclip(mesh["soldier_attack_2"].animations[0],'attack',0,100);
action["soldier_attack_2"]=mixer["soldier_attack_2"].clipAction(action["soldier_attack_2"]);
action["soldier_attack_2"].time=0;
action["soldier_attack_2"].play();
mixers.push(mixer["soldier_attack_2"]);
mesh["soldier_attack_2"].animations=[];
mesh["soldier_attack_2"].scale.set(0.025,0.025,0.025);
mesh["soldier_attack_2"].position.set(2,0,-8);
mesh["soldier_attack_2"].rotation.y=0;
mesh["soldier_attack_2"].children[1].frustumCulled=false;
mesh["soldier_attack_2"].children[1].onAfterRender=function(){
this.frustumCulled=true;
this.onAfterRender=function(){};
}
scene.add(mesh["soldier_attack_2"]);


}


function set_gun(){


let hand;
mesh["soldier_attack_1"].traverse(function(child){
if(child.name=="swatRightHand"){ hand=child; }
});


mesh["pistol"]=mesh["gun"].clone();
mesh["pistol"].rotation.y=1.57;
mesh["pistol"].scale.set(20,20,20);
mesh["pistol"].position.set(0,-0.04,-0.05);
scene.add(mesh["pistol"]);
mesh["pistol"].add(gun_light);
mesh["pistol"].parent=mesh["weapon"];


mesh["gun"].parent=hand;
mesh["gun"].position.set(-12,-2,3);
mesh["gun"].scale.set(2000,2000,2000);
mesh["gun"].rotation.set(1.57,3.3,0);


scene_2.children.push(mesh["pistol"]);
scene_2.children.push(mesh["weapon"]);


}


dummy["shot_spread"]=new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,1),new THREE.MeshStandardMaterial({color:0xff0000}));
dummy["shot_spread"].matrixAutoUpdate=false;
dummy["shot_spread"].updateMatrixWorld=function(){};
dummy["shot_spread"].geometry.translate(0,0,0.5);
scene.add(dummy["shot_spread"]);


mesh["test"]=new THREE.Mesh(new THREE.SphereGeometry(0.01,32,32),new THREE.MeshPhongMaterial({color:0xffc000}));
scene.add(mesh["test"]);


let spread=new THREE.Vector3();
let m_radius=1.0;
let theta=2*Math.PI*Math.random();
let r=Math.sqrt(Math.random());
r=0.45;
spread.x=r*m_radius*Math.cos(theta);
spread.y=r*m_radius*Math.sin(theta);
spread.z=-1;
spread.normalize();
dummy["shot_spread"].lookAt(spread);
dummy["shot_spread"].updateMatrix();
mesh["test"].position.set(spread.x,spread.y,spread.z);


function rzh(){
theta+=0.01;
spread.x=r*m_radius*Math.cos(theta);
spread.y=r*m_radius*Math.sin(theta);
spread.z=-1;
spread.normalize();
dummy["shot_spread"].lookAt(spread);
dummy["shot_spread"].updateMatrix();
let ddd=new THREE.Quaternion();
camera.getWorldQuaternion(ddd);
spread.applyQuaternion(ddd);
mesh["test"].position.set(spread.x+camera.position.x,spread.y+camera.position.y,spread.z+camera.position.z);
}


let pclose_g_1;
let pclose_g_2;
let pclose_g_3;


function prosto_zapchasti(){


mesh["Box002"].castShadow=true;


mesh["big_box"]=new THREE.Mesh(new THREE.BoxGeometry(1,5,1),new THREE.MeshStandardMaterial({color:0xffffff}));
mesh["big_box"].castShadow=true;
mesh["big_box"].position.set(47.8,1.8,61.8);
scene.add(mesh["big_box"]);


mesh["big_box_2"]=new THREE.Mesh(new THREE.BoxGeometry(3,5,3),new THREE.MeshStandardMaterial({map:tex["wall_118"]}));
mesh["big_box_2"].castShadow=true;
mesh["big_box_2"].position.set(32,-2.2,85);
scene.children.push(mesh["big_box_2"]);
scene_2.children.push(mesh["big_box_2"]);


mesh["big_box_3"]=new THREE.Mesh(new THREE.BoxGeometry(2,5,2),new THREE.MeshStandardMaterial({color:0xffff00}));
mesh["big_box_3"].castShadow=true;
mesh["big_box_3"].position.set(32,1.8,28);
scene.add(mesh["big_box_3"]);


mesh["big_box_4"]=new THREE.Mesh(new THREE.BoxGeometry(0.1,10,0.1),new THREE.MeshStandardMaterial({color:0xffff00}));
mesh["big_box_4"].castShadow=true;
mesh["big_box_4"].position.set(35.5,0.5,66.5);
scene.children.push(mesh["big_box_4"]);
scene_2.children.push(mesh["big_box_4"]);


mesh["big_box_5"]=new THREE.Mesh(new THREE.BoxGeometry(0.01,10,0.01),new THREE.MeshStandardMaterial({color:0xffff00}));
mesh["big_box_5"].castShadow=true;
mesh["big_box_5"].position.set(32,0.5,72);
scene.children.push(mesh["big_box_5"]);
scene_2.children.push(mesh["big_box_5"]);


mesh["big_box_6"]=new THREE.Mesh(new THREE.BoxGeometry(2,0.4,2),new THREE.MeshStandardMaterial({map:tex["wall_277"],normalMap:tex["wall_278"],normalScale:{x:1.5,y:1.5},roughnessMap:tex["wall_279"],roughness:10}));
mesh["big_box_6"].castShadow=true;
mesh["big_box_6"].position.set(23,-1,94);
scene.children.push(mesh["big_box_6"]);
scene_2.children.push(mesh["big_box_6"]);


mesh["big_box_7"]=new THREE.Mesh(new THREE.BoxGeometry(10,50,10),new THREE.MeshStandardMaterial({color:0xffffff}));
mesh["big_box_7"].castShadow=true;
mesh["big_box_7"].position.set(130,25,50);
scene.add(mesh["big_box_7"]);


mesh["big_box_8"]=new THREE.Mesh(new THREE.BoxGeometry(4,30,1),new THREE.MeshStandardMaterial({color:0xffffff}));
mesh["big_box_8"].castShadow=true;
mesh["big_box_8"].position.set(130,40,55.5);
scene.add(mesh["big_box_8"]);


mesh["big_box_9"]=new THREE.Mesh(new THREE.BoxGeometry(4,30,0.5),new THREE.MeshStandardMaterial({color:0xffffff}));
mesh["big_box_9"].castShadow=true;
mesh["big_box_9"].position.set(0,0,0);
mesh["big_box_9"].rotation.z=1.57;
mesh["big_box_8"].add(mesh["big_box_9"]);


mesh["big_box_10"]=new THREE.Mesh(new THREE.BoxGeometry(1,5,1),new THREE.MeshStandardMaterial({color:0xff0000}));
mesh["big_box_10"].castShadow=true;
mesh["big_box_10"].receiveShadow=true;
mesh["big_box_10"].position.set(34,-2.2,90);
scene.children.push(mesh["big_box_10"]);
scene_2.children.push(mesh["big_box_10"]);


mesh["big_box_11"]=new THREE.Mesh(new THREE.BoxGeometry(1,5,1),new THREE.MeshStandardMaterial({color:0x00ff00}));
mesh["big_box_11"].castShadow=true;
mesh["big_box_11"].receiveShadow=true;
mesh["big_box_11"].position.set(34,-2.2,92);
scene.children.push(mesh["big_box_11"]);
scene_2.children.push(mesh["big_box_11"]);


mesh["big_box_12"]=new THREE.Mesh(new THREE.BoxGeometry(1,5,1),new THREE.MeshStandardMaterial({color:0x0000ff}));
mesh["big_box_12"].castShadow=true;
mesh["big_box_12"].receiveShadow=true;
mesh["big_box_12"].position.set(34,-2.2,94);
scene.children.push(mesh["big_box_12"]);
scene_2.children.push(mesh["big_box_12"]);


mesh["big_box_13"]=new THREE.Mesh(new THREE.BoxGeometry(2,1,0.2),new THREE.MeshStandardMaterial({map:tex["wall_118"]}));
mesh["big_box_13"].castShadow=true;
mesh["big_box_13"].position.set(32,-0.5,86.6);
scene.children.push(mesh["big_box_13"]);
scene_2.children.push(mesh["big_box_13"]);


mesh["mbox"]=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshStandardMaterial({map:tex["wall_118"]}));
mesh["mbox"].castShadow=true;
mesh["mbox"].position.set(30,-0.5,70);
scene.children.push(mesh["mbox"]);
scene_2.children.push(mesh["mbox"]);


scene_2.children.push(mesh["terrain"]);


let angx=90;
let angy=10;
let xr=angx*radian;
let yr=(-angy-90)*radian;
let x=Math.cos(yr)*Math.sin(xr);
let y=Math.cos(xr);
let z=Math.sin(yr)*Math.sin(xr);
//dummy["shot_spread"].lookAt(x,y,z);


let alpha=Math.atan(z/x);
let beta=Math.atan(y/z);


let yaw=Math.atan(y/x);
let pitch=Math.atan(z/Math.sqrt(x^2+y^2));

let degrees=yaw*180/Math.PI;

let ax=Math.atan(z/y);
let ay=Math.atan(x/z);


/*

dummy["shot_spread"].lookAt(0.5,0,0.5);
dummy["shot_spread"].updateMatrix();
dummy["shot_spread"].matrix.multiplyMatrices(camera.matrixWorld,dummy["shot_spread"].matrix);
dummy["shot_spread"].updateMatrixWorld();


let xcv=new THREE.Vector3(0,0,1);
xcv.applyQuaternion(camera.quaternion);
xcv.x+=camera.position.x;
xcv.y+=camera.position.y;
xcv.z+=camera.position.z;
dummy["shot_spread"].position.set(camera.position.x,camera.position.y,camera.position.z);
dummy["shot_spread"].updateMatrix();
dummy["shot_spread"].lookAt(xcv);
dummy["shot_spread"].updateMatrix();


camera.getWorldDirection(xcv);
xcv.x+=camera.position.x;
xcv.y+=camera.position.y;
xcv.z+=camera.position.z;
dummy["shot_spread"].position.set(camera.position.x,camera.position.y,camera.position.z);
dummy["shot_spread"].updateMatrix();
dummy["shot_spread"].lookAt(xcv);
dummy["shot_spread"].updateMatrix();


let ddd=new THREE.Quaternion();
camera.getWorldQuaternion(ddd);
dummy["shot_spread"].quaternion._x=0;
dummy["shot_spread"].quaternion._y=0;
dummy["shot_spread"].quaternion._z=0;
dummy["shot_spread"].quaternion._w=1;
dummy["shot_spread"].applyQuaternion(ddd);
dummy["shot_spread"].position.x=camera.position.x;
dummy["shot_spread"].position.y=camera.position.y;
dummy["shot_spread"].position.z=camera.position.z;
dummy["shot_spread"].updateMatrix();


let aa=new THREE.Vector3();
aa.x=r*m_radius*Math.cos(theta);
aa.y=r*m_radius*Math.sin(theta);
aa.z=-1;
mesh["d1"].lookAt(aa);
mesh["s1"].position.set(aa.x,aa.y,aa.z);
aa.normalize();
mesh["d2"].lookAt(aa);
mesh["s2"].position.set(aa.x,aa.y,aa.z);
let bb=new THREE.Vector2(aa.x,aa.y);
bb.length();


*/





//pclose_g_1=new THREE.Geometry().fromBufferGeometry(mesh["Box002"].geometry);
//pclose_g_2=new THREE.Geometry().fromBufferGeometry(mesh["home001"].geometry);
//pclose_g_3=new THREE.Geometry().fromBufferGeometry(mesh["home"].geometry);


pclose_g_1=mesh["Box002"].geometry;
pclose_g_2=mesh["home001"].geometry;
pclose_g_3=mesh["home"].geometry;


//ajax_timeout=setTimeout("ajax_send();",1000);


mesh["wall_001"].material=new THREE.MeshStandardMaterial({
map:tex["wall_237"],
envMap:tex["env_sunny"],
normalMap:tex["wall_238_n"],
normalScale:{x:1,y:-1},
roughness:0.4,
metalness:0.5
});


mesh["wall_002"].material=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["wall_237"]},
normalRepeat:{value:[1,1]},
normalScale:{value:[1,-1]},
normalMap:{value:tex["wall_238_n"]},
specularMap:{value:tex["specular_test"]},
fogColor:{value:fogColor},
},
vertexShader:vs["wall"],
fragmentShader:fs["wall"],
extensions:{derivatives:true}
});


mesh["wall_003"].material=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["wall_237"]},
mapRepeat:{value:[1,1]},
aoMap:{value:tex["wall_003CompleteMap"]},
normalMap:{value:tex["wall_238_n"]},
normalRepeat:{value:[1,1]},
normalScale:{value:[1,-1]},
specularMap:{value:tex["specular_test"]},
specularRepeat:{value:[1,1]},
shininess:{value:60},
glossiness:{value:1},
fogColor:{value:fogColor},
envMap:{value:scene.background}
},
vertexShader:vs["stone"],
fragmentShader:fs["stone"],
extensions:{derivatives:true}
});


/*
mat["terrain"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["terrain_grass"]},
dirt:{value:tex["terrain_dirt"]},
noise:{value:tex["terrain_noise"]},
aoMap:{value:tex["terrainCompleteMap"]},
shadowGroundMap:{value:tex["shadow_ground_1"]},
shadowGroundOffset:{value:[0,0]},
fogColor:{value:fogColor},
},
vertexShader:vs["terrain_triplanar"],
fragmentShader:fs["terrain_triplanar"],
});
*/


/*
mat["terrain"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["017_color"]},
mapRepeat:{value:[200,200]},
aoMap:{value:tex["terrainCompleteMap"]},
noise:{value:tex["terrain_noise"]},
normalMap:{value:tex["017_normal"]},
normalRepeat:{value:[200,200]},
normalScale:{value:[1,1]},
specularMap:{value:tex["ground_63"]},
specularRepeat:{value:[1,1]},
shininess:{value:60},
glossiness:{value:0.99},
fogColor:{value:fogColor},
},
vertexShader:vs["stone"],
fragmentShader:fs["stone"],
extensions:{derivatives:true}
});
*/


/*
mat["terrain"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["terrain_grass"]},
dirt:{value:tex["terrain_dirt"]},
noise:{value:tex["terrain_noise_2"]},
aoMap:{value:tex["terrainCompleteMap"]},
shadowGroundMap:{value:tex["shadow_ground_1"]},
shadowGroundOffset:{value:[0,0]},
fogColor:{value:fogColor},
},
vertexShader:vs["terrain_single"],
fragmentShader:fs["terrain_single"],
});
*/


/*
mat["terrain"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["ground_1_diffuse"]},
dirt:{value:tex["terrain_dirt"]},
noise:{value:tex["terrain_noise"]},
aoMap:{value:tex["terrainCompleteMap"]},
shadowGroundMap:{value:tex["shadow_ground_1"]},
shadowGroundOffset:{value:[0,0]},
fogColor:{value:fogColor},
},
vertexShader:vs["terrain_triplanar"],
fragmentShader:fs["terrain_triplanar"],
});
*/


mat["terrain"]=new THREE.MeshStandardMaterial({
map:tex["ground_1_diffuse"],
aoMapIntensity:0,
//roughnessMap:tex["ground_1_roughness"],
roughness:0.8,
normalMap:tex["ground_1_normal"],
normalScale:{x:1,y:1},
});


mesh["terrain"].material=mat["terrain"];


mat["terrain"].alphaMap=tex["terrain_noise"];
mat["terrain"].aoMap=tex["dirt"];


mat["terrain"].onBeforeCompile=(shader)=>{
//console.log(shader.vertexShader);
//console.log(shader.fragmentShader);


shader.fragmentShader=shader.fragmentShader.replace("#include <normal_fragment_begin>",
`
float faceDirection=gl_FrontFacing?1.0:-1.0;


vec3 normal=normalize(vNormal);


#ifdef DOUBLE_SIDED
normal*=faceDirection;
#endif


mat3 tbn=getTangentFrame(-vViewPosition,normal,vNormalMapUv);


#if defined( DOUBLE_SIDED )
tbn[0]*=faceDirection;
tbn[1]*=faceDirection;
#endif


vec3 nonPerturbedNormal=normal;
`);


shader.fragmentShader=shader.fragmentShader.replace("#include <normal_fragment_maps>",
`
vec3 mapN=texture2D(normalMap,vNormalMapUv).xyz*2.0-1.0;
mapN.xy*=normalScale;
normal=normalize(tbn*mapN);




vec3 eye_pos=-vViewPosition;
vec2 vUv=vNormalMapUv;
vec3 N=vNormal;


vec3 q0=dFdx(eye_pos.xyz);
vec3 q1=dFdy(eye_pos.xyz);
vec2 st0=dFdx(vUv);
vec2 st1=dFdy(vUv);
vec3 q1perp=cross(q1,N);
vec3 q0perp=cross(N,q0);
vec3 T=q1perp*st0.x+q0perp*st1.x;
vec3 B=q1perp*st0.y+q0perp*st1.y;
float det=max(dot(T,T),dot(B,B));
float scale=(det==0.0)?0.0:inversesqrt(det);
normal=normalize(T*(mapN.x*scale)+B*(mapN.y*scale)+N*mapN.z);



`);


//shader.fragmentShader=shader.fragmentShader.replace("#include <alphamap_fragment>",
//`diffuseColor.rgb*=texture2D(alphaMap,vUv/30.0).rgb*1.0;`);


shader.fragmentShader=shader.fragmentShader.replace("#include <alphamap_fragment>",
`
vec3 tex=texture2D(map,vMapUv).rgb;
float gamma=texture2D(normalMap,vMapUv/50.0).g;
// ДОПОЛНИТЕЛЬНАЯ КАРТА НОРМАЛИ БОЛЬШАЯ
//diffuseColor.rgb=pow(tex,vec3(0.6+gamma/1.0));
diffuseColor.rgb=mix(diffuseColor.rgb,texture2D(aoMap,vMapUv).rgb,texture2D(alphaMap,vMapUv/20.0).r);
diffuseColor.rgb=mix(diffuseColor.rgb,texture2D(aoMap,vMapUv).rgb,texture2D(alphaMap,vMapUv/100.0).r);
//vec3 tex=texture2D(map,vMapUv).rgb*texture2D(map,vMapUv/35.0).rgb*8.0;
//diffuseColor.rgb=tex;
//diffuseColor.rgb=mix(tex,texture2D(aoMap,vMapUv).rgb,texture2D(alphaMap,vMapUv/70.0).r);
//diffuseColor.rgb=mix(texture2D(map,vMapUv).rgb,texture2D(aoMap,vUv).rgb,texture2D(alphaMap,vMapUv/70.0).r);
`);

shader.fragmentShader=shader.fragmentShader.replace("#include <lightmap_fragment>",
``);

shader.fragmentShader=shader.fragmentShader.replace("#include <aomap_fragment>",
`float ambientOcclusion;`);


shader.vertexShader=shader.vertexShader.replace("#include <common>",
`#include <common>
varying vec3 vPosition;
`);


shader.vertexShader=shader.vertexShader.replace("#include <begin_vertex>",
`#include <begin_vertex>
vPosition = vec3( position );
`);


shader.fragmentShader=shader.fragmentShader.replace("#include <common>",
`#include <common>
varying vec3 vPosition;
`);


shader.fragmentShader=shader.fragmentShader.replace("#include <metalnessmap_fragment>",
`#include <metalnessmap_fragment>
metalnessFactor=smoothstep(-0.5,-0.9,vPosition.y)*0.6;
roughnessFactor=mix(0.8,1.0,smoothstep(-0.5,-0.9,vPosition.y));


`);


};


mesh["rock"]=new THREE.Mesh(new THREE.BoxGeometry(2,2,2),new THREE.MeshStandardMaterial({
map:tex["bb_diffuse"],
roughness:1.0,
normalMap:tex["bb_normal"],
normalScale:{x:1,y:1}
}));
mesh["rock"].position.set(3.5,0,6);
scene.add(mesh["rock"]);


mesh["tower"]=new THREE.Mesh(new THREE.CylinderGeometry(4,4,30,32,1),new THREE.MeshStandardMaterial({
map:tex["bb_diffuse"],
roughness:0.8,
normalMap:tex["bb_normal"],
normalScale:{x:1,y:1}
}));
mesh["tower"].castShadow=true;
mesh["tower"].position.set(-67,50,72);
scene.add(mesh["tower"]);


mesh["tube"]=new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,2,32,5),new THREE.MeshStandardMaterial({
color:0xffffff,
envMap:tex["env_sunny"],
metalness:1,
roughness:0,
}));
mesh["tube"].position.set(16.6,1,-8.4);
mesh["tube"].castShadow=true;
mesh["tube"].receiveShadow=true;
scene.add(mesh["tube"]);


mesh["terrain"].receiveShadow=true;
mesh["terrain"].castShadow=true;


for(let x=-2;x<3;x++){
for(let y=-2;y<0;y++){
if(x==0 && y==0){ continue; }
mesh["terrain_"+x+"_"+y]=mesh["terrain"].clone();
mesh["terrain_"+x+"_"+y].position.set(x*500,0,y*500);
mesh["terrain_"+x+"_"+y].matrixAutoUpdate=true;
mesh["terrain_"+x+"_"+y].updateMatrixWorld();
mesh["terrain_"+x+"_"+y].updateMatrixWorld=function(){};
scene.add(mesh["terrain_"+x+"_"+y]);
}
}


}


function instance_long(){


let bufferGeometry=mesh["grass_long"].geometry;
let geometry=new THREE.InstancedBufferGeometry();
geometry.index=bufferGeometry.index;
geometry.attributes.position=bufferGeometry.attributes.position;
geometry.attributes.uv=bufferGeometry.attributes.uv;
geometry.attributes.normal=bufferGeometry.attributes.normal;


geometry.setAttribute('offset',new THREE.InstancedBufferAttribute(new Float32Array(),3));
geometry.setAttribute('orientation',new THREE.InstancedBufferAttribute(new Float32Array(),4));
geometry.setAttribute('scale',new THREE.InstancedBufferAttribute(new Float32Array(),1));
geometry.setAttribute('color',new THREE.InstancedBufferAttribute(new Float32Array(),3));


mat["grass_long_1"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["grass_long_1"]},
wind:{value:tex["wind"]},
noiseMap:{value:tex["grass_color"]},
shadowMap:{value:tex["terrainCompleteMap"]},
time:{value:0},
sun_direction:{value:sun_direction},
},
vertexShader:vs["grass"],
fragmentShader:fs["grass"],
side:2,
transparent:true,
//alphaToCoverage:true,
});


mesh["instance_grass_long"]=new THREE.Mesh(geometry,mat["grass_long_1"]);
mesh["instance_grass_long"].renderOrder=-2; 
mesh["instance_grass_long"].castShadow=true;
mesh["instance_grass_long"].matrixAutoUpdate=false;
mesh["instance_grass_long"].updateMatrixWorld=function(){};
mesh["instance_grass_long"].frustumCulled=false;
mesh["instance_grass_long"].onBeforeRender=function(){ this.material.uniforms.time.value=time*0.002; this.customDepthMaterial.uniforms.time.value=time*0.002; this.customDepthMaterial.uniforms.xz.value=[camera.position.x,camera.position.z]; };
scene.add(mesh["instance_grass_long"]);


mat["grass_long_1_depth"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["grass_long_1"]},
time:{value:0},
xz:{value:[0,0]}
},
vertexShader:vs["grass_depth"],
fragmentShader:fs["grass_depth"],
});


mesh["instance_grass_long"].customDepthMaterial=mat["grass_long_1_depth"];

	
}


function set_flare(){


let geometry=new THREE.InstancedBufferGeometry();
geometry.setAttribute('position',new THREE.Float32BufferAttribute(new Float32Array([-0.5,0.5,0,-0.5,-0.5,0,0.5,0.5,0,0.5,-0.5,0,0.5,0.5,0,-0.5,-0.5,0]),3));
geometry.setAttribute('uv',new THREE.Float32BufferAttribute(new Float32Array([0,1,0,0,1,1,1,0,1,1,0,0]),2));
geometry.setAttribute('offset',new THREE.InstancedBufferAttribute(new Float32Array([-1,1,6,5,1,0,12,1,-5,8,1,0.5,-0.9,0.5,-9,16,0,46]),3));
geometry.setAttribute('scale',new THREE.InstancedBufferAttribute(new Float32Array([5,5,5,5,5,5,0.5,0.5,0.2,0.2,5,5]),2));
geometry.setAttribute('rotating',new THREE.InstancedBufferAttribute(new Float32Array([0.0002,-0.0002,0.0002,0.004,0,0]),1));
geometry.setAttribute('color',new THREE.InstancedBufferAttribute(new Float32Array([1,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0]),3));
geometry.setAttribute('alpha',new THREE.InstancedBufferAttribute(new Float32Array([1,0.4,0.1,0.7,0.5,0.5]),1));


mat["flare"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["sprite_yellow"]},
time:{value:0}
},
vertexShader:vs["sprite_additive"],
fragmentShader:fs["sprite_additive"],
transparent:true,
depthWrite:false,
blending:THREE.AdditiveBlending,
side:THREE.DoubleSide
})


mesh["flare"]=new THREE.Mesh(geometry,mat["flare"]);
mesh["flare"].frustumCulled=false;
mesh["flare"].matrixAutoUpdate=false;
mesh["flare"].updateMatrixWorld=function(){};
scene.add(mesh["flare"]);


}


function set_pseudo(){


vs["pseudo"]=`
attribute vec3 position;
uniform vec2 screenTransform;
uniform vec2 offset;
void main() {
// БЫЛО 512/500=1.024 И УМНОЖЕНИЕ position.xz*1.024
gl_Position=vec4((position.xz+offset)*screenTransform.xy+vec2(-1.0,1.0),0.0,1.0);
gl_PointSize=10.0;
}
`;


fs["pseudo"]=`
uniform sampler2D map;
void main() {
gl_FragColor=texture2D(map,gl_PointCoord);
}
`;


mat["pseudo"]=new THREE.RawShaderMaterial({
uniforms:{
map:{value:tex["shadow_tree"]},
// РАЗМЕР СЕКТОРА ЛАНДШАФТА
screenTransform:{value:[2.0/500.0,2.0/500.0]},
offset:{value:[0,0]}
},
vertexShader:vs["pseudo"],
fragmentShader:fs["pseudo"],
depthTest:false,
depthWrite:false,
transparent:true
});


let geometry=new THREE.BufferGeometry();
geometry.setAttribute("position",new THREE.BufferAttribute());
mesh["pseudo"]=new THREE.Points(geometry,mat["pseudo"]);
mesh["pseudo"].matrixAutoUpdate=false;
mesh["pseudo"].updateMatrixWorld=function(){};
mesh["pseudo"].frustumCulled=false;


vs["pseudo2"]=`
attribute vec3 position;
uniform vec2 screenTransform;
uniform vec2 offset;
void main() {
// БЫЛО 512/500=1.024 И УМНОЖЕНИЕ position.xz*1.024
gl_Position=vec4((position.xz+offset)*screenTransform.xy+vec2(-1.0,1.0),0.0,1.0);
gl_PointSize=20.0;
}
`;


fs["pseudo2"]=`
uniform sampler2D map;
void main() {
gl_FragColor=vec4(0.0,0.0,0.0,1.0);
//gl_FragColor=texture2D(map,gl_PointCoord);
}
`;


mat["pseudo2"]=new THREE.RawShaderMaterial({
uniforms:{
map:{value:tex["shadow_tree"]},
// РАЗМЕР СЕКТОРА ЛАНДШАФТА
screenTransform:{value:[2.0/500.0,2.0/500.0]},
offset:{value:[0,0]}
},
vertexShader:vs["pseudo2"],
fragmentShader:fs["pseudo2"],
depthTest:false,
depthWrite:false,
transparent:true
});

let geometry2=new THREE.BufferGeometry();
geometry2.setAttribute("position",new THREE.BufferAttribute(new Float32Array(12),3));
geometry2.attributes.position.array[0]=20;
geometry2.attributes.position.array[2]=-20;
geometry2.attributes.position.array[3]=480;
geometry2.attributes.position.array[5]=-20;
geometry2.attributes.position.array[6]=20;
geometry2.attributes.position.array[8]=-480;
geometry2.attributes.position.array[9]=480;
geometry2.attributes.position.array[11]=-480;


mesh["pseudo2"]=new THREE.Points(geometry2,mat["pseudo2"]);
mesh["pseudo2"].matrixAutoUpdate=false;
mesh["pseudo2"].updateMatrixWorld=function(){};
mesh["pseudo2"].frustumCulled=false;
mesh["pseudo2"].geometry.attributes.position.setUsage(THREE.DynamicDrawUsage);
mesh["pseudo2"].geometry.attributes.position.needsUpdate=true;


}


function set_other(){


mesh["d1"]=new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,1),new THREE.MeshPhongMaterial({color:0xffc000}));
mesh["d1"].geometry.translate(0,0,0.5);
mesh["d1"].material.wireframe=true;
scene.add(mesh["d1"]);
mesh["s1"]=new THREE.Mesh(new THREE.SphereGeometry(0.01,32,32),new THREE.MeshPhongMaterial({color:0xffc000}));
scene.add(mesh["s1"]);
mesh["d2"]=new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,1),new THREE.MeshPhongMaterial({color:0xffc000}));
mesh["d2"].geometry.translate(0,0,0.6);
mesh["d2"].material.wireframe=true;
scene.add(mesh["d2"]);
mesh["s2"]=new THREE.Mesh(new THREE.SphereGeometry(0.01,32,32),new THREE.MeshPhongMaterial({color:0xffc000}));
scene.add(mesh["s2"]);


mat["overlay_damage_blood"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["overlay_damage_blood"]},
intensity:{value:1.0}
},
vertexShader:vs["overlay_damage_blood"],
fragmentShader:fs["overlay_damage_blood"],
transparent:true,
depthTest:false,
depthWrite:false,
//blending:THREE.AdditiveBlending,
});


mesh["overlay_damage_blood"]=new THREE.Mesh(new THREE.PlaneGeometry(1,1),mat["overlay_damage_blood"]);
modules_to_resize.push(()=>{
mesh["overlay_damage_blood"].matrixWorld.elements[0]=screen_width;
mesh["overlay_damage_blood"].matrixWorld.elements[5]=screen_height;
});


mesh["overlay_damage_blood"].frustumCulled=false;
mesh["overlay_damage_blood"].matrixAutoUpdate=false;
mesh["overlay_damage_blood"].updateMatrixWorld=function(){};
//scene_hud.add(mesh["overlay_damage_blood"]);


mesh["object_i_ray_triangle"]=new THREE.Mesh(new THREE.SphereGeometry(0.2,16,16),new THREE.MeshBasicMaterial({color:0x009000,opacity:0.5,blending:THREE.AdditiveBlending,transparent:true,depthWrite:false}));
scene.add(mesh["object_i_ray_triangle"]);


mesh["object_i_ray_sphere_1"]=new THREE.Mesh(new THREE.SphereGeometry(2,16,16),new THREE.MeshBasicMaterial({color:0x009000,opacity:0.5,blending:THREE.AdditiveBlending,transparent:true,depthWrite:false}));
mesh["object_i_ray_sphere_1"].geometry.computeBoundingSphere();
scene.add(mesh["object_i_ray_sphere_1"]);


mesh["object_i_ray_sphere_2"]=new THREE.Mesh(new THREE.SphereGeometry(1,16,16),new THREE.MeshBasicMaterial({color:0x009000,opacity:0.5,blending:THREE.AdditiveBlending,transparent:true,depthWrite:false}));
mesh["object_i_ray_sphere_2"].geometry.computeBoundingSphere();
scene.add(mesh["object_i_ray_sphere_2"]);


mesh["status_i_ray_sphere"]=new THREE.Mesh(new THREE.SphereGeometry(0.10,3,3),new THREE.MeshLambertMaterial({color:0xffff00}));
scene.add(mesh["status_i_ray_sphere"]);


mesh["status_i_ray_AABB"]=new THREE.Mesh(new THREE.SphereGeometry(0.10,3,3),new THREE.MeshLambertMaterial({color:0xff00ff}));
scene.add(mesh["status_i_ray_AABB"]);


mesh["belmo"]=new THREE.Mesh(
new THREE.PlaneGeometry(2,2,1),
new THREE.MeshBasicMaterial({transparent:true,opacity:0.5})
)


/*
mesh["belmo"].geometry.computeBoundingSphere();
let mem_bb=mesh["belmo"].geometry.boundingSphere.center.x,belmo.geometry.boundingSphere.center.y,belmo.geometry.boundingSphere.center.z];
mesh["belmo"].geometry.center();
mesh["belmo"].geometry.translate(0,1,0);
mesh["belmo"].position.set(mem_bb[0],0,mem_bb[2]);
*/
//mesh["belmo"].position.set(0,100,0);


mesh["belmo"].geometry.translate(0,0.5,0);
scene.add(mesh["belmo"]);


mesh["rotate_sphere"]=new THREE.Mesh(
new THREE.SphereGeometry(0.1,3,3),
new THREE.MeshNormalMaterial()
);
mesh["rotate_sphere"].position.set(2,1,2);
scene.add(mesh["rotate_sphere"]);


}
function meshes_frustum_visible(item,mode){


if(mode==1){
item.traverse(function(child){
if(child.isMesh){
child.last_visible=child.visible;
child.visible=true;
child.last_frustumCulled=child.frustumCulled;
child.frustumCulled=false;
}
});
}
else{
item.traverse(function(child){
if(child.isMesh){
child.visible=child.last_visible;
child.frustumCulled=child.last_frustumCulled;
delete child.last_visible;
delete child.last_frustumCulled;
}
});
}


}


function init_end(){


window.addEventListener("resize",on_window_resize);
on_window_resize();


meshes_frustum_visible(scene,1);
meshes_frustum_visible(scene_hud,1);
renderer.render(scene,camera);
renderer.render(scene_hud,camera_hud);
meshes_frustum_visible(scene,2);
meshes_frustum_visible(scene_hud,2);


document.getElementById("loading").style.display="none";
document.getElementById("begin").style.display="block";


document.getElementById("begin").onclick=()=>{
document.getElementById("begin").onclick=()=>{}
document.getElementById("begin").style.display="none";
fullscreen_pointerlock();
stop=0;
loop();
setTimeout(()=>{
document.getElementById("project").onclick=()=>{
fullscreen_pointerlock();
}
},1000);
}


}
let press_q_can_fetch=1;
let press_q_can_num=0;


function press_q(){


document.onkeydown=(e)=>{


key(event.keyCode,1);
if(event.keyCode==81 && press_q_can_fetch){
press_q_can_fetch=0;


fetch("./shaders/water.js?v="+performance.now())
.then(response=>response.text())
.then(contents=>{
eval(contents);
mat["lake"].fragmentShader=fs["water"];
mat["lake"].vertexShader=vs["water"];
mat["lake"].needsUpdate=true;


mat["ocean"].fragmentShader=fs["water"];
mat["ocean"].vertexShader=vs["water"];
mat["ocean"].needsUpdate=true;


mat["sea"].fragmentShader=fs["water"];
mat["sea"].vertexShader=vs["water"];
mat["sea"].needsUpdate=true;


mat["river"].fragmentShader=fs["water"];
mat["river"].vertexShader=vs["water"];
mat["river"].needsUpdate=true;


fetch("./shaders/grass.js?v="+performance.now())
.then(response=>response.text())
.then(contents=>{
eval(contents);


mat["grass_long_1"].fragmentShader=fs["grass"];
mat["grass_long_1"].vertexShader=vs["grass"];
mat["grass_long_1"].needsUpdate=true;


mat["grass_long_1_depth"].fragmentShader=fs["grass_depth"];
mat["grass_long_1_depth"].vertexShader=vs["grass_depth"];
mat["grass_long_1_depth"].needsUpdate=true;


})
.catch(error=>{
console.error(error);
press_q_can_fetch=1;
});


fetch("./shaders/water_refraction.js?v="+performance.now())
.then(response=>response.text())
.then(contents=>{
eval(contents);
mat["lake_refraction"].fragmentShader=fs["water_refraction"];
mat["lake_refraction"].vertexShader=vs["water_refraction"];
mat["lake_refraction"].needsUpdate=true;


mat["ocean_refraction"].fragmentShader=fs["water_refraction"];
mat["ocean_refraction"].vertexShader=vs["water_refraction"];
mat["ocean_refraction"].needsUpdate=true;

})
.catch(error=>{
console.error(error);
press_q_can_fetch=1;
});


fetch("./shaders/basic_ao.js?v="+performance.now())
.then(response=>response.text())
.then(contents=>{
eval(contents);


tex["Box002"]=RGBELoader.load("images/lightmap/Box002VRayRawTotalLightingMap.hdr?v="+Date.now());
tex["Box004"]=RGBELoader.load("images/lightmap/Box004VRayRawTotalLightingMap.hdr?v="+Date.now());
tex["home"]=RGBELoader.load("images/lightmap/homeVRayRawTotalLightingMap.hdr?v="+Date.now());
tex["home001"]=RGBELoader.load("images/lightmap/home001VRayRawTotalLightingMap.hdr?v="+Date.now());
mesh["Box002"].material.uniforms.lightMap.value=tex["Box002"];
mesh["Box004"].material.uniforms.lightMap.value=tex["Box004"];
mesh["home"].material[0].uniforms.lightMap.value=tex["home"];
mesh["home"].material[1].uniforms.lightMap.value=tex["home"];
mesh["home"].material[2].uniforms.lightMap.value=tex["home"];
mesh["home001"].material[0].uniforms.lightMap.value=tex["home001"];
mesh["home001"].material[1].uniforms.lightMap.value=tex["home001"];


mesh["Box002"].material.fragmentShader=fs["basic_ao"];
mesh["Box002"].material.vertexShader=vs["basic_ao"];
mesh["Box002"].material.needsUpdate=true;


mesh["Box004"].material.fragmentShader=fs["basic_ao"];
mesh["Box004"].material.vertexShader=vs["basic_ao"];
mesh["Box004"].material.needsUpdate=true;


mesh["home"].material[0].fragmentShader=fs["basic_ao"];
mesh["home"].material[0].vertexShader=vs["basic_ao"];
mesh["home"].material[0].needsUpdate=true;
mesh["home"].material[1].fragmentShader=fs["basic_ao"];
mesh["home"].material[1].vertexShader=vs["basic_ao"];
mesh["home"].material[1].needsUpdate=true;
mesh["home"].material[2].fragmentShader=fs["basic_ao"];
mesh["home"].material[2].vertexShader=vs["basic_ao"];
mesh["home"].material[2].needsUpdate=true;


mesh["home001"].material[0].fragmentShader=fs["basic_ao"];
mesh["home001"].material[0].vertexShader=vs["basic_ao"];
mesh["home001"].material[0].needsUpdate=true;
mesh["home001"].material[1].fragmentShader=fs["basic_ao"];
mesh["home001"].material[1].vertexShader=vs["basic_ao"];
mesh["home001"].material[1].needsUpdate=true;


})
.catch(error=>{
console.error(error);
press_q_can_fetch=1;
});


fetch("./shaders/overlay_damage_blood.js?v="+performance.now())
.then(response=>response.text())
.then(contents=>{
eval(contents);


mat["overlay_damage_blood"].fragmentShader=fs["overlay_damage_blood"];
mat["overlay_damage_blood"].vertexShader=vs["overlay_damage_blood"];
mat["overlay_damage_blood"].needsUpdate=true;


})
.catch(error=>{
console.error(error);
press_q_can_fetch=1;
});


fetch("./shaders/underwater_pass.js?v="+performance.now())
.then(response=>response.text())
.then(contents=>{


contents=contents.replace(/const underwater_pass/,"window.underwater2");
contents=contents.replace(/export default underwater_pass;/,"");
eval(contents);


underwater_pass.material.fragmentShader=underwater2.fragmentShader;
underwater_pass.material.vertexShader=underwater2.vertexShader;
underwater_pass.material.needsUpdate=true;


})
.catch(error=>{
console.error(error);
press_q_can_fetch=1;
});


fetch("./shaders/underwater_ripples_pass.js?v="+performance.now())
.then(response=>response.text())
.then(contents=>{


contents=contents.replace(/const underwater_ripples_pass/,"window.underwater_ripples2");
contents=contents.replace(/export default underwater_ripples_pass;/,"");
eval(contents);


underwater_ripples_pass.material.fragmentShader=underwater_ripples2.fragmentShader;
underwater_ripples_pass.material.vertexShader=underwater_ripples2.vertexShader;
underwater_ripples_pass.material.needsUpdate=true;


})
.catch(error=>{
console.error(error);
press_q_can_fetch=1;
});


fetch("./shaders/correction_pass.js?v="+performance.now())
.then(response=>response.text())
.then(contents=>{


contents=contents.replace(/const correction_pass/,"window.correction2");
contents=contents.replace(/export default correction_pass;/,"");
eval(contents);


correction_pass.material.fragmentShader=correction2.fragmentShader;
correction_pass.material.vertexShader=correction2.vertexShader;
correction_pass.material.needsUpdate=true;


})
.catch(error=>{
console.error(error);
press_q_can_fetch=1;
});



press_q_can_num++;
console.log("water shader changed "+press_q_can_num);
press_q_can_fetch=1;


sounds_play(null,"shader_changed",false,false,1,0,1,false,"","");


})
.catch(error=>{
console.error(error);
press_q_can_fetch=1;
});
}
}


}
vs["water"]=`


//#define test_waves 


#ifdef ocean
uniform vec3 move;
#endif


uniform vec4 gerstner_waves[waves_amount];
uniform float gerstner_waves_speed;
uniform float time;
varying vec3 vPosition;
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vToEye;
varying vec3 vViewPosition;
#ifdef use_waves
varying float wave_height;
#endif
varying float distance_attenuation;
varying float attenuation_env;
uniform float wave_max_height;
float PI2=6.283185307179586;


#ifdef holes
uniform vec4 holes_pars;
varying vec2 holes_uv;
#endif


uniform vec2 normal_far_smoothing;
uniform vec2 sky_far_mix_value;


vec3 gerstner_wave(vec4 wave,vec3 point,inout vec3 tangent,inout vec3 binormal,float time_shift){


float steepness=wave.z;
float k=PI2/wave.w;
float c=sqrt(9.8/k);
vec2 d=wave.xy;
float f=k*(dot(d,point.xz)-c*time_shift);
float a=steepness/k;
float steepness_sin_f=steepness*sin(f);
float steepness_cos_f=steepness*cos(f);
float minus_dx_dy_steepness_sin_f=-d.x*d.y*steepness_sin_f;
tangent+=vec3(-d.x*d.x*steepness_sin_f,d.x*steepness_cos_f,minus_dx_dy_steepness_sin_f);
binormal+=vec3(minus_dx_dy_steepness_sin_f,d.y*steepness_cos_f,-d.y*d.y*steepness_sin_f);
float a_cos=a*cos(f);
return vec3(d.x*a_cos,a*sin(f),d.y*a_cos);


}


// SHADOWMAP_PARS_VERTEX


#ifdef USE_SHADOWMAP


uniform mat4 directionalShadowMatrix[NUM_DIR_LIGHT_SHADOWS];
varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];


struct DirectionalLightShadow{
float shadowIntensity;
float shadowBias;
float shadowNormalBias;
float shadowRadius;
vec2 shadowMapSize;
};


uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];


#endif


void main(){


#ifndef ocean
vUv=position.xz;
#else
vUv=position.xz+move.xz;
#endif


#ifdef use_waves


float time_shift=time*gerstner_waves_speed;


#ifndef ocean
vec3 grid_point=position;
#else
vec3 grid_point=position+move;
#endif
vec3 tangent=vec3(1.0,0.0,0.0);
vec3 binormal=vec3(0.0,0.0,1.0);
vPosition=position;
for(int i=0;i<waves_amount;i++){
vPosition+=gerstner_wave(gerstner_waves[i],grid_point,tangent,binormal,time_shift);
}


#ifdef test_waves


tangent=vec3(1.0,0.0,0.0);
binormal=vec3(0.0,0.0,1.0);
vPosition=position;


float iteration=0.0;	
float steepness=0.02;
float frequency=5.0;
for(int i=0;i<12;i++){
vec2 rnd=vec2(sin(iteration),cos(iteration));
vec4 my_wave=vec4(rnd,steepness,frequency);
vPosition+=gerstner_wave(my_wave,grid_point,tangent,binormal,time_shift);
frequency*=1.1;
iteration+=1232.399963;
}


steepness=0.02;
frequency=15.0;
for(int i=0;i<12;i++){
vec2 rnd=vec2(sin(iteration),cos(iteration));
vec4 my_wave=vec4(rnd,steepness,frequency);
vPosition+=gerstner_wave(my_wave,grid_point,tangent,binormal,time_shift);
frequency*=1.1;
iteration+=1232.399963;
}


steepness=0.05;
frequency=60.0;
for(int i=0;i<3;i++){
vec2 rnd=vec2(sin(iteration),cos(iteration));
vec4 my_wave=vec4(rnd,steepness,frequency);
vPosition+=gerstner_wave(my_wave,grid_point,tangent,binormal,time_shift);
frequency*=1.3;
iteration+=1232.399963;
}
#endif


vNormal=cross(binormal,tangent);
#else
vPosition=position;
vNormal=vec3(0.0,1.0,0.0);
#endif


#ifdef holes
#ifndef ocean
holes_uv=vPosition.xz*holes_pars.xy+holes_pars.zw;
#else
holes_uv=(vPosition.xz+move.xz)*holes_pars.xy+holes_pars.zw;
#endif
#endif


#ifdef use_waves
#ifndef ocean
float distance_to_vertex=length(vPosition-cameraPosition+modelMatrix[3].xyz);
#else
float distance_to_vertex=length(position-vec3(0.0,cameraPosition.y-modelMatrix[3].y,0.0));	
#endif	
distance_attenuation=1.0-smoothstep(0.0,normal_far_smoothing.y,distance_to_vertex-normal_far_smoothing.x);
vPosition.y*=distance_attenuation;
vNormal=mix(vec3(0.0,1.0,0.0),vNormal,distance_attenuation);
#endif


#ifdef use_sky_far_mix
#ifndef ocean
attenuation_env=1.0-smoothstep(0.0,sky_far_mix_value.x,length(position.xz-cameraPosition.xz+modelMatrix[3].xz)-sky_far_mix_value.y);
#else
attenuation_env=1.0-smoothstep(0.0,sky_far_mix_value.x,length(position.xz)-sky_far_mix_value.y);
#endif		
#endif
	

vNormal=normalize(normalMatrix*vNormal);


#ifdef use_waves
// ПРЕВРАЩАЕМ ВЫСОТУ ВОЛНЫ В ИНТЕРВАЛ ОТ 0 ДО 1
wave_height=max(0.0,vPosition.y/wave_max_height);
#endif


vec4 mvPosition=modelViewMatrix*vec4(vPosition,1.0);
gl_Position=projectionMatrix*mvPosition;


vPosition=(modelMatrix*vec4(vPosition,1.0)).xyz;
vToEye=cameraPosition-vPosition;
vViewPosition=-mvPosition.xyz;


// SHADOWMAP_VERTEX


#if defined(USE_SHADOWMAP)
for(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){
vDirectionalShadowCoord[i]=directionalShadowMatrix[i]*vec4(vPosition,1.0);
}
#endif


}


`;


fs["water"]=`


varying float attenuation_env;
uniform float time;
uniform vec3 water_top_color;
uniform vec3 water_bottom_color;
uniform float shore_transparent;
uniform vec3 wave_color;
uniform float wave_color_power;
uniform samplerCube envMap;
uniform sampler2D foam_shore_map;
uniform sampler2D foam_wave_map;
#ifdef use_caustics
uniform sampler2D caustics_map;
uniform vec2 caustics_1_dir_speed;
uniform vec2 caustics_2_dir_speed;
uniform vec3 caustics_wave;
uniform float caustics_intensity;
uniform vec2 caustics_scale_power;
uniform vec3 caustics_color;
#endif
uniform sampler2D normal_map;
uniform sampler2D scene_map;
uniform sampler2D scene_depth_map;
uniform sampler2D water_depth_map;


uniform float env_mix;
uniform float env_melt;
uniform float env_fresnel_min;
uniform float env_fresnel_power;
uniform float env_intensity;
uniform float env_max;
uniform float env_add_background;


#ifdef holes
uniform sampler2D holes_map;
varying vec2 holes_uv;
#endif
uniform vec2 screen_resolution;
uniform vec2 screen_texel_size;
uniform mat4 projectionMatrix;
uniform mat4 position_from_depth_projection;
uniform vec3 sun_direction;
uniform vec3 sun_color;
varying vec2 vUv;
varying vec3 vPosition;
varying vec3 vNormal;
varying vec3 vToEye;
varying vec3 vViewPosition;
#ifdef use_waves
varying float wave_height;
#endif
uniform float depth_offset; 
uniform float depth_beers_law;
uniform float depth_distance; 
#ifdef use_gamma
uniform float gamma; 
#endif
#ifdef use_saturation
uniform float saturation; 
#endif
#if defined fog || defined fog_exp2
uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
uniform float fogDensity;
#endif
#ifdef use_sss
uniform vec3 sss_color;
uniform vec4 sss_value;
#endif
varying float distance_attenuation;


uniform float phong_simple_intensity;
uniform float scattering_intensity;
uniform vec3 specular;
uniform vec3 foam_waves_value;
uniform vec4 foam_shore_value;
uniform float shore_smoothing_intensity;
uniform vec2 refraction_value;


uniform vec3 normal_a_value;
uniform vec3 normal_b_value;
uniform float normal_ab;
uniform vec3 normal_c_value;
uniform vec3 normal_d_value;
uniform float normal_cd;
uniform vec2 normal_small_far_total;


vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){
return normalize((vec4(dir,0.0)*matrix).xyz);
}


vec3 perturbNormal2Arb(vec3 eye_pos,vec3 N,vec3 mapN){
vec3 q0=dFdx(eye_pos.xyz);
vec3 q1=dFdy(eye_pos.xyz);
vec2 st0=dFdx(vUv);
vec2 st1=dFdy(vUv);
vec3 q1perp=cross(q1,N);
vec3 q0perp=cross(N,q0);
vec3 T=q1perp*st0.x+q0perp*st1.x;
vec3 B=q1perp*st0.y+q0perp*st1.y;
float det=max(dot(T,T),dot(B,B));
float scale=(det==0.0)?0.0:inversesqrt(det);
return normalize(T*(mapN.x*scale)+B*(mapN.y*scale)+N*mapN.z);
}


vec3 triplanar(vec3 normal,float smooth_1,float smooth_2){
vec3 blend_weights=normal*normal;
float max_blend=max(blend_weights.x,max(blend_weights.y,blend_weights.z));
blend_weights=max(blend_weights-max_blend*smooth_1,0.0);// МЯГКИЙ ПЕРЕХОД
blend_weights.y*=smooth_2;
float rcp_blend=1.0/(blend_weights.x+blend_weights.y+blend_weights.z);
return blend_weights*rcp_blend;
}


vec3 get_position_from_depth(sampler2D depth,vec2 uv){
vec4 position=position_from_depth_projection*vec4((uv*2.0-1.0),texture2D(depth,uv).r*2.0-1.0,1.0);
return position.xyz/position.w;
}


vec3 get_position_from_depth(float depth,vec2 uv){
vec4 position=position_from_depth_projection*vec4((uv*2.0-1.0),depth*2.0-1.0,1.0);
return position.xyz/position.w;
}


vec3 get_normal_from_depth_2(sampler2D depth,vec2 uv,vec2 screen_texel_size){
vec3 dpdx=get_position_from_depth(depth,uv+vec2(1,0)*screen_texel_size)-get_position_from_depth(depth,uv-vec2(1,0)*screen_texel_size);
vec3 dpdy=get_position_from_depth(depth,uv+vec2(0,1)*screen_texel_size)-get_position_from_depth(depth,uv-vec2(0,1)*screen_texel_size);
return normalize(cross(dpdx,dpdy));
}


vec3 get_normal_from_depth_3(sampler2D depth,vec2 uv,vec2 screen_texel_size){
float c0=texture(depth,uv).r;
float l2=texture(depth,uv-vec2(2,0)*screen_texel_size).r;
float l1=texture(depth,uv-vec2(1,0)*screen_texel_size).r;
float r1=texture(depth,uv+vec2(1,0)*screen_texel_size).r;
float r2=texture(depth,uv+vec2(2,0)*screen_texel_size).r;
float b2=texture(depth,uv-vec2(0,2)*screen_texel_size).r;
float b1=texture(depth,uv-vec2(0,1)*screen_texel_size).r;
float t1=texture(depth,uv+vec2(0,1)*screen_texel_size).r;
float t2=texture(depth,uv+vec2(0,2)*screen_texel_size).r;
float dl=abs(l1*l2/(2.0*l2-l1)-c0);
float dr=abs(r1*r2/(2.0*r2-r1)-c0);
float db=abs(b1*b2/(2.0*b2-b1)-c0);
float dt=abs(t1*t2/(2.0*t2-t1)-c0);
vec3 ce=get_position_from_depth(c0,uv);
vec3 dpdx=(dl<dr)?ce-get_position_from_depth(l1,uv-vec2(1,0)*screen_texel_size):-ce+get_position_from_depth(r1,uv+vec2(1,0)*screen_texel_size);
vec3 dpdy=(db<dt)?ce-get_position_from_depth(b1,uv-vec2(0,1)*screen_texel_size):-ce+get_position_from_depth(t1,uv+vec2(0,1)*screen_texel_size);
return normalize(cross(dpdx,dpdy));
}


#ifdef USE_SHADOWMAP


uniform mat4 directionalShadowMatrix[NUM_DIR_LIGHT_SHADOWS];
const float UnpackDownscale=255./256.; // 0..1 -> fraction (excluding 1)
const vec4 PackFactors=vec4(1.0,256.0,256.0*256.0,256.0*256.0*256.0);
const vec4 UnpackFactors4=vec4(UnpackDownscale/PackFactors.rgb,1.0/PackFactors.a);
float unpackRGBAToDepth(const in vec4 v){ return dot(v,UnpackFactors4); }
vec2 unpackRGBATo2Half(const in vec4 v){ return vec2(v.x+(v.y/255.0),v.z+(v.w/255.0)); }


// SHADOWMAP_PARS_FRAGMENT


struct DirectionalLightShadow{
float shadowIntensity;
float shadowBias;
float shadowNormalBias;
float shadowRadius;
vec2 shadowMapSize;
};


uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];
uniform sampler2D directionalShadowMap[NUM_DIR_LIGHT_SHADOWS];
varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];


float texture2DCompare(sampler2D depths,vec2 uv,float compare){
return step(compare,unpackRGBAToDepth(texture2D(depths,uv)));


}


vec2 texture2DDistribution(sampler2D shadow,vec2 uv){
return unpackRGBATo2Half(texture2D(shadow,uv));
}


float VSMShadow(sampler2D shadow,vec2 uv,float compare){
float occlusion=1.0;
vec2 distribution=texture2DDistribution(shadow,uv);
float hard_shadow=step(compare,distribution.x); // Hard Shadow
if(hard_shadow!=1.0){
float distance=compare-distribution.x ;
float variance=max(0.00000,distribution.y*distribution.y);
float softness_probability=variance/(variance+distance*distance); // Chebeyshevs inequality
softness_probability=clamp((softness_probability-0.3)/(0.95-0.3),0.0,1.0); // 0.3 reduces light bleed
occlusion=clamp(max(hard_shadow,softness_probability),0.0,1.0);
}
return occlusion;
}


float getShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowIntensity,float shadowBias,float shadowRadius,vec4 shadowCoord){


float shadow=1.0;
shadowCoord.xyz/=shadowCoord.w;
shadowCoord.z+=shadowBias;


bool inFrustum=shadowCoord.x>=0.0 && shadowCoord.x<=1.0 && shadowCoord.y>=0.0 && shadowCoord.y<=1.0;
bool frustumTest=inFrustum && shadowCoord.z<=1.0;


if(frustumTest){
#if defined(SHADOWMAP_TYPE_VSM)
shadow=VSMShadow(shadowMap,shadowCoord.xy,shadowCoord.z);
#else // no percentage-closer filtering:
shadow=texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z);
#endif
}


return mix(1.0,shadow,shadowIntensity);


}


vec2 cubeToUV(vec3 v,float texelSizeY){	
vec3 absV=abs(v);
float scaleToCube=1.0/max(absV.x,max(absV.y,absV.z));
absV*=scaleToCube;
v*=scaleToCube*(1.0-2.0*texelSizeY);
vec2 planar=v.xy;
float almostATexel=1.5*texelSizeY;
float almostOne=1.0-almostATexel;
if(absV.z>=almostOne){
if(v.z>0.0)
planar.x=4.0-v.x;
}else if(absV.x>=almostOne){
float signX=sign(v.x);
planar.x=v.z*signX+2.0*signX;
}else if(absV.y>=almostOne){
float signY=sign(v.y);
planar.x=v.x+2.0*signY+2.0;
planar.y=v.z*signY-2.0;
}
return vec2(0.125,0.25)*planar+vec2(0.375,0.75);
}


float getPointShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowIntensity,float shadowBias,float shadowRadius,vec4 shadowCoord,float shadowCameraNear,float shadowCameraFar){
float shadow=1.0;
vec3 lightToPosition=shadowCoord.xyz;
float lightToPositionLength=length(lightToPosition);
if(lightToPositionLength-shadowCameraFar<=0.0 && lightToPositionLength-shadowCameraNear>=0.0){
float dp=(lightToPositionLength-shadowCameraNear)/(shadowCameraFar-shadowCameraNear);
dp+=shadowBias;
vec3 bd3D=normalize(lightToPosition);
vec2 texelSize=vec2(1.0)/(shadowMapSize*vec2(4.0,2.0));
shadow=texture2DCompare(shadowMap,cubeToUV(bd3D,texelSize.y),dp);
}
return mix(1.0,shadow,shadowIntensity);
}


// SHADOWMASK_PARS_FRAGMENT


float getShadowMask_top(){


float shadow=1.0;
DirectionalLightShadow directionalLight;


#pragma unroll_loop_start
for(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){
directionalLight=directionalLightShadows[i];
shadow*=getShadow(directionalShadowMap[i],directionalLight.shadowMapSize,directionalLight.shadowIntensity,directionalLight.shadowBias,directionalLight.shadowRadius,vDirectionalShadowCoord[i]);
}
#pragma unroll_loop_end


return shadow;


}


float getShadowMask_bottom(vec4 d_position){


float shadow=1.0;
DirectionalLightShadow directionalLight;


#pragma unroll_loop_start
for(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){
directionalLight=directionalLightShadows[i];
shadow*=getShadow(directionalShadowMap[i],directionalLight.shadowMapSize,directionalLight.shadowIntensity,directionalLight.shadowBias,directionalLight.shadowRadius,directionalShadowMatrix[i]*d_position);
}
#pragma unroll_loop_end


return shadow;


}


#endif


void main(){


#ifdef holes
if(texture2D(holes_map,holes_uv).r<1.0){ discard; }
#endif


vec2 screen_uv=gl_FragCoord.xy/screen_resolution;
vec3 viewDir=normalize(vToEye); 


vec3 normal_a=texture2D(normal_map,vec2(vUv.x*normal_a_value.x+time*normal_a_value.y,vUv.y*normal_a_value.x+time*normal_a_value.z)).rgb;
vec3 normal_b=texture2D(normal_map,vec2(vUv.x*normal_b_value.x+time*normal_b_value.y,vUv.y*normal_b_value.x+time*normal_b_value.z)).rgb;


vec3 normal_small=normal_a+normal_b-1.0;
normal_small.y*=normal_ab;
normal_small=normalize(normal_small);
normal_small=perturbNormal2Arb(-vViewPosition,vNormal,normal_small);
normal_small=inverseTransformDirection(normal_small,viewMatrix);


vec3 normal_c=texture2D(normal_map,vec2(vUv.x*normal_c_value.x+time*normal_c_value.y,vUv.y*normal_c_value.x+time*normal_c_value.z)).rgb;
vec3 normal_d=texture2D(normal_map,vec2(vUv.x*normal_d_value.x+time*normal_d_value.y,vUv.y*normal_d_value.x+time*normal_d_value.z)).rgb;


vec3 normal_far=normal_c+normal_d-1.0;
normal_far.y*=normal_cd;
normal_far=normalize(normal_far);
normal_far=perturbNormal2Arb(-vViewPosition,vNormal,normal_far);
normal_far=inverseTransformDirection(normal_far,viewMatrix);


vec3 normal_big=perturbNormal2Arb(-vViewPosition,vNormal,vec3(0.0,0.0,1.0));
normal_big=inverseTransformDirection(normal_big,viewMatrix);
#if defined ocean && defined use_waves
normal_big=mix(vec3(0.0,1.0,0.0),normal_big,distance_attenuation);
#endif


normal_far=normalize(mix(normal_small,normal_far,normal_small_far_total.x));


vec3 normal_total=normalize(mix(normal_big,normal_far,normal_small_far_total.y));


// ____________________ VERTICAL DEPTH ___________________
 

float scene_depth_raw=texture2D(scene_depth_map,screen_uv).r;
float scene_depth_computed=projectionMatrix[3][2]/((scene_depth_raw*2.0-1.0)+projectionMatrix[2][2]);
float water_depth_vertical_raw=vPosition.y-((vPosition.y-cameraPosition.y)/vViewPosition.z*scene_depth_computed+cameraPosition.y);


float water_depth_vertical=water_depth_vertical_raw;


water_depth_vertical=clamp(1.0-water_depth_vertical*2.0+0.2,0.0,1.0);
water_depth_vertical=pow(water_depth_vertical,1.0);
//water_depth_vertical=1.0-exp(-water_depth_vertical);


// ____________________ REFRACTION __________________


#ifdef refraction_use
vec2 uv_distorted=screen_uv+mix(normal_small,normal_big,0.5).xz*refraction_value.x*clamp(water_depth_vertical_raw,0.0,1.0)*smoothstep(30.0,0.0,vViewPosition.z);
// УМЕНЬШАЕМ РЕФРАКЦИЮ У БЕРЕГА
uv_distorted=mix(screen_uv,uv_distorted,clamp((scene_depth_computed-vViewPosition.z)*refraction_value.y,0.0,1.0));
#else
vec2 uv_distorted=screen_uv;
#endif


// ____________________ ANGLED DEPTH ___________________


#ifdef refraction_use
float scene_depth_distorted=texture2D(scene_depth_map,uv_distorted).r;
float scene_depth_angled=projectionMatrix[3][2]/((scene_depth_distorted*2.0-1.0)+projectionMatrix[2][2]);
#else
float scene_depth_angled=scene_depth_computed;
#endif


#ifdef refraction_use


float water_depth=texture2D(water_depth_map,uv_distorted).r;
water_depth=projectionMatrix[3][2]/((water_depth*2.0-1.0)+projectionMatrix[2][2]);


#ifdef refraction_flat
if(scene_depth_angled>=water_depth){
uv_distorted=mix(screen_uv,uv_distorted,min(clamp(scene_depth_angled-water_depth,0.0,1.0)*20.0,1.0));
}
#endif


// REMOVE DISTORTION


if(scene_depth_angled<water_depth){
uv_distorted=screen_uv;
scene_depth_angled=scene_depth_computed;
}


#endif


float water_depth_angled=scene_depth_angled-vViewPosition.z;


float water_depth_angled_raw=water_depth_angled;


water_depth_angled=exp((water_depth_angled-depth_offset)*depth_beers_law);
water_depth_angled=clamp(pow(water_depth_angled,depth_distance),0.0,1.0);


float water_depth_angled_inverted=1.0-water_depth_angled;



// ____________________ VERTEX FROM DEPTH ___________________


#if (defined use_shadows && defined USE_SHADOWMAP) || defined use_caustics
vec3 d_position=get_position_from_depth(scene_depth_map,uv_distorted);
#endif


// ____________________ SHADOWS ___________________


#if defined use_shadows && defined USE_SHADOWMAP
float shadow_top_raw=getShadowMask_top();
float shadow_top_bright=min(shadow_top_raw+0.5,1.0);
float shadow_bottom=getShadowMask_bottom(vec4(d_position,1.0));
#else
float shadow_top_raw=1.0;
float shadow_top_bright=1.0;
float shadow_bottom=1.0;
#endif


#ifdef use_caustics


// ____________________ NORMAL FROM DEPTH ___________________


#if screen_normal_quality==1
vec3 screen_normal=normalize(cross(dFdx(d_position),dFdy(d_position))); // EASY
#elif screen_normal_quality==2
vec3 screen_normal=get_normal_from_depth_2(scene_depth_map,uv_distorted,screen_texel_size); // AVERAGE
#elif screen_normal_quality==3
vec3 screen_normal=get_normal_from_depth_3(scene_depth_map,uv_distorted,screen_texel_size); // HARD
#endif


// FIX BLACK HOLES
screen_normal=clamp(screen_normal,-1.0,1.0);


// ____________________ CAUSTICS ___________________


vec2 caustics_uv_x=d_position.zy*caustics_scale_power.x;
vec2 caustics_uv_y=d_position.xz*caustics_scale_power.x;
vec2 caustics_uv_z=d_position.xy*caustics_scale_power.x;


float caustics_amplitude=sin(time*caustics_wave.z)*caustics_wave.y;
vec2 caustics_waves=vec2(sin(d_position.y*caustics_wave.x+caustics_wave.z)*caustics_amplitude,sin(d_position.x*caustics_wave.x+caustics_wave.z)*caustics_amplitude);
caustics_uv_x+=caustics_waves;
caustics_uv_y+=caustics_waves;
caustics_uv_z+=caustics_waves;


vec3 caustics_weights=triplanar(screen_normal,0.25,1.0);


vec2 caustics_1_speed=vec2(time*caustics_1_dir_speed.x,time*caustics_1_dir_speed.y);
vec2 caustics_2_speed=vec2(time*caustics_2_dir_speed.x,time*caustics_2_dir_speed.y);
vec3 caustics_1=caustics_weights.x*texture2D(caustics_map,caustics_uv_x+caustics_1_speed).rgb+caustics_weights.y*texture2D(caustics_map,caustics_uv_y+caustics_1_speed).rgb+caustics_weights.z*texture2D(caustics_map,caustics_uv_z+caustics_1_speed).rgb;
vec3 caustics_2=caustics_weights.x*texture2D(caustics_map,caustics_uv_x*0.8+caustics_2_speed).rgb+caustics_weights.y*texture2D(caustics_map,caustics_uv_y*0.8+caustics_2_speed).rgb+caustics_weights.z*texture2D(caustics_map,caustics_uv_z*0.8+caustics_2_speed).rgb;
vec3 caustics=pow(min(caustics_1,caustics_2),vec3(caustics_scale_power.y))*caustics_color*caustics_intensity*pow(sun_direction.y,2.0)*shadow_bottom*max(0.0,dot(sun_direction,screen_normal));


#endif


// ____________________ WATER COLOR __________________


vec3 top_color=water_top_color*max(0.2,sun_direction.y);
vec3 bottom_color=water_bottom_color*max(0.2,sun_direction.y);


// TRANSPARENT SHORE
#ifdef use_shore_transparent
float depth_top_smooth=smoothstep(1.0,shore_transparent,water_depth_angled);
top_color=mix(vec3(1.0),top_color,depth_top_smooth);
#else
float depth_top_smooth=1.0;	
#endif


vec3 screen_map=texture(scene_map,uv_distorted).rgb;


// SIMPLE
#ifndef use_transparent_style
#ifdef use_caustics
gl_FragColor.rgb=mix(screen_map*top_color+caustics,bottom_color,water_depth_angled_inverted);
#else
gl_FragColor.rgb=mix(screen_map*top_color,bottom_color,water_depth_angled_inverted);
#endif
// TRANSPARENT
#else
#ifdef use_caustics
gl_FragColor.rgb=screen_map*mix(top_color,bottom_color,water_depth_angled_inverted)+caustics;
#else
gl_FragColor.rgb=screen_map*mix(top_color,bottom_color,water_depth_angled_inverted);
#endif
#endif


// ____________________ WAVES COLOR ___________________


#if defined use_waves && defined use_wave_color
float waves_color_limit=dot(viewDir,normal_big); 
//gl_FragColor.rgb=mix(gl_FragColor.rgb,gl_FragColor.rgb+wave_color*water_depth_angled_inverted*waves_color_limit,pow(wave_height,wave_color_power)*sun_direction.y);
gl_FragColor.rgb=mix(gl_FragColor.rgb,wave_color,pow(wave_height,wave_color_power)*sun_direction.y);
#endif


// ____________________ SSS - SUBSURFACE SCATTERING ___________________


#ifdef use_sss
vec3 sss_refraction=normalize(refract(-viewDir,normal_total,sss_value.x));
float sss_dot=pow(max(0.0,dot(sss_refraction,normalize(vec3(sun_direction.x,sun_direction.y*sss_value.w,sun_direction.z)))),sss_value.y);
gl_FragColor.rgb+=sss_dot*sss_color*sss_value.z*(1.0-sun_direction.y)*shadow_top_bright*water_depth_angled_inverted;
#endif


// ____________________ PHONG SIMPLE ___________________


#ifdef use_phong_simple
float phong_simple_dot=max(0.0,dot(sun_direction,normal_total));
gl_FragColor.rgb+=phong_simple_intensity*phong_simple_dot*sun_color*gl_FragColor.rgb*water_depth_angled_inverted;
#endif


// ____________________ SCATTERING ___________________


#ifdef use_scattering
gl_FragColor.rgb*=mix(1.0,max(0.0,dot(sun_direction,normal_total)),scattering_intensity*water_depth_angled_inverted);
#endif


// ____________________ ENV ___________________


vec3 env_normal=mix(normal_big,normal_total,env_mix);
//vec3 env_R=reflect(-viewDir,env_normal); // CUBE ENV
vec3 env_R=reflect(-viewDir,normalize(vec3(env_normal.x,env_melt,env_normal.z))); // CUBE ENV
//vec3 env_R=reflect(viewDir,vec3(-env_normal.x,-env_normal.z,-env_normal.y)); // CUBE ENV INVERTED
env_R.y=abs(env_R.y);
vec3 env_reflection_map=textureCube(envMap,env_R).rgb;
float env_fresnel_reflectance=env_fresnel_min+(1.0-env_fresnel_min)*(pow(1.0-max(0.0,dot(viewDir,env_normal)),env_fresnel_power));
gl_FragColor=vec4(mix(gl_FragColor.rgb,env_reflection_map*env_intensity+gl_FragColor.rgb*env_add_background,env_fresnel_reflectance*env_max*depth_top_smooth),1.0);


// ____________________ GAMMA ____________________


#ifdef use_gamma
gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(gamma));
#endif


// ____________________ SATURATION ____________________


#ifdef use_saturation
float luminance=dot(gl_FragColor.rgb,vec3(0.2125,0.7154,0.0721));
vec3 intensity=vec3(luminance);
gl_FragColor.rgb=mix(intensity,gl_FragColor.rgb,saturation);
#endif


#ifdef use_specular


// ____________________ SUN __________________


vec3 normal_specular=normalize(mix(normal_big,normal_small,0.5)); 


vec3 halfDir=normalize(viewDir+sun_direction);
float specular_fresnel_power=mix(specular.y,specular.z,sun_direction.y); 
float specular_fresnel=pow(max(0.0,dot(halfDir,normal_specular)),specular_fresnel_power);
#ifndef use_back
gl_FragColor.rgb+=specular.x*specular_fresnel*sun_color*shadow_top_raw;
#else
if(gl_FrontFacing){
gl_FragColor.rgb+=specular.x*specular_fresnel*sun_color*shadow_top_raw;
}	
#endif


// ____________________ BACK __________________


#ifdef use_back
if(!gl_FrontFacing){
vec3 env_R_back=reflect(-viewDir,-env_normal);
float env_fresnel_reflectance_back=env_fresnel_min+(1.0-env_fresnel_min)*(pow(1.0-max(0.0,dot(viewDir,-env_normal)),env_fresnel_power));
vec3 env_reflection_map_back=textureCube(envMap,vec3(env_R_back.x,-env_R_back.y,env_R.z)).rgb;
gl_FragColor.rgb=mix(texture2D(scene_map,screen_uv+normal_total.xz*0.5).rgb,env_reflection_map_back,env_fresnel_reflectance_back);
}
#endif


#endif


// ____________________ FOAM WAVES __________________


#if defined use_waves && defined use_foam_waves
vec3 foam_waves=texture(foam_wave_map,vUv*foam_waves_value.x).rgb;
foam_waves=foam_waves*foam_waves_value.z*max(0.2,sun_direction.y);
gl_FragColor.rgb=mix(gl_FragColor.rgb,max(gl_FragColor.rgb,foam_waves)*shadow_top_bright,pow(wave_height,foam_waves_value.y));
#endif


// ____________________ FOAM SHORE __________________


#ifdef use_foam_shore
vec3 foam_shore=texture(foam_shore_map,vUv*foam_shore_value.y+vec2(time*foam_shore_value.z,time*foam_shore_value.w)).rgb;
// FIX BUG
gl_FragColor.rgb=mix(max(gl_FragColor.rgb,foam_shore)*(0.5+sun_direction.y*0.5)*shadow_top_bright,gl_FragColor.rgb,1.0-clamp(pow(water_depth_vertical,foam_shore_value.x)*(1.0-max(0.0,water_depth_angled_raw-1.0))+normal_small.x*0.4-0.2,0.0,1.0));
#endif


// ____________________ SKY MIX __________________


#ifdef use_sky_far_mix
gl_FragColor.rgb=mix(textureCube(envMap,-viewDir).rgb,gl_FragColor.rgb,attenuation_env);
#endif


// ____________________ SHORE SMOOTHING __________________


#ifdef use_shore_smoothing
float water_depth_shore=clamp((scene_depth_computed-vViewPosition.z)*shore_smoothing_intensity,0.0,1.0);
gl_FragColor.rgb=mix(texture(scene_map,screen_uv).rgb,gl_FragColor.rgb,water_depth_shore);
#endif


// ____________________ FOG __________________


#if defined fog || defined fog_exp2
#ifdef fog
float fogFactor=smoothstep(fogNear,fogFar,vViewPosition.z);
#else
float fogFactor=1.0-exp(-fogDensity*fogDensity*vViewPosition.z*vViewPosition.z);	
#endif
gl_FragColor.rgb=mix(gl_FragColor.rgb,fogColor,fogFactor);
#endif


// CHECKING LIGHT ON NORMAL MAP
//gl_FragColor.rgb=vec3(dot(normal_small,sun_direction));


}


`;
vs["waterline"]=`


uniform float time;
#ifdef use_waves
uniform vec3 move;
uniform vec4 gerstner_waves[waves_amount];
uniform float gerstner_waves_speed;
float PI2=6.283185307179586;


vec3 gerstner_wave(vec4 wave,vec3 point,float time_shift){


float k=PI2/wave.w;
float c=sqrt(9.8/k);
vec2 d=wave.xy;
float f=k*(dot(d,point.xz)-c*time_shift);
float a=wave.z/k;
float a_cos=a*cos(f);
return vec3(d.x*a_cos,a*sin(f),d.y*a_cos);


}
#endif


void main(){


#ifdef use_waves
vec3 grid_point=position+move;
vec3 tangent=vec3(1.0,0.0,0.0);
vec3 binormal=vec3(0.0,0.0,1.0);
vec3 vPosition=position;


float time_shift=time*gerstner_waves_speed;


for(int i=0;i<waves_amount;i++){
vPosition+=gerstner_wave(gerstner_waves[i],grid_point,time_shift);
}


gl_Position=projectionMatrix*modelViewMatrix*vec4(vPosition,1.0);
#else
gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
#endif


}


`;


fs["waterline"]=`


void main(){


if(gl_FrontFacing){
gl_FragColor=vec4(0.0,0.0,0.0,1.0);
}
else{
gl_FragColor=vec4(1.0,1.0,1.0,1.0);
}


}


`;vs["water_refraction"]=`


#ifdef ocean
uniform vec3 move;
#endif


#ifdef holes
uniform vec4 holes_pars;
varying vec2 holes_uv;
#endif


#ifdef use_waves
uniform float time;
uniform vec4 gerstner_waves[waves_amount];
uniform float gerstner_waves_speed;
float PI2=6.283185307179586;


vec3 gerstner_wave(vec4 wave,vec3 point,float time_shift){


float k=PI2/wave.w;
float c=sqrt(9.8/k);
vec2 d=wave.xy;
float f=k*(dot(d,point.xz)-c*time_shift);
float a=wave.z/k;
float a_cos=a*cos(f);
return vec3(d.x*a_cos,a*sin(f),d.y*a_cos);


}
#endif


void main(){


#ifdef use_waves
#ifndef ocean
vec3 grid_point=position;
#else
vec3 grid_point=position+move;
#endif
vec3 tangent=vec3(1.0,0.0,0.0);
vec3 binormal=vec3(0.0,0.0,1.0);
vec3 vPosition=position;


float time_shift=time*gerstner_waves_speed;


for(int i=0;i<waves_amount;i++){
vPosition+=gerstner_wave(gerstner_waves[i],grid_point,time_shift);
}


#ifdef holes
#ifndef ocean
holes_uv=vPosition.xz*holes_pars.xy+holes_pars.zw;
#else
holes_uv=(vPosition.xz+move.xz)*holes_pars.xy+holes_pars.zw;
#endif
#endif


gl_Position=projectionMatrix*modelViewMatrix*vec4(vPosition,1.0);


#else

	
#ifdef holes
#ifndef ocean
holes_uv=position.xz*holes_pars.xy+holes_pars.zw;
#else
holes_uv=(position.xz+move.xz)*holes_pars.xy+holes_pars.zw;
#endif
#endif


gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);


#endif


}


`;


fs["water_refraction"]=`


#ifdef holes
uniform sampler2D holes_map;
varying vec2 holes_uv;
#endif


void main(){


#ifdef holes
if(texture2D(holes_map,holes_uv).r<1.0){ discard; }
#endif


gl_FragColor=vec4(1.0);


}


`;vs["crosshair"]=`


uniform vec4 center;


void main(){


/*
vec4 screenTransform=vec4(2.0/1920.0,-2.0/1080.0,-1.0,1.0);
gl_Position=vec4(vec2(1920.0/2.0,1080.0/2.0)*screenTransform.xy+screenTransform.zw,0.0,1.0);
ДЛЯ РАСЧЁТ В JS: var center=[screen.width/2.0*(2.0/1920.0)-1.0,screen.height/2.0*(-2.0/1080.0)+1.0,0.0,1.0];
*/


gl_Position=center;
gl_PointSize=32.0;


}


`;


fs["crosshair"]=`


uniform sampler2D map;
varying float rotation;
//float angle=3.14;
//float mid=0.5;


void main(){


gl_FragColor=texture2D(map,gl_PointCoord);


// ПОВООРОТ
/*
vec2 rotated=vec2(cos(angle)*(gl_PointCoord.x-mid)+sin(angle)*(gl_PointCoord.y-mid)+mid,cos(angle)*(gl_PointCoord.y-mid)-sin(angle)*(gl_PointCoord.x-mid)+mid);
vec4 rotatedTexture=texture2D(map,rotated);
gl_FragColor=rotatedTexture;
*/


}


`;
vs["overlay_damage_blood"]=`


varying vec2 vUv;


void main(){


vUv=uv;


gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);


}


`;


fs["overlay_damage_blood"]=`


uniform sampler2D map;
uniform float intensity;
varying vec2 vUv;


void main(){


gl_FragColor=texture2D(map,vUv)*intensity;


}


`;vs["sprite"]=`


attribute vec3 offset;
attribute vec2 scale;
attribute vec4 quaternion;
attribute float rotation;
attribute vec4 color;
attribute float blend;
attribute vec4 frame;
attribute float texture;
varying vec2 vUv;
varying vec4 vColor;
varying float vBlend;
varying vec4 vFrame;
varying float tex_num;
uniform float time;
uniform vec3 cameraDirection;
uniform vec2 cameraAngle;
vec3 localUpVector=vec3(0.0,1.0,0.0);


void main(){


float angle=time*rotation;
vec3 vRotated=vec3(position.x*scale.x*cos(angle)-position.y*scale.y*sin(angle),position.y*scale.y*cos(angle)+position.x*scale.x*sin(angle),position.z);


vUv=uv;
vColor=color;
vBlend=blend;
tex_num=texture;
vFrame=frame;


vec3 vPosition;



if(quaternion.w<2.0){
vec3 vcV=cross(quaternion.xyz,vRotated);
vPosition=vcV*(2.0*quaternion.w)+(cross(quaternion.xyz,vcV)*2.0+vRotated);
}


else if(quaternion.w==2.0){


// ДЕФЕКТ: ЕСЛИ СПРАЙТ ВРАЩАЕТСЯ, ТО ПРИ ПОВОРОТЕ КАМЕРЫ СПРАЙТ КАК БЫ ЗАМИРАЕТ
// ТО ЕСТЬ ЛУЧШЕ ИСПОЛЬЗОВАТЬ ДЛЯ СТАТИЧНЫХ СПРАЙТОВ
vec3 cameraRight=vec3(viewMatrix[0].x,viewMatrix[1].x,viewMatrix[2].x);
vec3 cameraUp=vec3(viewMatrix[0].y,viewMatrix[1].y,viewMatrix[2].y);
vPosition=(cameraRight*vRotated.x)+(cameraUp*vRotated.y);


}


else if(quaternion.w==3.0){


vec3 vLook=normalize(cameraPosition-offset);
vec3 vRight=normalize(cross(vLook,localUpVector));
vec3 vUp=normalize(cross(vLook,vRight));
vPosition=vRight*vRotated.x+vUp*vRotated.y+vLook*vRotated.z;


}


else if(quaternion.w==4.0){


vec3 vLook=offset-cameraPosition;
vec3 vRight=normalize(cross(vLook,localUpVector));
vPosition=vRotated.x*vRight+vRotated.y*localUpVector+vRotated.z;


}


else if(quaternion.w==5.0){


vec3 vLook=normalize(quaternion.xyz-offset);
vec3 vRight=normalize(cross(vLook,localUpVector));
vec3 vUp=normalize(cross(vLook,vRight));
vPosition=vRight*vRotated.x+vUp*vRotated.y+vLook*vRotated.z;


}


else if(quaternion.w==6.0){


vec3 vLook=normalize(offset-cameraPosition);
vec3 xaxis=normalize(cross(vLook,quaternion.xyz));
vec3 zaxis=normalize(cross(xaxis,quaternion.xyz));
mat3 rotMatrix=mat3(vec3(xaxis.x,quaternion.x,zaxis.x),vec3(xaxis.y,quaternion.y,zaxis.y),vec3(xaxis.z,quaternion.z,zaxis.z));
vPosition=vec3(dot(rotMatrix[0],vRotated),dot(rotMatrix[1],vRotated),dot(rotMatrix[2],vRotated));


}


else if(quaternion.w==7.0){


vec4 mvPosition=modelViewMatrix*vec4(offset,1.0);
vec3 viewVelocity=normalMatrix*quaternion.xyz;
vPosition=vec3(position.xy*scale.x,vRotated.z);


float spherical_intensity=1.0-abs(dot(quaternion.xyz,cameraDirection));
mvPosition.xyz+=vPosition+dot(vPosition,viewVelocity)*viewVelocity/length(viewVelocity)*scale.y*spherical_intensity;


gl_Position=projectionMatrix*mvPosition;
return;


}


gl_Position=projectionMatrix*modelViewMatrix*vec4(vPosition+offset,1.0);


}


`;


fs["sprite"]=`


const int count=15;
uniform sampler2D map[count];
varying vec2 vUv;
varying vec4 vColor;
varying float vBlend;
varying vec4 vFrame;
varying float tex_num;


void main(){


float tex_num_2=round(tex_num);


if(tex_num_2==0.0){ gl_FragColor=texture2D(map[0],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==1.0){ gl_FragColor=texture2D(map[1],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==2.0){ gl_FragColor=texture2D(map[2],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==3.0){ gl_FragColor=texture2D(map[3],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==4.0){ gl_FragColor=texture2D(map[4],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==5.0){ gl_FragColor=texture2D(map[5],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==6.0){ gl_FragColor=texture2D(map[6],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==7.0){ gl_FragColor=texture2D(map[7],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==8.0){ gl_FragColor=texture2D(map[8],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==9.0){ gl_FragColor=texture2D(map[9],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==10.0){ gl_FragColor=texture2D(map[10],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==11.0){ gl_FragColor=texture2D(map[11],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==12.0){ gl_FragColor=texture2D(map[12],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==13.0){ gl_FragColor=texture2D(map[13],vUv/vFrame.xy+vFrame.zw)*vColor; }
else if(tex_num_2==14.0){ gl_FragColor=texture2D(map[14],vUv/vFrame.xy+vFrame.zw)*vColor; }


gl_FragColor.rgb*=gl_FragColor.a; 
gl_FragColor.a*=vBlend; 


}


`;
vs["sprite_additive"]=`


varying vec2 vUv;
attribute vec3 offset;
attribute vec2 scale;
uniform float time;
vec3 localUpVector=vec3(0.0,1.0,0.0);


#ifdef USE_rotating
attribute float rotating;
#endif


#ifdef USE_color
attribute vec3 color;
varying vec3 vColor;
#endif


#ifdef USE_alpha
attribute float alpha;
varying float vAlpha;
#endif


void main(){


#ifdef USE_rotating
float angle=time*rotating;
vec2 rotated=vec2(cos(angle)*(uv.x-0.5)+sin(angle)*(uv.y-0.5)+0.5,cos(angle)*(uv.y-0.5)-sin(angle)*(uv.x-0.5)+0.5);
vUv=rotated;
#else
vUv=uv;
#endif


#ifdef USE_color
vColor=color;
#endif


#ifdef USE_alpha
vAlpha=alpha;
#endif


#ifdef USE_followXZ
vec3 vPosition=position;
float x=offset.x-cameraPosition.x;
float z=offset.z-cameraPosition.z;
float angleXZ=acos(z/sqrt(x*x+z*z));
if(x>0.0){ angleXZ*=-1.0; }
vPosition.x=cos(angleXZ)*position.x-sin(angleXZ)*position.z;
vPosition.z=cos(angleXZ)*position.z+sin(angleXZ)*position.x;
vPosition.xz*=scale.x;
vPosition.y*=scale.y;
#else
vec3 vLook=normalize(offset-cameraPosition);
vec3 vRight=normalize(cross(vLook,localUpVector));
vec3 vUp=normalize(cross(vLook,vRight));
vec3 vPosition=vRight*position.x*scale.x+vUp*position.y*scale.y+vLook*position.z;
#endif


     
gl_Position=projectionMatrix*modelViewMatrix*vec4(vPosition+offset,1.0);


}


`;


fs["sprite_additive"]=`


uniform sampler2D map;
varying vec2 vUv;


#ifdef USE_color
varying vec3 vColor;
#endif


#ifdef USE_alpha
varying float vAlpha;
#endif


#ifdef USE_alphaMap
uniform sampler2D alphaMap;
uniform float alphaTest;
#endif


void main(){


#ifdef USE_smoke
gl_FragColor=texture2D(map,vUv);
//gl_FragColor.rgb*=vec3(0.1,0.1,0.1);
gl_FragColor.rgb*=vColor;
gl_FragColor.rgb*=gl_FragColor.a;
//gl_FragColor.a*=0.5; 
#else


#ifdef USE_alphaMap
if(texture2D(alphaMap,vUv).r<alphaTest){ discard; }
#endif


vec3 diffuse=texture2D(map,vUv).rgb;


#ifdef USE_color
diffuse*=vColor;
#endif


#ifndef USE_oneAlpha
#ifndef USE_alpha
float a=texture2D(map,vUv).a;
#else
float a=texture2D(map,vUv).a*vAlpha;
#endif
#else
float a=1.0;
#endif


gl_FragColor=vec4(diffuse,a);


#endif


}


`;
vs["stone"]=`


varying vec2 vUv;
attribute vec2 uv2;
varying vec2 vUv2;
varying vec3 vPosition;
varying vec3 vNormal;
varying vec3 vLightDir;
varying vec3 vViewPosition;
varying float fogFactor;
vec3 lightPosition=vec3(60.0,100.0,60.0);


void main(){


vPosition=position;


vec4 mvPosition=modelViewMatrix*vec4(vPosition,1.0);


fogFactor=smoothstep(50.0,800.0,length(mvPosition));


vViewPosition=-mvPosition.xyz;


vec3 vLightPosition=(viewMatrix*vec4(lightPosition,1.0)).xyz;
//vLightDir=vLightPosition-mvPosition.xyz; // POINT LIGHT
vLightDir=normalize(vLightPosition); // DIRECTIONAL LIGHT

vNormal=normalize(normalMatrix*normal);


vUv=uv;
vUv2=uv2;


gl_Position=projectionMatrix*mvPosition;


}


`;


fs["stone"]=`


uniform sampler2D map;
uniform vec2 mapRepeat;
uniform sampler2D normalMap;
uniform vec2 normalScale;
uniform vec2 normalRepeat;
uniform sampler2D specularMap;
uniform vec2 specularRepeat;
uniform sampler2D aoMap;
uniform float shininess;
uniform float glossiness;
varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUv;
varying vec2 vUv2;
varying vec3 vLightDir;
varying vec3 vViewPosition;
varying float fogFactor;
uniform vec3 fogColor;
//vec3 lightColor=vec3(0.99,0.94,0.75);
vec3 lightColor=vec3(0.99,0.87,0.49);
//vec3 specularColor=vec3(0.99,0.94,0.75);
vec3 specularColor=vec3(0.99,0.87,0.49);
vec3 ambient=vec3(0.2,0.2,0.2);
vec3 gamma=vec3(1.0,1.0,1.0);
vec3 rimColor=vec3(0.99,0.94,0.75);


// РАСЧЁТ БЛЕСКА ПО ФОНГУ


#define PI 3.141592653589793


vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}


#define RECIPROCAL_PI 0.3183098861837907
#define EPSILON 1e-6
float pow2( const in float x ) { return x*x; }


float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}


float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}


float G1V(float dotNV,float k) {
return 1.0/(dotNV*(1.0-k)+k);
}


vec3 LightingFuncGGX_REF(vec3 N,vec3 V,vec3 L,float roughness,float F0){


float alpha=roughness*roughness;


// half vector
vec3 H=normalize(V+L);
float dotNL=clamp(dot(N,L),0.0,1.0);
float dotNV=clamp(dot(N,V),0.0,1.0);
float dotNH=clamp(dot(N,H),0.0,1.0);
float dotLH=clamp(dot(L,H),0.0,1.0);


// D - microfacet distribution function, shape of specular peak
float alphaSqr=alpha*alpha;


float pi=3.14159;
float denom=dotNH*dotNH*(alphaSqr-1.0)+1.0;
//float D=alphaSqr/(pi*denom*denom);


float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
// F - fresnel reflection coefficient
//float F=fresnel+(1.0-fresnel)*pow(1.0-dotLH,5.0);
//float F=F0+(1.0-F0)*pow(1.0-dotLH,5.0);


// V / G - geometric attenuation or shadowing factor
float k=alpha/2.0;
float vis=G1V(dotNL,k)*G1V(dotNV,k);


//float specular=dotNL*D*F*vis;


//return specular;


vec3 F = F_Schlick( specularColor, dotLH );
float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
float  D = D_GGX( alpha, dotNH );
return F * ( G * D );
  
}


float saturate2(float f) {
    return clamp(f, 0.0, 1.0);
}


float chiGGX(float v) {
    return v > 0.0 ? 1.0 : 0.0;
}


float GGX_Distribution(vec3 n, vec3 h, float alpha) {
    float NoH = dot(n,h);
    float alpha2 = alpha * alpha;
    float NoH2 = NoH * NoH;
    float den = NoH2 * alpha2 + (1.0 - NoH2);
    //chiGGX removed to follow Graphics Rants, will get away with NdotL anyway
    return (chiGGX(NoH) * alpha2) / ( PI * den * den );
    //return (alpha2) / ( PI * den * den );
}


float GGX_PartialGeometryTerm(vec3 v, vec3 n, vec3 h, float alpha)
{
    float VoH2 = saturate2(dot(v,h));
    float chi = chiGGX( VoH2 / saturate2(dot(v,n)) );
    VoH2 = VoH2 * VoH2;
    float tan2 = ( 1.0 - VoH2 ) / VoH2;
    //return chi / (1 + tan2);
    //return ( 1 + sqrt( 1 + alpha * alpha * tan2 ));
    return (chi * 2.0) / ( 1.0 + sqrt( 1.0 + alpha * alpha * tan2 ) );
}


vec3 Fresnel_Schlick(float cosT, vec3 F0)
{
  return F0 + (1.0-F0) * pow( 1.0 - cosT, 5.0);
}
vec3 F_Schlick(vec3 F0, float fd90, float cosT)
{
  return F0 + fd90 * pow( 1.0 - cosT, 5.0);
}


float Fr_DisneyDiffuse(float NdotV, float NdotL, float LdotH, float linearRoughness)
{
    float energyBias = mix(0.0, 0.5, linearRoughness);
    float energyFactor = mix(1.0, 1.0 / 1.51, linearRoughness);
    float fd90 = energyBias + 2.0 * LdotH*LdotH * linearRoughness;
    vec3 f0 = vec3(1.0, 1.0, 1.0);
    float lightScatter = F_Schlick(f0, fd90, NdotL).r;
    float viewScatter = F_Schlick(f0, fd90, NdotV).r;
    return lightScatter * viewScatter * energyFactor;
}


mat3 getTSN(vec3 eye_pos,vec3 surf_norm) {


vec3 q0=vec3(dFdx(eye_pos.x),dFdx(eye_pos.y),dFdx(eye_pos.z));
vec3 q1=vec3(dFdy(eye_pos.x),dFdy(eye_pos.y),dFdy(eye_pos.z));
vec2 st0=dFdx(vUv.st);
vec2 st1=dFdy(vUv.st);
float scale=sign(st1.t*st0.s-st0.t*st1.s); // we do not care about the magnitude
vec3 S=normalize((q0*st1.t-q1*st0.t)*scale);
vec3 T=normalize((-q0*st1.s+q1*st0.s)*scale);
vec3 N=normalize(surf_norm);


return mat3(S,T,N);


}


void main(){


mat3 tsn=getTSN(-vViewPosition,vNormal);


vec3 normalTex=texture2D(normalMap,vUv*normalRepeat).xyz*2.0-1.0;
normalTex.xy*=normalScale;


vec3 normal=normalize(tsn*normalTex);


vec3 L=normalize(vLightDir);
vec3 V=normalize(vViewPosition);


float lambert=max(0.0,dot(normal,L));


vec3 diffuse=texture2D(map,vUv*mapRepeat).rgb;


vec3 finalColor=ambient*diffuse+diffuse*lightColor*lambert;



float uIor=1.45;
float metalness=0.0;
float roughness=0.4;

vec3 F0 = vec3(abs((1.0 - uIor) / (1.0 + uIor)));
    F0 = F0 * F0;
    //F0 = vec3(0.04); //0.04 is default for non-metals in UE4
    F0 = mix(F0, ambient, metalness);


vec3 H = normalize(V + L);
vec3 N=normal;
    float VdotH = saturate2(dot(V, H));
    float NdotL = saturate2(dot(N, L));
    float NdotH = saturate2(dot(N, H));
    float NdotV = saturate2(dot(N, V));
    float LdotH = saturate2(dot(L, N));


//F0=vec3(exp2( ( -5.55473 * LdotH - 6.98316 ) * LdotH ));


    float alpha = roughness * roughness;
    float D = GGX_Distribution(N, H, alpha);
    float G = GGX_PartialGeometryTerm(V, N, H, alpha);
    vec3 F = Fresnel_Schlick(VdotH, F0); //VdotH
    float Fd = Fr_DisneyDiffuse(NdotV, NdotL, LdotH, roughness);
   // float denom = saturate2( 4.0 * (NdotV * NdotH + 0.01) );
       float denom = saturate2( 1.0 * (NdotV * NdotH + 0.01) );
    //vec3 indirectSpecular = D * G * F / denom;
    vec3 directSpecular = specularColor * NdotL * D * G * F / denom;;
 //finalColor+=directSpecular;


vec3 H2 = normalize(V + L);
vec3 R=reflect(-L,normal);
float specular=pow(saturate2(dot(H2,normal)),shininess)*glossiness;


float exponential=pow(1.0-VdotH,5.0);
float FF0=4.2;
float fresnel=exponential+FF0*(1.0-exponential);
specular*=fresnel;
float FF=exp2((-5.55473*LdotH-6.98316)*LdotH);
//specular*=FF*20.0;
finalColor+=specularColor*specular;



gl_FragColor=vec4(finalColor,1.0);


}


`;
vs["wall"]=`


varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vLightDir;
varying vec3 vViewPosition;
varying vec3 vPosition;


vec3 lightPosition=vec3(60.0,100.0,60.0);


void main(){


vPosition=position;


gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);


vUv=uv*1.0;
vNormal=normalMatrix*normal;
vec3 vLightPosition=(viewMatrix*vec4(lightPosition,1.0)).xyz;
//vLightDir=vLightPosition-mvPosition.xyz; // POINT LIGHT
vLightDir=normalize(vLightPosition); // DIRECTIONAL LIGHT
vViewPosition=-vPosition.xyz;


vec4 vertPos4 = modelViewMatrix * vec4(position, 1.0);
  vPosition = vec3(vertPos4) / vertPos4.w;



}


`;


fs["wall"]=`


uniform sampler2D map;
uniform sampler2D normalMap;
uniform vec2 normalScale;
uniform vec2 normalRepeat;


varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vLightDir;
varying vec3 vViewPosition;
varying vec3 vPosition;

vec4 light_color=vec4(0.75,0.93,0.99,0.0);
vec4 specular_color=vec4(0.75,0.93,0.99,0.0);
vec4 ambient=vec4(0.2,0.2,0.2,1.0);



vec3 perturbNormalArb(vec3 eye_pos,vec3 surf_norm) {


vec3 q0=vec3(dFdx(eye_pos.x),dFdx(eye_pos.y),dFdx(eye_pos.z));
vec3 q1=vec3(dFdy(eye_pos.x),dFdy(eye_pos.y),dFdy(eye_pos.z));
vec2 st0=dFdx(vUv.st);
vec2 st1=dFdy(vUv.st);
float scale=sign(st1.t*st0.s-st0.t*st1.s); // we do not care about the magnitude
vec3 S=normalize((q0*st1.t-q1*st0.t)*scale);
vec3 T=normalize((-q0*st1.s+q1*st0.s)*scale);
vec3 N=normalize(surf_norm);
mat3 tsn=mat3(S,T,N);


vec3 mapN=texture2D(normalMap,vUv*normalRepeat).xyz*2.0-1.0;
mapN.xy*=vec2(normalScale.x,normalScale.y*1.0);


return normalize(tsn*mapN);


}





vec3 blinnPhongBRDF(vec3 lightDir, vec3 viewDir, vec3 normal, vec3 phongDiffuseCol, vec3 phongSpecularCol, float phongShininess) {
  vec3 color = phongDiffuseCol;
  vec3 halfDir = normalize(viewDir + lightDir);
  float specDot = max(dot(halfDir, normal), 0.0);
  color += pow(specDot, phongShininess) * phongSpecularCol;
  return color;
}


const vec3 lightPos = vec3(60.0, 100.0, 60.0);
const vec3 lightColor = vec3(1.0, 1.0, 1.0);
const float lightPower = 40.0;
const vec3 ambientColor = vec3(0.1, 0.1, 0.1);
const vec3 diffuseColor = vec3(0.0, 0.0, 0.0);
const vec3 specColor = vec3(1.0, 1.0, 1.0);
const float shininess = 60.0;
const float screenGamma = 2.2; // Assume the monitor is calibrated to the sRGB color space

void main(){




vec3 N=normalize(vNormal);
vec3 L=normalize(vLightDir);
vec3 V=normalize(vViewPosition);


vec3 PN=perturbNormalArb(-V,N);


vec4 diffuse=texture2D(map,vUv);
vec4 final_color=ambient*diffuse;


float lambert=dot(PN,L);


if(lambert>0.0){
vec3 R=reflect(-L,PN);
float specular=pow(max(dot(R,V),0.0),shininess);
final_color+=light_color*lambert*diffuse+specular_color*specular;
}


gl_FragColor=final_color;

int mode=1;

vec3 normal=PN;
vec3 lightDir = lightPos - vPosition;
  float distance = length(lightDir);
  distance = distance * distance;
  lightDir = normalize(lightDir);

  float lambertian = max(dot(lightDir, normal), 0.0);
  float specular = 0.0;

  if (lambertian > 0.0) {

    vec3 viewDir = normalize(-vPosition);

    // this is blinn phong
    vec3 halfDir = normalize(lightDir + viewDir);
    float specAngle = max(dot(halfDir, normal), 0.0);
    specular = pow(specAngle, shininess);

    // this is phong (for comparison)
    if (mode == 2) {
      vec3 reflectDir = reflect(-lightDir, normal);
      specAngle = max(dot(reflectDir, viewDir), 0.0);
      // note that the exponent is different here
      specular = pow(specAngle, shininess/4.0);
    }
  }
  vec3 colorLinear = diffuse.rgb +
                     diffuseColor * lambertian * lightColor * lightPower / distance +
                     specColor * specular * lightColor * lightPower / distance;
  // apply gamma correction (assume ambientColor, diffuseColor and specColor
  // have been linearized, i.e. have no gamma correction in them)
  vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0 / screenGamma));
  // use the gamma corrected color in the fragment
  gl_FragColor = vec4(colorGammaCorrected, 1.0);


}


`;
vs["basic_ao"]=`


varying vec2 vUv;
attribute vec2 uv2;
varying vec2 vUv2;


void main(){


vUv=uv;
vUv2=uv2;


gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);


}


`;


fs["basic_ao"]=`


uniform sampler2D map;
uniform sampler2D lightMap;
uniform sampler2D shadow_map;
varying vec2 vUv;
varying vec2 vUv2;
vec2 texSize=vec2(256.0,256.0);


vec3 bilinearFilter(){


vec2 texelSize=vec2(1.0)/texSize;
vec2 uvFloor=floor(vUv2*texSize);
vec2 uvFrac=fract(vUv2*texSize);
vec3 bottomLeft=texture2D(lightMap,uvFloor*texelSize).rgb;
vec3 bottomRight=texture2D(lightMap,(uvFloor+vec2(1.0,0.0))*texelSize).rgb;
vec3 topLeft=texture2D(lightMap,(uvFloor+vec2(0.0,1.0))*texelSize).rgb;
vec3 topRight=texture2D(lightMap,(uvFloor+vec2(1.0,1.0))*texelSize).rgb;
vec3 bottom=mix(bottomLeft,bottomRight,uvFrac.x);
vec3 top=mix(topLeft,topRight,uvFrac.x);
return mix(bottom,top,uvFrac.y);


}


vec3 bicubicFilter(){


vec2 iTc=vUv2;
iTc*=texSize;
vec2 tc=floor(iTc-0.5)+0.5;


vec2 f=iTc-tc;
vec2 f2=f*f;
vec2 f3=f2*f;
vec2 omf=1.0-f;
vec2 omf2=omf*omf;
vec2 omf3=omf2*omf;


vec2 w0=omf3/6.0;
vec2 w1=(4.0+3.0*f3-6.0*f2)/6.0;
vec2 w2=(4.0+3.0*omf3-6.0*omf2)/6.0;
vec2 w3=f3/6.0f;


vec2 s0=w0+w1;
vec2 s1=w2+w3;


vec2 f0=w1/(w0+w1);
vec2 f1=w3/(w2+w3);


vec2 t0=tc-1.0+f0;
vec2 t1=tc+1.0+f1;


t0/=texSize;
t1/=texSize;


return
texture2D(lightMap,vec2(t0.x,t0.y)).rgb*s0.x*s0.y+
texture2D(lightMap,vec2(t1.x,t0.y)).rgb*s1.x*s0.y+
texture2D(lightMap,vec2(t0.x,t1.y)).rgb*s0.x*s1.y+
texture2D(lightMap,vec2(t1.x,t1.y)).rgb*s1.x*s1.y;


}


void main(){


//vec3 lightMapTotal=texture2D(lightMap,vUv2).rgb; // 0.01 MS
//vec3 lightMapTotal=bilinearFilter(); // 0.02 MS
vec3 lightMapTotal=bicubicFilter();// 0.05 MS


// SRGB IS NOT NECESSARY FOR HDR, BECAUSE IT ALREADY IS IN IT


float gamma=1.0; // EVENS OUT DARK COLORS. FOR CONTRAST, YOU CAN SET 0.42, 0.8
float exposure=1.0; // AFFECTS THE VISIBILITY OF DETAILS
float saturation=1.0; // SATURATION
float contrast=0.0; // CONTRAST


float luminance=dot(lightMapTotal,vec3(0.2125,0.7154,0.0721));
vec3 intensity=vec3(luminance);
lightMapTotal=mix(intensity,lightMapTotal,saturation);
lightMapTotal=(lightMapTotal-0.5)/(1.0-contrast)+0.5;
lightMapTotal=pow(lightMapTotal,vec3(1.0/gamma))*exposure;


gl_FragColor=vec4(clamp(texture2D(map,vUv).rgb*lightMapTotal,0.0,1.0),1.0);
//gl_FragColor=vec4(clamp(lightMapTotal,0.0,1.0),1.0);
//gl_FragColor=vec4(texture2D(lightMap,vUv2).rgb,1.0);
//gl_FragColor=vec4(lightMapTotal,1.0);


/*
here on the back side of the wall, if the shadow reception is turned off, then the wall shines with the sun, and in order not to shine, you need to turn off the sun on the back side of the normal, and leave the other lights on
Of course you can insert your own normal code
incorrect. because the object may be in the basement and the sun will shine on its outer side. although if you take the shadow from the sun, then it may be normal, because the shadow will fall on it.
mesh["Box002"].material=new THREE.MeshStandardMaterial()
mesh["Box002"].material.map=tex["wall_237"];
mesh["Box002"].material.lightMap=RGBELoader.load("images/lightmap/Box002VRayRawTotalLightingMap.hdr?v="+Date.now());
mesh["Box002"].material.lightMap.channel=2;
//mesh["Box002"].material.envMap=tex["env_sunny"];
mesh["Box002"].material.normalMap=tex["wall_238_n"]
mesh["Box002"].material.normalScale={x:1,y:-1};
mesh["Box002"].material.lightMapIntensity=1;
mesh["Box002"].material.metalness=0.2;
mesh["Box002"].material.roughness=0.2;
mesh["Box002"].receiveShadow=true;
mesh["Box002"].castShadow=true;
mesh["Box002"].material.needsUpdate=true;


mesh["Box002"].material=new THREE.MeshStandardMaterial()
mesh["Box002"].material.map=tex["wall_118"];
mesh["Box002"].material.lightMap=RGBELoader.load("images/lightmap/Box002VRayRawTotalLightingMap.hdr?v="+Date.now());
mesh["Box002"].material.lightMap.channel=2;
mesh["Box002"].material.lightMapIntensity=3;
mesh["Box002"].material.metalness=0;
mesh["Box002"].material.roughness=1;
mesh["Box002"].receiveShadow=true;
mesh["Box002"].castShadow=true;
mesh["Box002"].material.needsUpdate=true;


mesh["Box004"].material=new THREE.MeshStandardMaterial()
mesh["Box004"].material.map=tex["wall_237"];
mesh["Box004"].material.lightMap=RGBELoader.load("images/lightmap/Box004VRayRawTotalLightingMap.hdr?v="+Date.now());
mesh["Box004"].material.lightMap.channel=2;
//mesh["Box004"].material.envMap=tex["env_sunny"];
mesh["Box004"].material.normalMap=tex["wall_238_n"]
mesh["Box004"].material.normalScale={x:1,y:-1};
mesh["Box004"].material.lightMapIntensity=1;
mesh["Box004"].material.metalness=0.4;
mesh["Box004"].material.roughness=0.5;
mesh["Box004"].receiveShadow=true;
mesh["Box004"].castShadow=true;
mesh["Box004"].material.needsUpdate=true;


*/


}


`;vs["grass"]=`


attribute float scale;
attribute vec3 offset;
attribute vec4 orientation;
attribute vec3 color;
varying vec3 vViewPosition;
varying vec3 vPosition;
varying vec2 vUv;
varying vec3 vColor;
uniform float time;
uniform vec3 sun_direction;
varying float vLight;
varying vec2 shadowUv;
varying vec2 noise_uv_y;
varying float fogFactor;
varying float m;
varying float dec;
vec3 localUpVector=vec3(0.0,1.0,0.0);

uniform sampler2D noiseMap;
uniform sampler2D wind;


float noise_random_value(vec2 st){


return fract(sin(st.x*12.+st.y*15.)*19.);


}


float noise_get(vec2 st){


vec2 lv=fract(st);
vec2 id=floor(st);


lv=lv*lv*(3.0-2.0*lv);


float bl=noise_random_value(id);
float br=noise_random_value(id+vec2(1,0));
float b=mix(bl,br,lv.x);


float tl=noise_random_value(id+vec2(0,1));
float tr=noise_random_value(id+vec2(1,1));
float t=mix(tl,tr,lv.x);


return mix(b,t,lv.y);


}


void main(){


float distance_2d=distance(cameraPosition.xz,offset.xz);
if(distance_2d>150.0){ gl_Position=vec4(2.0,2.0,2.0,1.0); return; }


vPosition=position;
vPosition.xz/=1.0;
// ШИРОКАЯ ТРАВА
vPosition.y/=2.0;
vPosition*=2.0;
vPosition.y-=0.2;


vec3 vcV=cross(orientation.xyz,vPosition);
vPosition=vcV*(2.0*orientation.w)+cross(orientation.xyz,vcV)*2.0+vPosition;


vec3 vLook=offset-cameraPosition;
vec3 vRight=normalize(cross(vLook,localUpVector));
//vec3 vPosition=position.x*vRight+position.y*localUpVector+position.z;

float noise_value=0.0;
if(position.y>0.0){
// ДЛЯ УЧЁТА НАКЛОНА ПОВЕРХНОСТИ
/*
vec3 bbb=vec3(sin(time*0.75+cos(length(offset)))*0.5,0.0,cos(time*0.5+cos(length(offset)))*0.5);
vec3 noise_value=cross(orientation.xyz,bbb);
bbb=noise_value*(2.0*orientation.w)+cross(orientation.xyz,noise_value)*2.0+bbb;
vPosition.x+=bbb.x;
vPosition.z+=bbb.z;
*/

float power=1.0;


vec2 wind_pos=vPosition.xz+offset.xz+uv.y;


vec2 wind_uv=wind_pos*0.3+vec2(time*0.7*power,time*0.7*power);
float noise_value=noise_get(wind_uv);
float xx=(noise_value*2.0-1.0)*0.3*noise_value;


wind_uv=wind_pos*0.5+vec2(-time*0.6*power,-time*1.0*power);
noise_value=noise_get(wind_uv);
xx+=(noise_value*2.0-1.0)*0.05;


wind_uv=wind_pos*0.16+vec2(time*0.8*power,time*0.8*power);
noise_value=noise_get(wind_uv);
float zz=(noise_value*2.0-1.0)*0.4*noise_value;


wind_uv=wind_pos*0.5+vec2(time*0.6*power,time*1.0*power);
noise_value=noise_get(wind_uv);
zz+=(noise_value*2.0-1.0)*0.07;


float wind_micro_pos=(offset.x+offset.z+position.x+position.z)*4.4+time*3.0;
xx+=sin(wind_micro_pos)*0.012;
zz+=cos(wind_micro_pos)*0.027;


float xz_rnd=offset.x+offset.z+position.x+position.z;
xx+=((sin(xz_rnd/1.0))*2.0-1.0)*0.1;
zz+=((cos(xz_rnd/1.7))*2.0-1.0)*0.17;


vec3 ddd=normalize(vec3(xx,1.0/uv.y,zz))*uv.y;
vPosition.x+=ddd.x;
vPosition.z+=ddd.z;
vPosition.y+=-uv.y+ddd.y;


/*
vPosition=position;

wind_uv=wind_pos*0.3+vec2(time*0.7*power,time*0.3*power);
noise_value=noise_get(wind_uv);
xx=(noise_value*2.0-1.0)*0.6;


wind_uv=wind_pos*0.16+vec2(time*0.8*power,time*0.8*power);
noise_value=noise_get(wind_uv);
float yy=(noise_value*2.0-1.0)*0.4;


//float dist=distance(offset,offset+position);
//vec3 dir=normalize((offset+vPosition+vec3(xx,0.0,0.0))-(offset+position));
//vPosition+=dir*dist;

//float dist=distance(vec3(0.0,0.0,0.0),position);
//vec3 dir=normalize(position+vec3(xx,0.0,yy));
//vPosition=dir*dist;
*/
}


//if(distance_2d<95.0){ vPosition*=scale; }
//else{ vPosition*=scale*((100.0-distance_2d)/5.0); }

vPosition*=scale;
dec=1.0;
if(distance_2d>145.0){ dec=(150.0-distance_2d)/5.0; }


vPosition+=offset;


noise_uv_y=vec2((position.x+offset.x)*0.002,(position.z+offset.z)*0.002*-1.0)+0.5;
shadowUv=vec2(vPosition.x*0.002,vPosition.z*0.002*-1.0)+0.5;


vUv=uv;
//vColor=normalize(color);
//vColor=normalize(vec3(1.0)+(vec3(1.0+sin(vPosition.x)/1.0,1.0+sin(vPosition.y)/1.0,1.0+sin(vPosition.z)/1.0))/4.0);
vColor=texture2D(noiseMap,noise_uv_y).rgb;
//vColor=vec3(noise_value);
vLight=dot(normal,normalize(sun_direction));
if(vLight<0.2){ vLight=0.2; }


m=0.4;
if(distance_2d>2.0){
m=0.4-(distance_2d-2.0)/20.0;
if(m<0.1){ m=0.1; }
}


m=0.9;
if(distance_2d>2.0){
m=0.9-(distance_2d-2.0)/20.0;
if(m<0.2){ m=0.2; }
}





vec4 mvPosition=modelViewMatrix*vec4(vPosition,1.0);


gl_Position=projectionMatrix*mvPosition;


vViewPosition=-mvPosition.xyz;
vPosition=(modelMatrix*vec4(vPosition,1.0)).xyz;


}


`;


fs["grass"]=`


uniform sampler2D map;
uniform sampler2D noiseMap;
uniform sampler2D shadowMap;
varying vec3 vViewPosition;
varying vec3 vPosition;
varying vec2 vUv;
varying vec3 vColor;
varying float vLight;
varying vec2 shadowUv;
varying vec2 noise_uv_y;
varying float fogFactor;
varying float m;
varying float dec;


const vec3 lightPosition=vec3(60.0,100.0,60.0);
const vec3 ambientColor=vec3(0.2,0.0,0.0);
const vec3 diffuseColor=vec3(0.5,0.0,0.0);
const vec3 specularColor=vec3(1.0,0.87,0.65);


void main(){



vec4 diffuse=texture2D(map,vUv);

diffuse.a*=1.5;

if(diffuse.a<m){ discard; }

diffuse.rgb*=vColor;

diffuse.rgb*=2.0;
diffuse.rgb=(diffuse.rgb-0.5)/(1.0-0.05)+0.5;


diffuse.rgb*=(vUv.y+0.6)*1.0;

if(diffuse.a>1.0){ diffuse.a=1.0; }

if(dec<1.0){
if(length(diffuse.rgb*0.5)>dec){
discard;
}
}


vec3 fdx=vec3(dFdx(vViewPosition.x),dFdx(vViewPosition.y),dFdx(vViewPosition.z));
vec3 fdy=vec3(dFdy(vViewPosition.x),dFdy(vViewPosition.y),dFdy(vViewPosition.z));
vec3 normal=normalize(cross(fdx,fdy));
normal=vec3(0.0,1.0,0.0);

vec3 viewDir=normalize(cameraPosition-vPosition);

vec3 halfDir=normalize(viewDir+normalize(lightPosition));
float specular=pow(dot(halfDir,normal),5.0)*0.1;
diffuse.rgb+=specular*specularColor;




gl_FragColor=diffuse;



diffuse.a*=m;






	vec3 lightDir=normalize(lightPosition - vPosition);

	float lambertian=abs(max(dot(lightDir,normal), 0.0));
	specular=0.0;

	if(lambertian > 0.0) {
vec3 viewDir=normalize(-vPosition);
vec3 halfDir=normalize(lightDir + viewDir);
float specAngle=max(dot(halfDir, normal), 0.0);
specular=pow(specAngle, 20.0);
	}



gl_FragColor.rgb=clamp(gl_FragColor.rgb,0.0,1.0);


}


`;


vs["grass_depth"]=`


attribute float scale;
attribute vec3 offset;
attribute vec4 orientation;
varying vec2 vUv;
uniform vec2 xz;
uniform float time;
vec3 localUpVector=vec3(0.0,1.0,0.0);
varying float dec;
varying vec2 vHighPrecisionZW;


void main(){


float distance_2d=distance(xz,offset.xz);
if(distance_2d>150.0){ gl_Position=vec4(0,0,-1,0); return; }

vec3 vPosition=position;
vPosition.xz/=1.0;
vPosition.y/=2.0;
vPosition*=2.0;
vPosition.y-=0.2;


vec3 vcV=cross(orientation.xyz,vPosition);
vPosition=vcV*(2.0*orientation.w)+cross(orientation.xyz,vcV)*2.0+vPosition;


vec3 vLook=offset-cameraPosition;
vec3 vRight=normalize(cross(vLook,localUpVector));
//vec3 vPosition=position.x*vRight+position.y*localUpVector+position.z;



vPosition*=scale;
dec=1.0;
if(distance_2d>145.0){ dec=(150.0-distance_2d)/5.0; }


vPosition+=offset;



vPosition.y+=0.5;


vUv=uv;


vec4 mvPosition=modelViewMatrix*vec4(vPosition,1.0);
gl_Position=projectionMatrix*mvPosition;
vHighPrecisionZW=gl_Position.zw;


}


`;


fs["grass_depth"]=`


uniform sampler2D map;
varying float dec;
varying vec2 vUv;
varying vec2 vHighPrecisionZW;
#include <packing>


void main(){


if(texture2D(map,vUv).a<0.4/dec){ discard; } 
float fragCoordZ=0.5*vHighPrecisionZW[0]/vHighPrecisionZW[1]+0.5;
gl_FragColor=packDepthToRGBA(fragCoordZ);


}


`;
vs["i_tree_basic"]=`


attribute float scale;
attribute vec3 offset;
attribute vec4 orientation;
varying vec2 vUv;
uniform vec3 sun_direction;
varying float light;
void main(){
//if(distance(cameraPosition.xz,offset.xz)>50.0){ gl_Position=vec4(2.0,2.0,2.0,1.0); return; }
vec3 vPosition=position*scale;
vec3 vcV=cross(orientation.xyz,vPosition);
vPosition=vcV*(2.0*orientation.w)+(cross(orientation.xyz,vcV)*2.0+vPosition);
//gl_Position=projectionMatrix*modelViewMatrix*vec4(offset-pos+vPosition,1.0);
gl_Position=projectionMatrix*modelViewMatrix*vec4(offset+vPosition,1.0);
vUv=uv;
********light=dot(normal,vec3(0.45,0.76,0.45));
//light=dot(normal,normalize(sun_direction-offset))*1.5;
light=dot(normal,normalize(sun_direction-vPosition-offset))*1.5;
//if(light<0.5){ light=0.5; }
}


`;


fs["i_tree_basic"]=`


uniform sampler2D map;
varying vec2 vUv;
varying float light;
void main(){
gl_FragColor=vec4(texture2D(map,vUv).rgb*light,1.0);
}


`;
vs["i_tree_sprite"]=`


attribute float scale;
attribute vec3 offset;
varying vec2 vUv;
uniform vec3 pos;
uniform vec3 sun_direction;
varying float light;
vec3 localUpVector=vec3(0.0,1.0,0.0);


void main(){
//if(distance(cameraPosition.xz,offset.xz)>50.0){ gl_Position=vec4(2.0,2.0,2.0,1.0); return; }
vec3 vLook=offset-cameraPosition;
vec3 vRight=normalize(cross(vLook,localUpVector));
vec3 vPosition=position.x*vRight+position.y*localUpVector+position.z;
gl_Position=projectionMatrix*modelViewMatrix*vec4(offset-pos+vPosition*scale,1.0);
vUv=uv;
light=dot(normalize(sun_direction-offset),normalize(cameraPosition-offset))*2.0;
//light=dot(normalize(sun_direction-offset),normalize(cameraPosition-vPosition-offset))*2.5;
if(light<0.9){ light=0.9; }
}


`;


fs["i_tree_sprite"]=`


uniform sampler2D map;
varying vec2 vUv;
varying float light;
void main() {
gl_FragColor=texture2D(map,vUv);
if(gl_FragColor.a<0.5){ discard; }
gl_FragColor.rgb*=light;
}


`;
vs["terrain_single"]=`


attribute vec2 uv2;


varying vec2 map_uv_y;
varying vec2 noise_uv_y;
varying vec2 shadowGroundUv;
varying vec2 vUv2;
varying vec3 light_c;
varying float fogFactor;
varying vec3 vPosition;
varying float shadowGroundDist;
uniform vec2 shadowGroundOffset;


void main(){


vPosition=position;


noise_uv_y=vec2(position.x*0.002,position.z*0.002*-1.0)+0.5;
shadowGroundUv=(vec2(position.x,position.z)+modelMatrix[3].xz)*0.002+shadowGroundOffset;


map_uv_y=position.xz;


vUv2=uv2;


float light_i=dot(normal,vec3(0.45,0.76,0.45));
if(light_i<0.2){ light_i=0.2; }
light_i*=2.0;


light_c=light_i*vec3(1.0,0.99,0.99);


shadowGroundDist=clamp(145.0-distance(cameraPosition.xz,vPosition.xz),0.0,1.0);


vec4 mvPosition=modelViewMatrix*vec4(vPosition,1.0);


fogFactor=smoothstep(50.0,800.0,length(mvPosition));


gl_Position=projectionMatrix*mvPosition;


}


`;


fs["terrain_single"]=`


uniform sampler2D map;
uniform sampler2D dirt;
uniform sampler2D noise;
uniform sampler2D aoMap;
uniform sampler2D shadowGroundMap;


uniform vec3 fogColor;
varying float fogFactor;


varying vec2 map_uv_y;
varying vec2 noise_uv_y;
varying vec2 shadowGroundUv;
varying vec2 vUv2;
varying vec3 light_c;
varying vec3 vPosition;
varying float shadowGroundDist;


void main(){


vec3 finalColor=texture2D(map,map_uv_y*0.2).rgb;


vec3 noiseTex=texture2D(noise,noise_uv_y).rgb;


vec3 dirtTex=texture2D(dirt,map_uv_y*0.2).rgb;


finalColor*=noiseTex;



finalColor*=texture2D(aoMap,noise_uv_y).rgb;


finalColor*=light_c; 


vec3 shadowGroundTex=finalColor*texture2D(shadowGroundMap,shadowGroundUv).r;


finalColor=mix(finalColor,shadowGroundTex,clamp(145.0-distance(cameraPosition.xz,vPosition.xz),0.0,1.0));


finalColor=pow(finalColor,vec3(1.4));
finalColor=mix(finalColor,fogColor,fogFactor);


gl_FragColor=vec4(finalColor,1.0);


}


`;
vs["terrain_triplanar"]=`


attribute vec2 uv2;


varying vec2 noise_uv_y;
varying vec2 shadowGroundUv;
varying vec3 light_c;
varying float fogFactor;
varying vec3 vNormal;
varying vec3 vPosition;


void main(){


vPosition=position;


noise_uv_y=vec2(position.x*0.002,position.z*0.002*-1.0)+0.5;
shadowGroundUv=vec2(position.x,position.z*-1.0);


vNormal=normal;


float light_i=dot(normal,vec3(0.45,0.76,0.45));
if(light_i<0.2){ light_i=0.2; }
light_i*=2.4;


light_c=light_i*vec3(1.0,0.94,0.79);


vec4 mvPosition=modelViewMatrix*vec4(vPosition,1.0);



fogFactor=smoothstep(50.0,800.0,length(mvPosition));


gl_Position=projectionMatrix*mvPosition;


}


`;


fs["terrain_triplanar"]=`


uniform sampler2D map;
uniform sampler2D dirt;
uniform sampler2D noise;
uniform sampler2D aoMap;
uniform sampler2D shadowGroundMap;
uniform vec2 shadowGroundOffset;


uniform vec3 fogColor;
varying float fogFactor;


varying vec2 noise_uv_y;
varying vec2 shadowGroundUv;
varying vec3 light_c;
varying vec3 vNormal;
varying vec3 vPosition;


vec3 triplanar(vec3 normal,float smooth_1,float smooth_2){
vec3 blend_weights=normal*normal;
float max_blend=max(blend_weights.x,max(blend_weights.y,blend_weights.z));
blend_weights=max(blend_weights-max_blend*smooth_1,0.0);// МЯГКИЙ ПЕРЕХОД
blend_weights.y*=smooth_2;
float rcp_blend=1.0/(blend_weights.x+blend_weights.y+blend_weights.z);
return blend_weights*rcp_blend;
}


void main(){


float grid=1.0;
float width=3.0;
vec3 pos=d_position.xyz*grid;
vec3 fw=fwidth(pos);
vec3 bc=clamp(width-abs(1.0-2.0*fract(pos))/fw,0.0,1.0);
vec3 f1=smoothstep(1.0/grid,2.0/grid,fw);
vec3 f2=smoothstep(2.0/grid,4.0/grid,fw);
//gl_FragColor.rgb=mix(mix(bc,vec3(0.5),f1),vec3(0.0),f2);


vec2 map_uv_x=vPosition.zy*0.4;
vec2 map_uv_y=vPosition.xz*0.4;
vec2 map_uv_z=vPosition.xy*0.4;


vec3 weights=triplanar(vNormal,0.25,1.0);


vec3 color=weights.x*texture2D(dirt,map_uv_x).rgb+weights.y*texture2D(map,map_uv_y).rgb+weights.z*texture2D(dirt,map_uv_z).rgb;


vec3 finalColor=color*texture2D(aoMap,noise_uv_y).rgb*texture2D(noise,noise_uv_y).rgb*light_c;
vec3 shadowGroundTex=finalColor*texture2D(shadowGroundMap,shadowGroundUv*0.002+vec2(0.0,1.0)+shadowGroundOffset).r;
float shadowGroundDist=clamp(98.0-distance(cameraPosition.xz,vPosition.xz),0.0,1.0);
//finalColor=mix(finalColor,shadowGroundTex,shadowGroundDist);
finalColor=shadowGroundTex;


finalColor=pow(finalColor,vec3(1.4));
finalColor=mix(finalColor,fogColor,fogFactor);


gl_FragColor=vec4(finalColor,1.0);


}


`;
/*
CREATION DATE: 080323-010525
IMPORTANT:
1. When 2 normals with the same texture and scale flow, they merge into one texture. Either change the scale, or move diagonally, or different textures.
2. A bad normal texture may be upside down, have stripes around the edges, or not be seamless.
*/


let water_stats=true; // DISPLAY STATISTICS IN CONSOLE
let water_debug=false; // SHOW WATER GRID AND WATER LINE
let water=[];
let water_refaction_enabled=false;


// ____________________ WATER SETTINGS ____________________


function waters_set(){


// ADDING A FUNCTION TO DELETE THE OBJECT WE WILL USE IN from_mesh
mesh["lake"].delete=function(){ delete mesh["lake"]; };


water["lake"]={
from_mesh:mesh["lake"], // TURN OBJECT INTO WATER, ELSE null
width:0, // WIDTH
depth:0, // LENGTH	
deep:12, // DEPTH
position:{x:0,y:0,z:0}, // POSITION
// [LOD CELL SIZE CAN ALSO BE 0 - THEN THERE WILL BE A PLANE OF 2 TRIANGLES, DISTANCE TO THE CENTER OF LOD]
// FOR THE FIRST LOD, THE DISTANCE TO THE CENTER MAY NOT BE SPECIFIED
// ALLOWED CELL SIZES: 0.125,0.25,0.5,1,2,4,8,16,32,64
// EXAMPLE: cells_size:[[0.25,20]], NO LOD
// EXAMPLE: cells_size:[[0.25,20],[0.25,100],[0,200]], 3 LOD
// IF WE NEED FLAT WATER, THEN WE SET: cells_size:[[0,0]], AND use_waves:false
cells_size:[[0,0]],
// GERSTNER WAVES
gerstner_waves:[new THREE.Vector4(-1.0,-1.0,0.05,60.0),new THREE.Vector4(-1.0,-0.6,0.05,31.0),new THREE.Vector4(-1.0,-1.3,0.05,18.0)],
gerstner_waves_speed:{value:0.001}, // WAVE SPEED
water_top_color:{value:new THREE.Color(0.0,0.96,0.48).convertSRGBToLinear()}, // WATER TOP COLOR		
water_bottom_color:{value:new THREE.Color(0.0,0.7,0.7).convertSRGBToLinear()}, // WATER BOTTOM COLOR		
shore_transparent:{value:0.4}, // SHORE TRANSPARENCY 0-1
wave_color:{value:new THREE.Color(0.0,0.6,0.6).convertSRGBToLinear()}, // WAVE COLOR
wave_color_power:{value:1.5}, // WAVE COLOR FRINEL
sss_color:{value:new THREE.Color(0.0,1.0,1.0)}, // SUBSURFACE LIGHT SCATTERING COLOR
sss_value:{value:[0.66,5.0,10.0,0.01]}, // SUBSURFACE LIGHT SCATTERING [DISTORTION,FRESNEL,INTENSITY,REDUCE SUN HEIGHT TO MAINTAIN EFFECT]
shore_smoothing_intensity:{value:10.0}, // SHORE SMOOTHING
refraction_value:{value:[0.05,10.0]}, // REFRACTION [INTENSITY,REFRACTION REDUCTION NEAR THE SHORE]
// NORMAL
normal_a_value:{value:[0.2,0,0.00015]}, // SHALLOW NORMAL A [SCALE,VELOCITY X,VELOCITY Z]
normal_b_value:{value:[0.1,0,-0.00010]}, // SHALLOW NORMAL B [SCALE,X-SPEED,Z-SPEED]
normal_ab:{value:1.0}, // FLIP THE Y NORMAL BY -1. AS WELL AS DECREASE IN INTENSITY
normal_c_value:{value:[0.02,0,0.00010]}, // BIG NORMAL C [SCALE,X-SPEED,Z-SPEED]
normal_d_value:{value:[0.01,0,-0.00005]}, // BIG NORMAL D [SCALE,X-SPEED,Z-SPEED]
normal_cd:{value:1.0}, // FLIP THE Y NORMAL BY -1. AND ALSO DECREASE INTENSITY
normal_small_far_total:{value:[0.5,0.1]}, // HOW MUCH TO MIX THE SMALL NORMAL WITH THE BIG NORMAL, AND HOW MUCH TO MIX THEM WITH THE WAVE APEX
// REFLECTION
env_mix:{value:1.0}, // HOW STRENGTHLY TO MIX THE BASE NORMAL WITH THE TEXTURE NORMAL
env_melt:{value:1.0}, // IF THE NORMAL TEXTURE IS SHARP, THEN THE BLUE FROM THE SKY IS VISIBLE, TO REDUCE IT, WE INCREASE THIS VALUE
env_fresnel_min:{value:0.01}, // MINIMUM FRESNEL
env_fresnel_power:{value:5.0}, // FRESNEL POWER
env_intensity:{value:1.0}, // SKY REFLECTION BRIGHTNESS
env_max:{value:1.0}, // MAXIMUM REFLECTION LEVEL
env_add_background:{value:0.0}, // HOW MUCH TO ADD WATER COLOR TO AFFECT REFLECTION
envMap:{value:scene_envMap_backed.textures[0]}, // REFLECTION TEXTURE
foam_shore_map:{value:tex["water_foam"]}, // TEXTURE OF FOAM SHORE
foam_wave_map:{value:tex["water_foam"]}, // WAVE FOAM TEXTURE
normal_map:{value:tex["water_normal"]}, // NORMAL TEXTURE OR null
holes_map:{value:null}, // BLACK AND WHITE TEXTURE FOR HOLES IN WATER, IF NOT NEEDED, THEN null
holes_pars:{value:[0.001,0.001,0.5,0.5]}, // [SCALE X, SCALE Z, OFFSET UV X, OFFSET UV Z]
depth_offset:{value:0.0}, // DEPTH OFFSET
depth_beers_law:{value:-0.1}, // TOP OF DEPTH
depth_distance:{value:2.5}, // DEPTH TRANSPARENCY
foam_waves_value:{value:[0.1,3.0,1.4]}, // FOAM ON WAVES [TEXTURE SCALE,STRENGTH,BRIGHTNESS]
foam_shore_value:{value:[1.0,0.4,0,0.00002]}, // FOAM AT THE SHORE [WIDTH,TEXTURE SCALE,X-SPEED,Z-SPEED]
specular:{value:[10,100,720]}, // SUN GLARE [INTENSITY,STRENGTH WHEN SUN IS HIGH,STRENGTH WHEN SUN IS ON THE HORIZON]
phong_simple_intensity:{value:0.5}, // SIMPLE PHONG INTENSITY
scattering_intensity:{value:0.5}, // LIGHT SCATTERING INTENSITY. IF YOU SET IT TO MUCH IT MAY LOOK LIKE PLASTIC
// CAUSTIC
caustics_map:{value:tex["water_caustic"]}, // CAUSTIC TEXTURE OR null
caustics_1_dir_speed:{value:[0,0.0001]}, // [X,Z] DIRECTION AND SPEED OF THE FIRST CAUSTICS
caustics_2_dir_speed:{value:[0,0.0002]}, // [X,Z] DIRECTION AND SPEED OF THE SECOND CAUSTICS
caustics_wave:{value:[1,0.1,0.001]}, // CAUSTIC WAVE [FREQUENCY, MAGNITUDE, SPEED AND DIRECTION]
caustics_intensity:{value:2}, // INTENSITY
caustics_scale_power:{value:[0.2,1]}, // SCALE, POWER OF MANIFESTATION
caustics_color:{value:new THREE.Color(1.0,1.0,0.4)}, // COLOR
// UNDER WATER
underwater_gradient_offset:1, // HOW MUCH TO RETRIEVE THE GRADIENT FROM THE TOP OF THE WATER
underwater_gradient_deep:3, // GRADIENT DEPTH
underwater_top_color_deep:4, // TOP COLOR DEPTH
underwater_top_color:new THREE.Color(0.0,0.9,0.2), // TOP COLOR
underwater_bottom_color:new THREE.Color(0.0,0.45,0.45), // BOTTOM COLOR
underwater_sun_flare_color:new THREE.Color(1.0,1.0,0.2), // SUN FLARE COLOR
underwater_sun_flare_intensity:0.5, // SUN FLARE INTENSITY
underwater_darkness_deep:20, // DEPTH OF DARKNESS
underwater_depth_distance:30, // DEPTH TRANSPARENCY
gamma:{value:1.0}, // GAMMA
saturation:{value:1.0}, // SATURATION
normal_far_smoothing:{value:[250,200]}, // FAR NORMAL SMOOTHING [DISTANCE FROM,EXTENSION]
sky_far_mix_value:{value:[450,500]}, // MIXING SKY WITH WATER IN THE DISTANCE [DISTANCE FROM,DISTANCE TO]
// SHOULD I USE THESE FUNCTIONS?
use_transparent_style:true, // FALSE - NORMAL WATER, TRUE - FULLY TRANSPARENT
refraction:1, // 0 - DO NOT USE REFRACTION, 1 - USE BUT FLAT FROM 2 TRIANGLES, 2 - FROM ALL TRIANGLES OF WAVES
use_waves:false, // GERSTNER WAVES
use_sss:false, // SUBSURFACE LIGHT SCATTERING
use_shore_smoothing:true, // SHORE SMOOTHING
use_caustics:true, // CAUSTICS
use_fog:true, // FOG
use_wave_color:true, // WAVE COLOR
use_foam_waves:true, // FOAM ON WAVES
use_foam_shore:true, // FOAM AT THE SHORE AND OBJECTS
use_gamma:false, // GAMMA
use_saturation:false, // SATURATION
use_back:true, // BACK SIDE
use_shadows:true, // SHADOWS
use_sky_far_mix:true, // MIXING THE SKY WITH THE WATER IN THE DISTANCE
use_specular:true, // SUN GLARE
use_phong_simple:true, // SIMPLE PHONG INTENSITY
use_scattering:true, // LIGHT SCATTERING INTENSITY
use_shore_transparent:true, // SHORE TRANSPARENCY
use_underwater_sun_flare:true, // UNDERWATER SUN FLARE
}


water["sea"]={
from_mesh:null, // TURN OBJECT INTO WATER, ELSE null
width:80, // WIDTH
depth:90, // LENGTH	
deep:10, // DEPTH
position:{x:180,y:-3,z:145}, // POSITION
// [LOD CELL SIZE CAN ALSO BE 0 - THEN THERE WILL BE A PLANE OF 2 TRIANGLES, DISTANCE TO THE CENTER OF LOD]
// FOR THE FIRST LOD, THE DISTANCE TO THE CENTER MAY NOT BE SPECIFIED
// ALLOWED CELL SIZES: 0.125,0.25,0.5,1,2,4,8,16,32,64
// EXAMPLE: cells_size:[[0.25,20]], NO LOD
// EXAMPLE: cells_size:[[0.25,20],[0.25,100],[0,200]], 3 LOD
// IF WE NEED FLAT WATER, THEN WE SET: cells_size:[[0,0]], AND use_waves:false
cells_size:[[1.0,0],[2.0,100],[4.0,150],[8.0,200]],
// GERSTNER WAVES
gerstner_waves:[new THREE.Vector4(-1.0,-1.0,0.05,60.0),new THREE.Vector4(-1.0,-0.6,0.05,31.0),new THREE.Vector4(-1.0,-1.3,0.05,18.0)],
gerstner_waves_speed:{value:0.001}, // WAVE SPEED
water_top_color:{value:new THREE.Color(0.05,0.12,0.2)}, // WATER TOP COLOR			
water_bottom_color:{value:new THREE.Color(0.05,0.12,0.2)}, // WATER BOTTOM COLOR	
shore_transparent:{value:0.4}, // SHORE TRANSPARENCY 0-1
wave_color:{value:new THREE.Color(0.0,0.6,0.6).convertSRGBToLinear()}, // WAVE COLOR
wave_color_power:{value:1.5}, // WAVE COLOR FRINEL
sss_color:{value:new THREE.Color(0.0,1.0,1.0)}, // SUBSURFACE LIGHT SCATTERING COLOR
sss_value:{value:[0.66,5.0,10.0,0.01]}, // SUBSURFACE LIGHT SCATTERING [DISTORTION,FRESNEL,INTENSITY,REDUCE SUN HEIGHT TO MAINTAIN EFFECT]
shore_smoothing_intensity:{value:10.0}, // SHORE SMOOTHING
refraction_value:{value:[0.05,10.0]}, // REFRACTION [INTENSITY,REFRACTION DECREASE NEAR THE SHORE]
// NORMAL
normal_a_value:{value:[0.2,0,0.00015]}, // SHALLOW NORMAL A [SCALE,VELOCITY X,VELOCITY Z]
normal_b_value:{value:[0.1,0,-0.00010]}, // SHALLOW NORMAL B [SCALE,VELOCITY X,VELOCITY Z]
normal_ab:{value:1.0}, // FLIP THE Y NORMAL BY -1. AS WELL AS DECREASE IN INTENSITY
normal_c_value:{value:[0.02,0,0.00010]}, // BIG NORMAL C [SCALE,X-SPEED,Z-SPEED]
normal_d_value:{value:[0.01,0,-0.00005]}, // BIG NORMAL D [SCALE,X-SPEED,Z-SPEED]
normal_cd:{value:1.0}, // FLIP THE Y NORMAL BY -1. AND ALSO DECREASE INTENSITY
normal_small_far_total:{value:[0.5,0.1]}, // HOW MUCH TO MIX THE SMALL NORMAL WITH THE BIG NORMAL, AND HOW MUCH TO MIX THEM WITH THE WAVE APEX
// REFLECTION
env_mix:{value:1.0}, // HOW STRENGTHLY TO MIX THE BASE NORMAL WITH THE TEXTURE NORMAL
env_melt:{value:1.0}, // IF THE NORMAL TEXTURE IS SHARP, THEN THE BLUE FROM THE SKY IS VISIBLE, TO REDUCE IT, WE INCREASE THIS VALUE
env_fresnel_min:{value:0.01}, // MINIMUM FRESNEL
env_fresnel_power:{value:0.0}, // FRESNEL POWER
env_intensity:{value:1.0}, // SKY REFLECTION BRIGHTNESS
env_max:{value:1.0}, // MAXIMUM REFLECTION LEVEL
env_add_background:{value:0.0}, // HOW MUCH TO ADD WATER COLOR TO AFFECT REFLECTION
envMap:{value:scene_envMap_backed.textures[0]}, // REFLECTION TEXTURE
foam_shore_map:{value:tex["water_foam"]}, // TEXTURE OF FOAM SHORE
foam_wave_map:{value:tex["water_foam"]}, // WAVE FOAM TEXTURE
normal_map:{value:tex["water_normal"]}, // NORMAL TEXTURE OR null
holes_map:{value:null}, // BLACK AND WHITE TEXTURE FOR HOLES IN WATER, IF NOT NEEDED, THEN null
holes_pars:{value:[0.001,0.001,0.5,0.5]}, // [SCALE X, SCALE Z, OFFSET UV X, OFFSET UV Z]
depth_offset:{value:0.0}, // DEPTH OFFSET
depth_beers_law:{value:-0.1}, // TOP OF DEPTH
depth_distance:{value:2.5}, // DEPTH TRANSPARENCY
foam_waves_value:{value:[0.1,3.0,1.4]}, // FOAM ON WAVES [TEXTURE SCALE,STRENGTH,BRIGHTNESS]
foam_shore_value:{value:[1.0,0.4,0,0.00002]}, // FOAM AT THE SHORE [WIDTH,TEXTURE SCALE,X-SPEED,Z-SPEED]
specular:{value:[10,100,720]}, // SUN GLARE [INTENSITY,STRENGTH WHEN SUN IS HIGH,STRENGTH WHEN SUN IS ON THE HORIZON]
phong_simple_intensity:{value:0.5}, // SIMPLE PHONG INTENSITY
scattering_intensity:{value:0.5}, // LIGHT SCATTERING INTENSITY. IF YOU SET IT TO MUCH IT MAY LOOK LIKE PLASTIC
// CAUSTIC
caustics_map:{value:tex["water_caustic"]}, // CAUSTIC TEXTURE OR null
caustics_1_dir_speed:{value:[0,0.0001]}, // [X,Z] DIRECTION AND SPEED OF THE FIRST CAUSTICS
caustics_2_dir_speed:{value:[0,0.0002]}, // [X,Z] DIRECTION AND SPEED OF THE SECOND CAUSTICS
caustics_wave:{value:[1,0.1,0.001]}, // CAUSTIC WAVE [FREQUENCY, MAGNITUDE, SPEED AND DIRECTION]
caustics_intensity:{value:2}, // INTENSITY
caustics_scale_power:{value:[0.2,1]}, // SCALE, POWER OF MANIFESTATION
caustics_color:{value:new THREE.Color(1.0,1.0,0.4)}, // COLOR
// UNDER WATER
underwater_gradient_offset:1, // HOW MUCH TO RETRIEVE THE GRADIENT FROM THE TOP OF THE WATER
underwater_gradient_deep:3, // GRADIENT DEPTH
underwater_top_color_deep:4, // TOP COLOR DEPTH
underwater_top_color:new THREE.Color(0.0,0.9,0.2), // TOP COLOR
underwater_bottom_color:new THREE.Color(0.05,0.12,0.2), // BOTTOM COLOR
underwater_sun_flare_color:new THREE.Color(1.0,1.0,0.2), // SUN FLARE COLOR
underwater_sun_flare_intensity:0.5, // SUN FLARE INTENSITY
underwater_darkness_deep:20, // DEPTH OF DARKNESS
underwater_depth_distance:30, // DEPTH TRANSPARENCY
gamma:{value:1.0}, // GAMMA
saturation:{value:1.0}, // SATURATION
normal_far_smoothing:{value:[250,200]}, // FAR NORMAL SMOOTHING [DISTANCE FROM,EXTENSION]
sky_far_mix_value:{value:[450,500]}, // MIXING SKY WITH WATER IN THE DISTANCE [DISTANCE FROM,DISTANCE TO]
// SHOULD I USE THESE FUNCTIONS?
use_transparent_style:false, // FALSE - NORMAL WATER, TRUE - COMPLETELY TRANSPARENT
refraction:2, // 0 - DO NOT USE REFRACTION, 1 - USE BUT FLAT FROM 2 TRIANGLES, 2 - FROM ALL TRIANGLES WAVES
use_waves:true, // GERSTNER WAVES
use_sss:false, // SUBSURFACE LIGHT SCATTERING
use_shore_smoothing:true, // SHORE SMOOTHING
use_caustics:false, // CAUSTICS
use_fog:true, // FOG
use_wave_color:false, // WAVE COLOR
use_foam_waves:true, // FOAM ON WAVES
use_foam_shore:true, // FOAM AT THE SHORE AND OBJECTS
use_gamma:false, // GAMMA
use_saturation:false, // SATURATION
use_back:true, // BACK SIDE
use_shadows:true, // SHADOWS
use_sky_far_mix:true, // MIXING THE SKY WITH THE WATER IN THE DISTANCE
use_specular:true, // SUN GLARE
use_phong_simple:true, // SIMPLE PHONG INTENSITY
use_scattering:true, // LIGHT SCATTERING INTENSITY
use_shore_transparent:true, // SHORE TRANSPARENCY
use_underwater_sun_flare:true, // UNDERWATER SUN FLARE
}


water["river"]={
from_mesh:null, // TURN OBJECT INTO WATER, ELSE null
width:40, // WIDTH
depth:70, // LENGTH	
deep:10, // DEPTH
position:{x:120,y:-2,z:125}, // POSITION
// [LOD CELL SIZE CAN ALSO BE 0 - THEN THERE WILL BE A PLANE OF 2 TRIANGLES, DISTANCE TO THE CENTER OF LOD]
// FOR THE FIRST LOD, THE DISTANCE TO THE CENTER MAY NOT BE SPECIFIED
// ALLOWED CELL SIZES: 0.125,0.25,0.5,1,2,4,8,16,32,64
// EXAMPLE: cells_size:[[0.25,20]], NO LOD
// EXAMPLE: cells_size:[[0.25,20],[0.25,100],[0,200]], 3 LOD
// IF WE NEED FLAT WATER, THEN WE SET: cells_size:[[0,0]], AND use_waves:false
cells_size:[[0,0]],
// GERSTNER WAVES
gerstner_waves:[new THREE.Vector4(-1.0,-1.0,0.05,60.0),new THREE.Vector4(-1.0,-0.6,0.05,31.0),new THREE.Vector4(-1.0,-1.3,0.05,18.0)],
gerstner_waves_speed:{value:0.001}, // WAVE SPEED
water_top_color:{value:new THREE.Color(0.0,0.96,0.48).convertSRGBToLinear()}, // WATER TOP COLOR				
water_bottom_color:{value:new THREE.Color(0.0,0.7,0.7).convertSRGBToLinear()}, // WATER BOTTOM COLOR	
shore_transparent:{value:0.4}, // SHORE TRANSPARENCY 0-1
wave_color:{value:new THREE.Color(0.0,0.6,0.6).convertSRGBToLinear()}, // WAVE COLOR
wave_color_power:{value:1.5}, // WAVE COLOR FRINEL
sss_color:{value:new THREE.Color(0.0,1.0,1.0)}, // SUBSURFACE LIGHT SCATTERING COLOR
sss_value:{value:[0.66,5.0,10.0,0.01]}, // SUBSURFACE LIGHT SCATTERING [DISTORTION,FRESNEL,INTENSITY,REDUCE SUN HEIGHT TO MAINTAIN EFFECT]
shore_smoothing_intensity:{value:10.0}, // SHORE SMOOTHING
refraction_value:{value:[0.05,10.0]}, // REFRACTION [INTENSITY,REFRACTION REDUCTION NEAR THE SHORE]
// NORMAL
normal_a_value:{value:[0.2,0,0.00015]}, // SHALLOW NORMAL A [SCALE,VELOCITY X,VELOCITY Z]
normal_b_value:{value:[0.1,0,-0.00010]}, // SHALLOW NORMAL B [SCALE,X-SPEED,Z-SPEED]
normal_ab:{value:1.0}, // FLIP THE Y NORMAL BY -1. AS WELL AS DECREASE IN INTENSITY
normal_c_value:{value:[0.02,0,0.00010]}, // BIG NORMAL C [SCALE,X-SPEED,Z-SPEED]
normal_d_value:{value:[0.01,0,-0.00005]}, // BIG NORMAL D [SCALE,X-SPEED,Z-SPEED]
normal_cd:{value:1.0}, // FLIP THE Y NORMAL BY -1. AND ALSO DECREASE INTENSITY
normal_small_far_total:{value:[0.5,0.1]}, // HOW MUCH TO MIX THE SMALL NORMAL WITH THE BIG NORMAL, AND HOW MUCH TO MIX THEM WITH THE WAVE APEX
// REFLECTION
env_mix:{value:1.0}, // HOW STRENGTHLY TO MIX THE BASE NORMAL WITH THE TEXTURE NORMAL
env_melt:{value:1.0}, // IF THE NORMAL TEXTURE IS SHARP, THEN THE BLUE FROM THE SKY IS VISIBLE, TO REDUCE IT, WE INCREASE THIS VALUE
env_fresnel_min:{value:0.01}, // MINIMUM FRESNEL
env_fresnel_power:{value:5.0}, // FRESNEL POWER
env_intensity:{value:1.0}, // SKY REFLECTION BRIGHTNESS
env_max:{value:1.0}, // MAXIMUM REFLECTION LEVEL
env_add_background:{value:0.0}, // HOW MUCH TO ADD WATER COLOR TO AFFECT REFLECTION
envMap:{value:scene_envMap_backed.textures[0]}, // REFLECTION TEXTURE
foam_shore_map:{value:tex["water_foam"]}, // TEXTURE OF FOAM SHORE
foam_wave_map:{value:tex["water_foam"]}, // WAVE FOAM TEXTURE
normal_map:{value:tex["water_normal"]}, // NORMAL TEXTURE OR null
holes_map:{value:null}, // BLACK AND WHITE TEXTURE FOR HOLES IN WATER, IF NOT NEEDED, THEN null
holes_pars:{value:[0.001,0.001,0.5,0.5]}, // [SCALE X, SCALE Z, OFFSET UV X, OFFSET UV Z]
depth_offset:{value:0.0}, // DEPTH OFFSET
depth_beers_law:{value:-0.1}, // TOP OF DEPTH
depth_distance:{value:2.5}, // DEPTH TRANSPARENCY
foam_waves_value:{value:[0.1,3.0,1.4]}, // FOAM ON WAVES [TEXTURE SCALE,STRENGTH,BRIGHTNESS]
foam_shore_value:{value:[1.0,0.4,0,0.00002]}, // FOAM AT THE SHORE [WIDTH,TEXTURE SCALE,X-SPEED,Z-SPEED]
specular:{value:[10,100,720]}, // SUN GLARE [INTENSITY,STRENGTH WHEN SUN IS HIGH,STRENGTH WHEN SUN IS ON THE HORIZON]
phong_simple_intensity:{value:0.5}, // SIMPLE PHONG INTENSITY
scattering_intensity:{value:0.5}, // LIGHT SCATTERING INTENSITY. IF YOU SET IT TO MUCH IT MAY LOOK LIKE PLASTIC
// CAUSTIC
caustics_map:{value:tex["water_caustic"]}, // CAUSTIC TEXTURE OR null
caustics_1_dir_speed:{value:[0,0.0001]}, // [X,Z] DIRECTION AND SPEED OF THE FIRST CAUSTICS
caustics_2_dir_speed:{value:[0,0.0002]}, // [X,Z] DIRECTION AND SPEED OF THE SECOND CAUSTICS
caustics_wave:{value:[1,0.1,0.001]}, // CAUSTIC WAVE [FREQUENCY, MAGNITUDE, SPEED AND DIRECTION]
caustics_intensity:{value:2}, // INTENSITY
caustics_scale_power:{value:[0.2,1]}, // SCALE, POWER OF MANIFESTATION
caustics_color:{value:new THREE.Color(1.0,1.0,0.4)}, // COLOR
// UNDER WATER
underwater_gradient_offset:1, // HOW MUCH TO RETRIEVE THE GRADIENT FROM THE TOP OF THE WATER
underwater_gradient_deep:5, // GRADIENT DEPTH
underwater_top_color_deep:4, // TOP COLOR DEPTH
underwater_top_color:new THREE.Color(0.0,0.9,0.2), // TOP COLOR
underwater_bottom_color:new THREE.Color(0.0,0.45,0.45), // BOTTOM COLOR
underwater_sun_flare_color:new THREE.Color(1.0,1.0,0.2), // SUN FLARE COLOR
underwater_sun_flare_intensity:0.5, // SUN FLARE INTENSITY
underwater_darkness_deep:20, // DEPTH OF DARKNESS
underwater_depth_distance:30, // DEPTH TRANSPARENCY
gamma:{value:1.0}, // GAMMA
saturation:{value:1.0}, // SATURATION
normal_far_smoothing:{value:[250,200]}, // FAR NORMAL SMOOTHING [DISTANCE FROM,EXTENSION]
sky_far_mix_value:{value:[450,500]}, // MIXING SKY WITH WATER IN THE DISTANCE [DISTANCE FROM,DISTANCE TO]
// SHOULD I USE THESE FUNCTIONS?
use_transparent_style:false, // FALSE - NORMAL WATER, TRUE - COMPLETELY TRANSPARENT
refraction:1, // 0 - DO NOT USE REFRACTION, 1 - USE BUT FLAT FROM 2 TRIANGLES, 2 - FROM ALL TRIANGLES OF WAVES
use_waves:false, // GERSTNER WAVES
use_sss:false, // SUBSURFACE LIGHT SCATTERING
use_shore_smoothing:true, // SHORE SMOOTHING
use_caustics:true, // CAUSTICS
use_fog:true, // FOG
use_wave_color:true, // WAVE COLOR
use_foam_waves:true, // FOAM ON WAVES
use_foam_shore:true, // FOAM AT THE SHORE AND OBJECTS
use_gamma:false, // GAMMA
use_saturation:false, // SATURATION
use_back:true, // BACK SIDE
use_shadows:true, // SHADOWS
use_sky_far_mix:true, // MIXING THE SKY WITH THE WATER IN THE DISTANCE
use_specular:true, // SUN GLARE
use_phong_simple:true, // SIMPLE PHONG INTENSITY
use_scattering:true, // LIGHT SCATTERING INTENSITY
use_shore_transparent:true, // SHORE TRANSPARENCY
use_underwater_sun_flare:true, // UNDERWATER SUN FLARE
}


water["ocean"]={ // DO NOT CHANGE ocean NAME
hide:mesh["hide_ocean_waterline"], // GEOMETRY WHERE THE OCEAN WATERLINE SHOULD NOT BE SO IT DOESN'T APPEAR ON THE LAKE. OR null
position:{y:-1}, // POSITION BY HEIGHT
deep:500, // DEPTH
cells_size:2.0, // CELL SIZE OF THE FIRST LOD IN METERS. ALLOWED SIZES: 0.125,0.25,0.5,1,2,4,8,16,32,64
//IF YOU NEED A FLAT OCEAN OF 2 TRIANGLES, THEN SET cells_size:500, cells_amount:1, lod:[], use_waves:false
//PICK AN EVEN NUMBER OF CELLS AT WHICH THE OCEAN TRIANGLES WILL NOT OVERLOAD EACH OTHER, FOR EXAMPLE, cells_amount IS NOT 50, BUT 40
cells_amount:100, // EVEN NUMBER OF CELLS IN THE FIRST LOD
lod:[80,10], // NUMBER OF LOD CELLS. MAXIMUM 2 LOD
last_lod_stretch:50, // HOW MANY METERS TO STRETCH THE CELLS OF THE LAST LOD TO COVER THE VIEW RANGE AND SAVE TRIANGLES
// GERSTNER WAVES
//gerstner_waves:gerstner_waves_gen(12,1.1,0,1232.399963,0.02,5).concat(gerstner_waves_gen(3,1.3,0,1232.399963,0.05,60)),
gerstner_waves:[new THREE.Vector4(-1.0,-1.0,0.05,60.0),new THREE.Vector4(-1.0,-0.6,0.05,31.0),new THREE.Vector4(-1.0,-1.3,0.05,18.0)],
gerstner_waves_speed:{value:0.001}, // WAVE SPEED
ocean_move:16, // STEP OF FOLLOWING THE OCEAN CAMERA SO THAT THE JERKING IS NOTICEABLE
water_top_color:{value:new THREE.Color(0.0,0.96,0.48).convertSRGBToLinear()}, // WATER TOP COLOR	
water_bottom_color:{value:new THREE.Color(0.0,0.4,0.2).convertSRGBToLinear()}, // WATER BOTTOM COLOR		
shore_transparent:{value:0.4}, // SHORE TRANSPARENCY 0-1
wave_color:{value:new THREE.Color(0.0,0.6,0.0).convertSRGBToLinear()}, // WAVE COLOR
wave_color_power:{value:1.5}, // WAVE COLOR FRINEL
sss_color:{value:new THREE.Color(0.0,0.5,0.0)}, // SUBSURFACE LIGHT SCATTERING COLOR
sss_value:{value:[0.66,5.0,10.0,0.01]}, // SUBSURFACE LIGHT SCATTERING [DISTORTION,FRESNEL,INTENSITY,REDUCE SUN HEIGHT TO MAINTAIN EFFECT]
shore_smoothing_intensity:{value:10.0}, // SHORE SMOOTHING
refraction_value:{value:[0.05,10.0]}, // REFRACTION [INTENSITY,REFRACTION REDUCTION NEAR THE SHORE]
// NORMAL
normal_a_value:{value:[0.2,0,0.00015]}, // SHALLOW NORMAL A [SCALE,VELOCITY X,VELOCITY Z]
normal_b_value:{value:[0.1,0,-0.00010]}, // SHALLOW NORMAL B [SCALE,X-SPEED,Z-SPEED]
normal_ab:{value:1.0}, // FLIP THE Y NORMAL BY -1. AS WELL AS DECREASE IN INTENSITY
normal_c_value:{value:[0.02,0,0.00010]}, // BIG NORMAL C [SCALE,X-SPEED,Z-SPEED]
normal_d_value:{value:[0.01,0,-0.00005]}, // BIG NORMAL D [SCALE,X-SPEED,Z-SPEED]
normal_cd:{value:1.0}, // FLIP THE Y NORMAL BY -1. AND ALSO DECREASE INTENSITY
normal_small_far_total:{value:[0.5,0.1]}, // HOW MUCH TO MIX THE SMALL NORMAL WITH THE BIG NORMAL, AND HOW MUCH TO MIX THEM WITH THE WAVE APEX
// REFLECTION
env_mix:{value:1.0}, // HOW STRENGTHLY TO MIX THE BASE NORMAL WITH THE TEXTURE NORMAL
env_melt:{value:1.0}, // IF THE NORMAL TEXTURE IS SHARP, THEN THE BLUE FROM THE SKY IS VISIBLE, TO REDUCE IT, WE INCREASE THIS VALUE
env_fresnel_min:{value:0.01}, // MINIMUM FRESNEL
env_fresnel_power:{value:5.0}, // FRESNEL POWER
env_intensity:{value:1.0}, // SKY REFLECTION BRIGHTNESS
env_max:{value:1.0}, // MAXIMUM REFLECTION LEVEL
env_add_background:{value:0.0}, // HOW MUCH TO ADD WATER COLOR TO AFFECT REFLECTION
envMap:{value:scene_envMap_backed.textures[0]}, // REFLECTION TEXTURE
foam_shore_map:{value:tex["water_foam"]}, // TEXTURE OF FOAM SHORE
foam_wave_map:{value:tex["water_foam"]}, // WAVE FOAM TEXTURE
normal_map:{value:tex["water_normal"]}, // NORMAL TEXTURE OR null
holes_map:{value:tex["ocean_holes"]}, // BLACK AND WHITE TEXTURE FOR HOLES IN WATER, IF NOT NEEDED, THEN null
holes_pars:{value:[0.001,0.001,0.5,0.5]}, // [SCALE X, SCALE Z, OFFSET UV X, OFFSET UV Z]
depth_offset:{value:0.0}, // DEPTH OFFSET
depth_beers_law:{value:-0.1}, // TOP OF DEPTH
depth_distance:{value:2.5}, // DEPTH TRANSPARENCY
foam_waves_value:{value:[0.1,3.0,1.4]}, // FOAM ON WAVES [TEXTURE SCALE,STRENGTH,BRIGHTNESS]
foam_shore_value:{value:[1.0,0.4,0,0.00002]}, // FOAM AT THE SHORE [WIDTH,TEXTURE SCALE,X-SPEED,Z-SPEED]
specular:{value:[10,100,720]}, // SUN GLARE [INTENSITY,STRENGTH WHEN SUN IS HIGH,STRENGTH WHEN SUN IS ON THE HORIZON]
phong_simple_intensity:{value:0.5}, // SIMPLE PHONG INTENSITY
scattering_intensity:{value:0.5}, // LIGHT SCATTERING INTENSITY. IF YOU SET IT TO MUCH IT MAY LOOK LIKE PLASTIC
// CAUSTIC
caustics_map:{value:tex["water_caustic"]}, // CAUSTIC TEXTURE OR null
caustics_1_dir_speed:{value:[0,0.0001]}, // [X,Z] DIRECTION AND SPEED OF THE FIRST CAUSTICS
caustics_2_dir_speed:{value:[0,0.0002]}, // [X,Z] DIRECTION AND SPEED OF THE SECOND CAUSTICS
caustics_wave:{value:[1,0.1,0.001]}, // CAUSTIC WAVE [FREQUENCY, MAGNITUDE, SPEED AND DIRECTION]
caustics_intensity:{value:2}, // INTENSITY
caustics_scale_power:{value:[0.2,1]}, // SCALE, POWER OF MANIFESTATION
caustics_color:{value:new THREE.Color(1.0,1.0,0.4)}, // COLOR
// UNDER WATER
underwater_gradient_offset:1, // HOW MUCH TO RETRIEVE THE GRADIENT FROM THE TOP OF THE WATER
underwater_gradient_deep:5, // GRADIENT DEPTH
underwater_top_color_deep:4, // TOP COLOR DEPTH
underwater_top_color:new THREE.Color(0.0,0.9,0.2), // TOP COLOR
underwater_bottom_color:new THREE.Color(0.0,0.13,0.03), // BOTTOM COLOR
underwater_sun_flare_color:new THREE.Color(1.0,1.0,0.2), // SUN FLARE COLOR
underwater_sun_flare_intensity:0.5, // SUN FLARE INTENSITY
underwater_darkness_deep:20, // DEPTH OF DARKNESS
underwater_depth_distance:70, // DEPTH TRANSPARENCY
gamma:{value:1.0}, // GAMMA
saturation:{value:1.0}, // SATURATION
normal_far_smoothing:{value:[250,200]}, // FAR NORMAL SMOOTHING [DISTANCE FROM,EXTENSION]
sky_far_mix_value:{value:[450,500]}, // MIXING SKY WITH WATER IN THE DISTANCE [DISTANCE FROM,DISTANCE TO]
// SHOULD I USE THESE FUNCTIONS?
use_transparent_style:false, // FALSE - NORMAL WATER, TRUE - COMPLETELY TRANSPARENT
refraction:2, // 0 - DO NOT USE REFRACTION, 1 - USE BUT FLAT FROM 2 TRIANGLES, 2 - FROM ALL TRIANGLES WAVES
use_waves:true, // GERSTNER WAVES
use_sss:true, // SUBSURFACE LIGHT SCATTERING
use_shore_smoothing:true, // SHORE SMOOTHING
use_caustics:true, // CAUSTICS
use_fog:false, // FOG
use_wave_color:true, // WAVE COLOR
use_foam_waves:true, // FOAM ON WAVES
use_foam_shore:true, // FOAM AT THE SHORE AND OBJECTS
use_gamma:false, // GAMMA
use_saturation:false, // SATURATION
use_back:true, // BACK SIDE
use_shadows:true, // SHADOWS
use_sky_far_mix:true, // MIXING THE SKY WITH THE WATER IN THE DISTANCE
use_specular:true, // SUN GLARE
use_phong_simple:true, // SIMPLE PHONG INTENSITY
use_scattering:true, // LIGHT SCATTERING INTENSITY
use_shore_transparent:true, // SHORE TRANSPARENCY
use_underwater_sun_flare:true, // UNDERWATER SUN FLARE
}


// ____________________ CREATION OF MATERIALS ____________________


for(let i in water){


let water_item=water[i];


let material=mat[i]=new THREE.ShaderMaterial({
uniforms:{
position_from_depth_projection:{value:new THREE.Matrix4()},
shadowMap:{value:null},
screen_resolution:{value:null},
screen_texel_size:{value:null},
sun_direction:{value:[0,0,0]},
scene_map:{value:null},
scene_depth_map:{value:null},
water_depth_map:{value:null},
fogDensity:{value:0},
fogColor:{value:[0,0,0]},
fogNear:{value:0},
fogFar:{value:0},
time:{value:0},
},
defines:{
screen_normal_quality:2 // QUALITY OF NORMAL FROM DEPTH TEXTURE: 1 - LOW, 2 - MEDIUM, 3 - HIGH
},
vertexShader:vs["water"],
fragmentShader:fs["water"],
wireframe:water_debug,
side:2
});


if(water_item.use_fog){
if(scene.fog){
if(scene.fog.isFog){
material.fog=true;
material.defines.fog=true;
}
if(scene.fog.isFogExp2){
material.fog=true;
material.defines.fog_exp2=true;
}
}
}


if(water_item.refraction!=0){ material.defines.refraction_use=true; }
if(water_item.refraction==1){ material.defines.refraction_flat=true; }
if(!water_item.use_waves && water_item.refraction==2){ water_item.refraction=1; }
if(water_item.refraction!=0){ water_refaction_enabled=true; }
	

material.defines.use_wave_color=water_item.use_wave_color;
material.defines.use_foam_waves=water_item.use_foam_waves;
material.defines.use_foam_shore=water_item.use_foam_shore;
material.defines.use_gamma=water_item.use_gamma;
material.defines.use_saturation=water_item.use_saturation;
material.defines.use_sss=water_item.use_sss;
material.defines.use_caustics=water_item.use_caustics;
material.defines.use_transparent_style=water_item.use_transparent_style;
material.defines.use_back=water_item.use_back;
material.defines.use_sky_far_mix=water_item.use_sky_far_mix;
material.defines.use_shore_smoothing=water_item.use_shore_smoothing;
material.defines.use_specular=water_item.use_specular;
material.defines.use_phong_simple=water_item.use_phong_simple;
material.defines.use_scattering=water_item.use_scattering;
material.defines.use_shore_transparent=water_item.use_shore_transparent;


if(water_item.use_transparent_style){
water_item.underwater_gradient_deep=500;
water_item.underwater_darkness_deep=500;
water_item.underwater_depth_distance=500;
}


if(water_item.holes_map.value){ material.defines.holes=true; }


let u=material.uniforms;


let gerstner_waves_amount=water_item.gerstner_waves.length;


// NORMALIZING THE DIRECTION OF GERSTNER WAVES
for(let n=0;n<gerstner_waves_amount;n++){
let item=water_item.gerstner_waves[n];
let length=1/Math.sqrt(item.x*item.x+item.y*item.y);
item.x*=length;
item.y*=length;
}


// CREATING GERSTNER WAVES FOR CALCULATIONS


water_item.waves=[];


let waves_amplitude=0;
let waves_dx=0;
let waves_dz=0;
let waves_d_max=0;


if(water_item.use_waves){
for(let n=0;n<gerstner_waves_amount;n++){
let item=water_item.gerstner_waves[n];
let k=6.283185307179586/item.w;
let c=Math.sqrt(9.8/k);
let a=item.z/k; // AMPLITUDE, MAXIMUM HEIGHT
let dx=Math.abs(a*item.x); // MAXIMUM X OFFSET
let dz=Math.abs(a*item.y); // MAXIMUM Z-OFFSET
let d_max=Math.max(dx,dz); // MAXIMUM SQUARE OFFSET FOR CALCULATION OF WATERLINE GEOMETRY DIMENSIONS
waves_amplitude+=a;
waves_dx+=dx;
waves_dz+=dz;
waves_d_max+=d_max;
water_item.waves.push({x:item.x,y:item.y,k:k,c:c,a:a,dx:dx,dz:dz,d_max:d_max});
}
}


water_item.waves_amplitude=waves_amplitude;
water_item.waves_dx=waves_dx;
water_item.waves_dz=waves_dz;
water_item.waves_d_max=waves_d_max;


// FOLLOWING THE WATER LINE WITH THE CAMERA STEP
if(i!=="ocean"){ water_item.waterline_move=water_item.cells_size[0][0]; }
else{ water_item.waterline_move=water_item.cells_size; }
if(!water_item.use_waves){ water_item.waterline_move=0.1; }


u.gerstner_waves={value:water_item.gerstner_waves};	
material.defines.waves_amount=gerstner_waves_amount;
material.defines.use_waves=water_item.use_waves;


u.gerstner_waves_speed=water_item.gerstner_waves_speed;
u.water_top_color=water_item.water_top_color;		
u.water_bottom_color=water_item.water_bottom_color;
u.wave_color=water_item.wave_color;
u.wave_color_power=water_item.wave_color_power;
u.sss_color=water_item.sss_color;
u.sss_value=water_item.sss_value;
u.shore_smoothing_intensity=water_item.shore_smoothing_intensity;
u.env_mix=water_item.env_mix;
u.env_melt=water_item.env_melt;
u.env_fresnel_min=water_item.env_fresnel_min;
u.env_fresnel_power=water_item.env_fresnel_power;
u.env_intensity=water_item.env_intensity;
u.env_max=water_item.env_max;
u.env_add_background=water_item.env_add_background;
u.envMap=water_item.envMap;
u.foam_shore_map=water_item.foam_shore_map;
u.foam_wave_map=water_item.foam_wave_map;
u.normal_map=water_item.normal_map;
u.caustics_map=water_item.caustics_map;
u.caustics_1_dir_speed=water_item.caustics_1_dir_speed;
u.caustics_2_dir_speed=water_item.caustics_2_dir_speed;
u.caustics_wave=water_item.caustics_wave;
u.caustics_intensity=water_item.caustics_intensity;
u.caustics_scale_power=water_item.caustics_scale_power;
u.caustics_color=water_item.caustics_color;
u.depth_offset=water_item.depth_offset;
u.depth_beers_law=water_item.depth_beers_law;
u.depth_distance=water_item.depth_distance;
u.holes_map=water_item.holes_map;
u.holes_pars=water_item.holes_pars;
if(water_item.use_gamma){ u.gamma=water_item.gamma; }
if(water_item.use_saturation){ u.saturation=water_item.saturation; }
u.foam_waves_value=water_item.foam_waves_value;
u.foam_shore_value=water_item.foam_shore_value;
u.specular=water_item.specular;
u.phong_simple_intensity=water_item.phong_simple_intensity;
u.scattering_intensity=water_item.scattering_intensity;
u.shore_transparent=water_item.shore_transparent;
u.refraction_value=water_item.refraction_value;
u.normal_a_value=water_item.normal_a_value;
u.normal_b_value=water_item.normal_b_value;
u.normal_ab=water_item.normal_ab;
u.normal_c_value=water_item.normal_c_value;
u.normal_d_value=water_item.normal_d_value;
u.normal_cd=water_item.normal_cd;
u.normal_small_far_total=water_item.normal_small_far_total;
u.sun_color={value:[0,0,0]};
u.normal_far_smoothing=water_item.normal_far_smoothing;
u.sky_far_mix_value=water_item.sky_far_mix_value;
u.sun_direction.value=sun_direction;
u.sun_color.value=sun.color;
u.scene_map.value=water_rtt_scene.texture;
u.scene_depth_map.value=water_rtt_scene.depthTexture;
u.water_depth_map.value=water_rtt_refraction.depthTexture;


// TO GET SHADOWS
if(water_item.use_shadows){
material.lights=true;
material.defines.use_shadows=true;
}
	
	
// ADDING SHADOW PARAMETERS. TAKEN FROM THE PLACE WHERE THE CODE IS: if ( materialProperties.needsLights ) {
if(material.lights){
u.ambientLightColor={value:null};
u.lightProbe={value:null};
u.directionalLights={value:null};
u.directionalLightShadows={value:null};
u.spotLights={value:null};
u.spotLightShadows={value:null};
u.rectAreaLights={value:null};
u.ltc_1={value:null};
u.ltc_2={value:null};
u.pointLights={value:null};
u.pointLightShadows={value:null};
u.hemisphereLights={value:null};
u.directionalShadowMap={value:null};
u.directionalShadowMatrix={value:null};
u.spotShadowMap={value:null};
u.spotLightMatrix={value:null};
u.spotLightMap={value:null};
u.pointShadowMap={value:null};
u.pointShadowMatrix={value:null};
}


if(i=="ocean"){
u.move={value:[0,0,0]};
material.defines.ocean=true;
}


}


}


// GERSTNER WAVE GENERATOR. EXAMPLE: gerstner_waves_gen(12,1.1,0,1232.399963,0.02,5);


function gerstner_waves_gen(amount,multiply_frequency,iteration,add_iteration,steepness,frequency){


let waves=[];
for(let n=0;n<amount;n++){
waves.push(new THREE.Vector4(-Math.sin(iteration),-Math.cos(iteration),steepness,frequency));
frequency*=multiply_frequency;
iteration+=add_iteration;	
}
return waves;


}

// ____________________ WATER LINE TEXTURE ____________________


let waterline_rtt=new THREE.WebGLRenderTarget(screen_width,screen_height);
// IT IS IMPORTANT TO SET HIGH TEXTURE QUALITY FOR THE WATER LINE
waterline_rtt.depthBuffer=true;
waterline_rtt.texture.type=THREE.FloatType;
waterline_rtt.texture.minFilter=THREE.NearestFilter;
waterline_rtt.texture.magFilter=THREE.NearestFilter;


// ____________________ TEXTURE OF THE UNDERWATER SCENE ____________________


let water_rtt_scene=new THREE.WebGLRenderTarget(screen_width,screen_height);
water_rtt_scene.depthTexture=new THREE.DepthTexture();
water_rtt_scene.depthTexture.type=THREE.FloatType;
water_rtt_scene.texture.wrapS=water_rtt_scene.texture.wrapT=THREE.MirroredRepeatWrapping;
// WE SET FILTERS TO AVOID SMALL ARTIFACTS WHEN USING REFRACTION
// FOR EXAMPLE, AN OBJECT ABOVE THE WATER WILL HAVE ITS OWN PIXELS VISIBLE AROUND IT
water_rtt_scene.texture.minFilter=THREE.NearestFilter;
water_rtt_scene.texture.magFilter=THREE.NearestFilter;


// ____________________ REFRACTION TEXTURE ____________________


let water_rtt_refraction=new THREE.WebGLRenderTarget(screen_width,screen_height);
water_rtt_refraction.depthTexture=new THREE.DepthTexture();
water_rtt_refraction.depthTexture.type=THREE.FloatType;
water_rtt_refraction.texture.wrapS=water_rtt_refraction.texture.wrapT=THREE.MirroredRepeatWrapping;
water_rtt_refraction.texture.minFilter=THREE.NearestFilter;
water_rtt_refraction.texture.magFilter=THREE.NearestFilter;


let ray_hide_ocean_waterline=new THREE.Raycaster();
ray_hide_ocean_waterline.ray.direction.set(0,-1,0);
ray_hide_ocean_waterline.ray.origin.y=10000;


// GEOMETRY WHERE THERE SHOULD NOT BE AN OCEAN WATER LINE SO IT DOESN'T APPEAR ON THE LAKE
mesh["hide_ocean_waterline"]=new THREE.Mesh(new THREE.BoxGeometry(500,1,400),new THREE.MeshBasicMaterial());
mesh["hide_ocean_waterline"].position.set(0,0,0);


let underwater_pass_uniforms=underwater_pass.material.uniforms;


let water_eyes_status=1;
let water_eyes_intensity=0;
let water_eyes_height=0;


function water_set(){


underwater_ripples_pass.material.uniforms.normal_map.value=tex["underwater_ripples"];
underwater_ripples_pass.material.uniforms.eyes_normal_map.value=tex["underwater_eyes"];
underwater_pass_uniforms.waterline_rtt.value=waterline_rtt.texture;
underwater_ripples_pass.material.uniforms.waterline_rtt.value=waterline_rtt.texture;
underwater_pass_uniforms.sun_direction.value=sun_direction;
underwater_pass_uniforms.position_from_depth_projection.value=new THREE.Matrix4();


waters_set();


mesh["water_refraction"]=new THREE.Group();
mesh["water_refraction"].matrixWorldAutoUpdate=false;


for(let i in water){

	
let item=water[i];

	
if(i!="ocean"){
if(item.from_mesh!=null){ water_from_mesh(item); }
else{
item.left=Number((item.position.x-item.width/2).toFixed(2));
item.right=Number((item.position.x+item.width/2).toFixed(2));
item.top=Number((item.position.z+item.depth/2).toFixed(2));
item.bottom=Number((item.position.z-item.depth/2).toFixed(2));
}
water_lake_create(item,item.cells_size[0][0],i,null);
let max_lod=item.cells_size.length;
if(max_lod>1){
for(let n=1;n<max_lod;n++){
water_lake_create(item,item.cells_size[n][0],i,i+"_"+n);	
}
}
}


if(i=="ocean"){ water_ocean_create(); }
waterline_create(i);
// WATER HEIGHT TAKING INTO ACCOUNT WAVES
let wave=item.waves_amplitude;
// ADD 0.2 TO THE HEIGHT BECAUSE IF YOU PLACE IT CLOSE IN HEIGHT, THEN IN THIS PLACE WHEN THE CAMERA IS TILTED THE WATER LINE IS NOT VISIBLE
let amplitude=Number((item.waves_amplitude+0.2).toFixed(2));
item.height_top=Number((item.position.y+amplitude).toFixed(2));
mat[i].uniforms.wave_max_height={value:amplitude};
// WATER DEPTH
item.height_bottom=item.position.y-item.deep;


if(item.refraction==0 && water_stats){
console.log(i+" REFRACTION TRIANGLES: 0");
}


if(item.refraction==1){


let refraction_width=500;
let refraction_depth=500;
if(i!="ocean"){
refraction_width=item.width;
refraction_depth=item.depth;
}
 

let vertices=[];
let indices=[];
let w_half=refraction_width/2;
let h_half=refraction_depth/2;


vertices.push(-w_half,0,h_half,w_half,0,h_half,-w_half,0,-h_half,w_half,0,-h_half);
indices.push(0,1,2,2,1,3);


mat[i+"_refraction"]=new THREE.ShaderMaterial({
uniforms:{
move:{value:[0,0,0]},	
holes_map:item.holes_map,
holes_pars:item.holes_pars
},
vertexShader:vs["water_refraction"],
fragmentShader:fs["water_refraction"],
});


if(item.holes_map.value){ mat[i+"_refraction"].defines.holes=true; }
if(i=="ocean"){ mat[i+"_refraction"].defines.ocean=true; }


let geometry=new THREE.BufferGeometry();
geometry.setIndex(indices);
geometry.setAttribute("position",new THREE.Float32BufferAttribute(vertices,3));
geometry.boundingSphere=new THREE.Sphere();
geometry.boundingSphere.center.set(0,0,0);
geometry.boundingSphere.radius=Math.sqrt(refraction_width*refraction_width+refraction_depth*refraction_depth)/2;


let object=mesh[i+"_refraction"]=new THREE.Mesh(geometry,mat[i+"_refraction"]);
if(i!="ocean"){
object.position.x=item.position.x;	
object.position.z=item.position.z;	
}
object.position.y=item.position.y;
if(item.use_waves){ object.position.y-=item.waves_amplitude; }
object.updateMatrixWorld();
object.matrixWorldAutoUpdate=false;
mesh["water_refraction"].add(object);


if(i=="ocean"){ mesh["ocean_refraction"].frustumCulled=false; }


if(water_stats){
console.log(i+" REFRACTION TRIANGLES: 2");
}


}


if(item.refraction==2){

	
mat[i+"_refraction"]=new THREE.ShaderMaterial({
uniforms:{
time:{value:0},
move:{value:[0,0,0]},
gerstner_waves:{value:item.gerstner_waves},	
gerstner_waves_speed:item.gerstner_waves_speed,	
holes_map:item.holes_map,
holes_pars:item.holes_pars
},
defines:{
use_waves:item.use_waves,
waves_amount:item.gerstner_waves.length
},
vertexShader:vs["water_refraction"],
fragmentShader:fs["water_refraction"],
wireframe:water_debug,
});


if(item.holes_map.value){ mat[i+"_refraction"].defines.holes=true; }
if(i=="ocean"){ mat[i+"_refraction"].defines.ocean=true; }


let geometry=mesh[i].geometry.clone();


let object=mesh[i+"_refraction"]=new THREE.Mesh(geometry,mat[i+"_refraction"]);
if(i!="ocean"){
object.position.x=item.position.x;	
object.position.z=item.position.z;	
}
object.position.y=item.position.y;
object.updateMatrixWorld();
object.matrixWorldAutoUpdate=false;
mesh["water_refraction"].add(object);
	

if(i=="ocean"){ mesh["ocean_refraction"].frustumCulled=false; }


if(water_stats){
console.log(i+" REFRACTION TRIANGLES: "+geometry.index.count/3);
}

	
}


}


}


function gerstner_wave_get_position(name){
	
	
if(!water[name].use_waves){ return; }

	
let item=water[name].waves;
let max=item.length;


for(let n=0;n<max;n++){


let mytime=item[n].c*time*water[name].gerstner_waves_speed.value;


let f=item[n].k*(item[n].x*water_mx+item[n].y*water_mz-mytime);
let a=item[n].a;
let a_cos=a*Math.cos(f);
water_nx+=item[n].x*a_cos;
water_ny+=a*Math.sin(f);
water_nz+=item[n].y*a_cos;


}
	
	
}


function water_from_mesh(item){
	

let object=item.from_mesh;


// TAKE DATA FROM AN OLD LAKE TO CREATE A NEW ONE
object.geometry.computeBoundingBox();
let bounding=object.geometry.boundingBox;


item.left=Number(bounding.min.x.toFixed(2));
item.right=Number(bounding.max.x.toFixed(2));
item.top=Number(bounding.max.z.toFixed(2));
item.bottom=Number(bounding.min.z.toFixed(2));
item.width=Math.abs(item.right-item.left);
item.depth=Math.abs(item.top-item.bottom);
item.position.x=item.left+item.width/2;
item.position.y=Number(bounding.min.y.toFixed(2));
item.position.z=Number(item.bottom)+item.depth/2;


// DELETE THE OLD LAKE
object.geometry.dispose();
object.material.dispose();
scene.remove(object);
object.delete();
delete item.from_mesh;


}


function water_on_window_resize(){
	
	
for(let i in water){
mat[i].uniforms.screen_resolution.value=screen_resolution;
mat[i].uniforms.screen_texel_size.value=screen_texel_size;
}


if(typeof underwater_pass!="undefined"){
underwater_pass.uniforms.screen_aspect_ratio.value=screen_aspect_ratio;
underwater_pass.uniforms.screen_texel_size.value=screen_texel_size;
}


waterline_rtt.setSize(screen_width,screen_height);
water_rtt_scene.setSize(screen_width,screen_height);
water_rtt_refraction.setSize(screen_width,screen_height);


}


modules_to_resize.push(water_on_window_resize);


let water_nx=0;
let water_ny=0;
let water_nz=0;
let water_mx;
let water_mz;


function water_render(){


water_nx=0;
water_ny=0;
water_nz=0;


let pos_x=30;
let pos_y=water["lake"].position.y;
let pos_z=70+Math.sin(time*0.001)*10;
water_mx=pos_x-water["lake"].position.x;
water_mz=pos_z-water["lake"].position.z;


gerstner_wave_get_position("lake");


mesh["mbox"].position.set(pos_x+water_nx,pos_y+water_ny,pos_z+water_nz);


renderer.setRenderTarget(water_rtt_scene);
renderer.clear();
renderer.autoClear=true;
// DISABLE SHADOW UPDATE, SINCE THEY ARE ALREADY THERE FROM THE FIRST SCENE, ALTHOUGH, IF THE OBJECT IS MOVING, THE SHADOWS MAY NOT MATCH SLIGHTLY
let sun_autoUpdate_status=sun.shadow.autoUpdate;
sun.shadow.autoUpdate=false;
renderer.render(scene_2,camera);
// TURN ON SHADOWS
sun.shadow.autoUpdate=sun_autoUpdate_status;


// ____________________ REFRACTION ____________________


if(water_refaction_enabled){


for(let i in water){
	
	
let item=water[i];
if(item.refraction==0){ continue; }


let cp=camera.position;
if(i=="ocean"){
if(Math.abs(cp.y-item.position.y)>30){ mesh["ocean_refraction"].visible=false; continue; }
mesh["ocean_refraction"].visible=true;
}
else{
if(Math.sqrt((cp.x-item.position.x)**2+(cp.y-item.position.y)**2+(cp.z-item.position.z)**2)>mesh["lake"].geometry.boundingSphere.radius+30){ mesh[i+"_refraction"].visible=false; continue; }
mesh[i+"_refraction"].visible=true;
}


if(i=="ocean"){
// SHIFT THE OCEAN REFRACTION TOWARDS THE CAMERA
let step=item.ocean_move;
let move=[Math.floor(camera.position.x/step)*step,0,Math.floor(camera.position.z/step)*step];
mesh["ocean_refraction"].matrixWorld.elements[12]=move[0];
mesh["ocean_refraction"].matrixWorld.elements[14]=move[2];
mat["ocean_refraction"].uniforms.move.value=move;
}
if(item.refraction==2){
mat[i+"_refraction"].uniforms.time.value=time;
}


}


renderer.setRenderTarget(water_rtt_refraction);
renderer.clear();
renderer.render(mesh["water_refraction"],camera);
renderer.autoClear=false;
renderer.setRenderTarget(null);


}


// ____________________ WATERLINE ____________________


let waterline_mesh=null;
let waterline_name;


// HIDE ALL WATER LINES SO THEY DON'T GET IN THE WAY LATER
for(let i in water){
mesh["waterline_"+i].visible=false;	
}


for(let i in water){


if(i=="ocean"){ continue; }

	
let item=water[i];


// IF THERE IS WATER WITH LOD, THEN FIRST WE HIDE EVERYTHING, AND THEN WE SHOW THE RIGHT ONE


let max_lods=item.cells_size.length;
if(max_lods>1){
mesh[i].visible=false;
let show=i;
let cp=camera.position;	
for(let n=1;n<max_lods;n++){
let show_name=i+"_"+n;
mesh[show_name].visible=false;		
if(Math.sqrt((cp.x-item.position.x)**2+(cp.y-item.position.y)**2+(cp.z-item.position.z)**2)>=item.cells_size[n][1]){ show=show_name; }
}
mesh[show].visible=true;	
}


let pos=camera.position;
let pos_x=pos.x;
let pos_y=pos.y;
let pos_z=pos.z;
if(pos_x>item.left && pos_x<item.right && pos_z<item.top && pos_z>item.bottom && pos_y<item.height_top && pos_y>item.height_bottom){
waterline_mesh=i;
waterline_name="waterline_"+i;
mesh[waterline_name].visible=true;
break;
}
}


if(waterline_mesh==null && water["ocean"] && camera.position.y<water["ocean"].height_top && camera.position.y>water["ocean"].height_bottom){
ray_hide_ocean_waterline.ray.origin.x=camera.position.x;
ray_hide_ocean_waterline.ray.origin.z=camera.position.z;
let go_ocean_waterline=true;
if(water["ocean"].hide!=null){
let hits=ray_hide_ocean_waterline.intersectObject(water["ocean"].hide);
if(hits.length>0){ go_ocean_waterline=false; }
}
if(go_ocean_waterline==true){
waterline_mesh="ocean";
waterline_name="waterline_ocean";
mesh["waterline_ocean"].visible=true;	
}
}


if(waterline_mesh){
	

//MOVE THE WATER LINE TOWARDS THE CAMERA	
let step=water[waterline_mesh].waterline_move;
let move_waterline=[Math.floor(camera.position.x/step)*step,0,Math.floor(camera.position.z/step)*step];
mesh[waterline_name].matrixWorld.elements[12]=move_waterline[0];
mesh[waterline_name].matrixWorld.elements[14]=move_waterline[2];
if(waterline_mesh!="ocean"){
mat[waterline_name].uniforms.move.value=[move_waterline[0]-mesh[waterline_mesh].matrixWorld.elements[12],0.0,move_waterline[2]-mesh[waterline_mesh].matrixWorld.elements[14]];
}
else{
mat[waterline_name].uniforms.move.value=move_waterline;	
}
// UPDATE WATER LINE TIME
mat[waterline_name].uniforms.time.value=time;	


}


//MOVING THE OCEAN TOWARDS THE CAMERA
if(water["ocean"]){
let step=water["ocean"].ocean_move;
let move=[Math.floor(camera.position.x/step)*step,0,Math.floor(camera.position.z/step)*step];
mesh["ocean"].matrixWorld.elements[12]=move[0];
mesh["ocean"].matrixWorld.elements[14]=move[2];
mat["ocean"].uniforms.move.value=move;
}	
	
	
if(waterline_mesh){	


let water_item=water[waterline_mesh];
renderer.setRenderTarget(waterline_rtt);
renderer.clear();
renderer.render(mesh[waterline_name],camera);
renderer.setRenderTarget(null);


water_item.waterline_move;
let v=water_item.underwater_top_color;
let i=underwater_pass_uniforms.top_color.value;
let sun_y_max=Math.max(0.2,sun_direction.y);
i[0]=v.r*sun_y_max;
i[1]=v.g*sun_y_max;
i[2]=v.b*sun_y_max;
v=water_item.underwater_bottom_color;
i=underwater_pass_uniforms.bottom_color.value;
i[0]=v.r*sun_y_max;
i[1]=v.g*sun_y_max;
i[2]=v.b*sun_y_max;
underwater_pass_uniforms.use_transparent_style.value=water_item.use_transparent_style;
underwater_pass_uniforms.gradient_top.value=water_item.height_top+water_item.underwater_gradient_offset;
underwater_pass_uniforms.gradient_bottom.value=water_item.height_top-water_item.underwater_gradient_deep;
underwater_pass_uniforms.top_color_top.value=water_item.height_top+1.0;
underwater_pass_uniforms.top_color_bottom.value=water_item.height_top-water_item.underwater_top_color_deep;
underwater_pass_uniforms.darkness_top.value=water_item.height_top;
underwater_pass_uniforms.darkness_bottom.value=water_item.height_top-water_item.underwater_darkness_deep;
underwater_pass_uniforms.depth_distance.value=water_item.underwater_depth_distance;
underwater_pass_uniforms.use_caustics.value=water_item.use_caustics;
if(water_item.use_caustics){
underwater_pass_uniforms.caustics_map.value=water_item.caustics_map.value;
underwater_pass_uniforms.caustics_top.value=water_item.position.y;
underwater_pass_uniforms.caustics_bottom.value=water_item.position.y-1;
underwater_pass_uniforms.caustics_1_dir_speed.value=water_item.caustics_1_dir_speed.value;
underwater_pass_uniforms.caustics_2_dir_speed.value=water_item.caustics_2_dir_speed.value;
underwater_pass_uniforms.caustics_wave.value=water_item.caustics_wave.value;
underwater_pass_uniforms.caustics_intensity.value=water_item.caustics_intensity.value;
underwater_pass_uniforms.caustics_scale_power.value=water_item.caustics_scale_power.value;
underwater_pass_uniforms.caustics_color.value=water_item.caustics_color.value;
}
underwater_pass_uniforms.gamma.value=water_item.gamma.value;
underwater_pass_uniforms.saturation.value=water_item.saturation.value;
underwater_pass_uniforms.use_shadows.value=water_item.use_shadows;
underwater_pass_uniforms.sun_flare_color.value=water_item.underwater_sun_flare_color;
underwater_pass_uniforms.sun_flare_intensity.value=water_item.underwater_sun_flare_intensity;
underwater_pass_uniforms.use_sun_flare.value=water_item.use_underwater_sun_flare;


underwater_pass_uniforms.time.value=time;
underwater_ripples_pass.material.uniforms.time.value=time;
// WE TAKE THE DEPTH OF THE ENTIRE SCENE, NOT THE WATER
underwater_pass_uniforms.tDepth.value=composer.readBuffer.depthTexture;
underwater_pass_uniforms.cameraPosition.value=camera.position.clone();
underwater_pass_uniforms.position_from_depth_projection.value.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse).invert();


sun_clip_position_update();
underwater_pass_uniforms.sun_3d_position.value=sun_3d_position;


underwater_pass_uniforms.directionalShadowMap.value=[sun.shadow.map.textures[0]];
let dlight={
shadowIntensity:sun.shadow.intensity,
shadowBias:sun.shadow.bias,
shadowNormalBias:sun.shadow.normalBias,
shadowRadius:sun.shadow.radius,
shadowMapSize:sun.shadow.mapSize	
};
underwater_pass_uniforms.directionalLightShadows.value=[dlight];
underwater_pass_uniforms.directionalShadowMatrix.value=[sun.shadow.matrix];


underwater_pass.enabled=true;
underwater_ripples_pass.enabled=true;


}
else{
underwater_pass.enabled=false;	
underwater_ripples_pass.enabled=false;
}


// ____________________ EYE DROPS ____________________


let water_eyes_found=0;


for(let i in water){


if(i=="ocean"){ continue; }

	
let item=water[i];


let pos=camera.position;
let pos_x=pos.x;
let pos_y=pos.y;
let pos_z=pos.z;
if(pos_x>item.left && pos_x<item.right && pos_z<item.top && pos_z>item.bottom && pos_y<item.position.y-item.waves_amplitude && pos_y>item.height_bottom){
water_eyes_height=item.position.y-item.waves_amplitude;
water_eyes_found=1;
break;
}


}


if(!water_eyes_found && water["ocean"] && camera.position.y<water["ocean"].position.y-water["ocean"].waves_amplitude && camera.position.y>water["ocean"].height_bottom){
ray_hide_ocean_waterline.ray.origin.x=camera.position.x;
ray_hide_ocean_waterline.ray.origin.z=camera.position.z;
let go_ocean_waterline=true;
if(water["ocean"].hide!=null){
let hits=ray_hide_ocean_waterline.intersectObject(water["ocean"].hide);
if(hits.length>0){ go_ocean_waterline=false; }
}
if(go_ocean_waterline==true){
water_eyes_height=water["ocean"].position.y-water["ocean"].waves_amplitude;
water_eyes_found=1;
}
}


if(water_eyes_found && camera.position.y<water_eyes_height){
water_eyes_status=2;
water_eyes_intensity=0.2;
underwater_ripples_pass.enabled=true;
underwater_ripples_pass.material.uniforms.time.value=time;
underwater_ripples_pass.material.uniforms.eyes.value=true;
underwater_ripples_pass.material.uniforms.eyes_intensity.value=water_eyes_intensity;
}
if(water_eyes_status==2 && camera.position.y>water_eyes_height){
water_eyes_status=3;	
water_eyes_intensity=0.2;
underwater_ripples_pass.material.uniforms.eyes.value=true;
}
if(water_eyes_status==3){
water_eyes_intensity-=0.003;
underwater_ripples_pass.material.uniforms.eyes_intensity.value=water_eyes_intensity;	
underwater_ripples_pass.material.uniforms.time.value=time;
underwater_ripples_pass.enabled=true;
if(water_eyes_intensity<0){
water_eyes_status=1;
underwater_ripples_pass.material.uniforms.eyes.value=false;
}
}


// UPDATING MATERIALS


for(let i in water){
let item=mat[i].uniforms;
item.time.value=time;
item.position_from_depth_projection.value.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse).invert();
}
	

}


function water_lake_create(item,cells_size,name,name_2){


let start=performance.now();


let width=item.width;
let height=item.depth;
let grid_size=cells_size;


let position_x=item.position.x;
let position_y=item.position.y;
let position_z=item.position.z;


// FOR BASIC GEOMETRY ONLY, ROUND THE POSITION BY THE STEP SO THAT WATERLINE DOESN'T HAVE AN ARTIFACT WHERE A 1-PIXEL STRIP OF UNPAINTED WATER IS VISIBLE
if(!name_2 && grid_size!=0){
position_x=Math.floor(item.position.x/grid_size)*grid_size;
position_z=Math.floor(item.position.z/grid_size)*grid_size;
if(item.position.x!=position_x){
item.left=Number((position_x-width/2).toFixed(2));	
item.right=Number((position_x+width/2).toFixed(2));	
console.log("water "+name+" changed position x to "+position_x);
}
if(item.position.z!=position_z){
item.top=Number((position_z+height/2).toFixed(2));
item.bottom=Number((position_z-height/2).toFixed(2));		
console.log("water "+name+" changed position z to "+position_z);
}
}


// FOR THE REST OF THE LOD WE SET THE POSITION OF THE MAIN GEOMETRY
if(name_2){
position_x=mesh[name].matrixWorld.elements[12];
position_y=mesh[name].matrixWorld.elements[13];
position_z=mesh[name].matrixWorld.elements[14];
}


let width_segments=1;
let height_segments=1;


if(grid_size!=0){
width_segments=width*(1/grid_size);
height_segments=height*(1/grid_size);
}


let width_half=width/2;
let height_half=height/2;
let grid_x=Math.floor(width_segments);
let grid_y=Math.floor(height_segments);
let grid_x1=grid_x+1;
let grid_y1=grid_y+1;
let segment_width=width/grid_x;
let segment_height=height/grid_y;
let indices=[];
let vertices=[];


for(let iy=0;iy<grid_y1;iy++){
let y=iy*segment_height-height_half;
for(let ix=0;ix<grid_x1;ix++){
let x=ix*segment_width-width_half;
vertices.push(x,0,-y);
}
}


for(let iy=0;iy<grid_y;iy++){
for(let ix=0;ix<grid_x;ix++){
let a=ix+grid_x1*iy;
let b=ix+grid_x1*(iy+1);
let c=ix+1+grid_x1*(iy+1);
let d=ix+1+grid_x1*iy;
indices.push(a,d,b);
indices.push(b,d,c);
}
}


let geometry=new THREE.BufferGeometry();
geometry.setIndex(indices);
geometry.setAttribute("position",new THREE.Float32BufferAttribute(vertices,3));
geometry.boundingSphere=new THREE.Sphere();
geometry.boundingSphere.center.set(0,0,0);
geometry.boundingSphere.radius=Math.sqrt(width*width+height*height)/2;


let real_name=name;
if(name_2){ real_name=name_2; }


let object=mesh[real_name]=new THREE.Mesh(geometry,mat[name]);
object.matrixAutoUpdate=false;
object.updateMatrixWorld=function(){};
object.position.set(position_x,position_y,position_z);
object.matrixWorld.elements[12]=position_x;
object.matrixWorld.elements[13]=position_y;
object.matrixWorld.elements[14]=position_z;
scene.add(object);


if(water_stats){
console.log("["+((performance.now()-start)/1000).toFixed(6)+"s] "+real_name+" TRIANGLES: "+geometry.index.count/3);
}


}


function water_ocean_create(){
	
	
let start=performance.now();


let item=water["ocean"];


let cells_size=item.cells_size;
let cells_amount=item.cells_amount;
let lod=item.lod;
let last_lod_stretch=item.last_lod_stretch;
let grid_size=cells_size;


let indices=[];
let vertices=[];
let a,b,c,d,e,iy,ix,x,y;
let lod_max=lod.length;
let previous_indices=0;


let cells_size_half=cells_amount*cells_size/2;
let cells_amount_max=cells_amount+1;


for(iy=0;iy<cells_amount_max;iy++){
y=iy*cells_size-cells_size_half;
for(ix=0;ix<cells_amount_max;ix++){
x=ix*cells_size-cells_size_half;
vertices.push(x,0,-y);
}
}	


for(iy=0;iy<cells_amount;iy++){
for(ix=0;ix<cells_amount;ix++){
a=ix+cells_amount_max*iy;
b=ix+cells_amount_max*(iy+1);
c=ix+1+cells_amount_max*(iy+1);
d=ix+1+cells_amount_max*iy;
indices.push(a,d,b);
indices.push(b,d,c);
}
}


let left_column=[0];
let right_column=[cells_amount];
let new_left_column=[];
let new_right_column=[];


for(let n=0;n<cells_amount;n++){
left_column.push((cells_amount+1)*(n+1));
right_column.push(cells_amount+(cells_amount+1)*(n+1));
}


for(let n=0;n<lod_max;n++){


let lod_value=lod[n];


let go_top=previous_indices;
let go_left=previous_indices;


previous_indices=vertices.length/3;
let plus_indices=previous_indices;


let cells=cells_amount/2+2+lod_value*2;
let cells_max=cells_amount/2+2+lod_value*2+1;
let bound_left=-cells_size_half;
let bound_right=cells_size_half;
let bound_top=cells_size_half;
let bound_bottom=-cells_size_half;
cells_size*=2;
cells_size_half=cells*cells_size/2;


for(iy=0;iy<cells_max;iy++){
y=iy*cells_size-cells_size_half;
let real_y=y;
// STRETCHING FURTHER
if(n==1 && iy<lod[1]){ real_y-=(cells_size+last_lod_stretch)*(lod[1]-iy); }
if(n==1 && iy>cells_max-lod[1]-1){ real_y+=(cells_size+last_lod_stretch)*(iy-(cells_max-lod[1])+1); }
for(ix=0;ix<cells_max;ix++){
x=ix*cells_size-cells_size_half;
let real_x=x;
// STRETCHING FURTHER
if(n==1 && ix<lod[1]){ real_x-=(cells_size+last_lod_stretch)*(lod[1]-ix); }
if(n==1 && ix>cells_max-lod[1]-1){ real_x+=(cells_size+last_lod_stretch)*(ix-(cells_max-lod[1])+1); }
if(x<bound_left || x>bound_right || y>bound_top || y<bound_bottom){ vertices.push(real_x,0,-real_y); }
}
}


let index_top;
let index_left;
let index_right;
let index_add=lod_value*2+2;
let was_left=0;
let simple_ad=0;
let simple_bc=0;


new_left_column.push(plus_indices);
new_right_column.push(plus_indices+cells);


for(iy=0;iy<cells;iy++){
for(ix=0;ix<cells;ix++){
// LEFT TOP
if(iy==lod_value && ix==lod_value){
a=ix+cells_max*iy+plus_indices;
b=ix+cells_max*(iy+1)+plus_indices;
c=go_top;
d=a+1;
indices.push(a,c,b);
indices.push(c,a,d);
index_top=d;
index_left=b;
simple_bc++;
}
// TOP
else if(iy==lod_value && ix>lod_value && ix<cells-lod_value-1){
a=index_top;
b=go_top;
c=go_top+2;
d=a+1;
e=go_top+1;
indices.push(a,e,b);
indices.push(a,d,e);
indices.push(d,c,e);
go_top+=2;
index_top=d;
simple_bc++;
}
// RIGHT TOP
else if(iy==lod_value && ix==cells-lod_value-1){
a=index_top;
b=go_top;
c=ix+1+cells_max*(iy+1)+plus_indices-cells_amount/2-1;
d=a+1;
indices.push(a,d,b);
indices.push(b,d,c);
index_right=c;
}
// LEFT
else if(iy>lod_value && iy<cells-lod_value-1 && ix==lod_value){
a=index_left;
b=a+index_add;
c=left_column[was_left*2+2];
d=left_column[was_left*2];
e=left_column[was_left*2+1];
indices.push(a,d,e);
indices.push(a,e,b);
indices.push(b,e,c);
was_left++;
index_left=b;
simple_ad++;
simple_bc++;
if(iy==cells-lod_value-2){ go_left=c; }
}
// EMPTY
else if(iy>lod_value && iy<lod_value+cells_amount/2+1 && ix>lod_value && ix<cells-lod_value-1){
simple_ad++;
simple_bc++;
}
// RIGHT
else if(iy>lod_value && iy<cells-lod_value-1 && ix==cells-lod_value-1){
a=right_column[(was_left-1)*2];
e=right_column[(was_left-1)*2+1];
b=right_column[(was_left-1)*2+2];
c=index_right+index_add;
d=index_right;
indices.push(a,d,e);
indices.push(d,c,e);
indices.push(e,c,b);
index_right=c;
}
// LEFT BOTTOM
else if(iy==cells-lod_value-1 && ix==lod_value){
a=index_left;
b=a+index_add;
c=b+1;
d=go_left;
indices.push(a,d,b);
indices.push(b,d,c);
index_left=c;
simple_ad++;
}
// BOTTOM
else if(iy==cells-lod_value-1 && ix>lod_value && ix<cells-lod_value-1){
a=go_left;
b=index_left;
c=b+1;
d=a+2;
e=a+1;
indices.push(a,e,b);
indices.push(b,e,c);
indices.push(c,e,d);
index_left=c;
go_left+=2;
simple_ad++;
}
// RIGHT BOTTOM
else if(iy==cells-lod_value-1 && ix==cells-lod_value-1){
a=go_left;
b=index_left;
c=b+1;
d=index_right;
indices.push(a,c,b);
indices.push(a,d,c);
}
// SIMPLE
else{
a=ix+cells_max*iy+plus_indices-simple_ad;
b=ix+cells_max*(iy+1)+plus_indices-simple_bc;
c=ix+1+cells_max*(iy+1)+plus_indices-simple_bc;
d=ix+1+cells_max*iy+plus_indices-simple_ad;
indices.push(a,d,b);
indices.push(b,d,c);
if(ix==0){ new_left_column.push(b); }
if(ix==cells-1){ new_right_column.push(c); }
}
}
}
cells_amount=cells;
left_column=new_left_column;
new_left_column=[];
right_column=new_right_column;
new_right_column=[];
}


let geometry=new THREE.BufferGeometry();
geometry.setIndex(indices);
geometry.setAttribute("position",new THREE.Float32BufferAttribute(vertices,3));
geometry.boundingSphere=new THREE.Sphere();
geometry.boundingSphere.center.set(0,0,0);
geometry.boundingSphere.radius=10000;


mesh["ocean"]=new THREE.Mesh(geometry,mat["ocean"]);
mesh["ocean"].frustumCulled=false;
mesh["ocean"].matrixAutoUpdate=false;
mesh["ocean"].updateMatrixWorld=function(){};
mesh["ocean"].matrixWorld.elements[13]=item.position.y;
scene.add(mesh["ocean"]);


if(water_stats){
console.log("["+((performance.now()-start)/1000).toFixed(6)+"s] OCEAN TRIANGLES: "+geometry.index.count/3);
}
	
	
}


function waterline_create(name){
	

let start=performance.now();


let min_size=1; // MINIMUM SIZE


let item=water[name];	
let cells_size=item.cells_size;
if(name!="ocean"){ cells_size=item.cells_size[0][0]; }


// CALCULATE THE SIZE OF THE GEOMETRY
let size=item.waves_d_max*2; // SINCE THE WAVE SHIFT IN BOTH SIDES, WE MULTIPLY THE MAXIMUM SHIFT BY 2	
size+=item.waterline_move*2; // CONSIDER THE OFFSET STEP
size+=0.1; // ERROR JUST IN CASE
size=Math.max(min_size,size); // SELECT THE MAXIMUM VALUE
let cells_amount=Math.ceil(size/cells_size);
if(cells_amount%2){ cells_amount++; } // MAKE THE NUMBER OF CELLS EVEN


if(!item.use_waves){
cells_amount=1;
cells_size=min_size;
}


let indices=[];
let vertices=[];
let a,b,c,d,e,iy,ix,x,y;
let previous_indices=0;


let cells_size_half=cells_amount*cells_size/2;
let cells_amount_max=cells_amount+1;


for(iy=0;iy<cells_amount_max;iy++){
y=iy*cells_size-cells_size_half;
for(ix=0;ix<cells_amount_max;ix++){
x=ix*cells_size-cells_size_half;
vertices.push(x,0,-y);
}
}	


for(iy=0;iy<cells_amount;iy++){
for(ix=0;ix<cells_amount;ix++){
a=ix+cells_amount_max*iy;
b=ix+cells_amount_max*(iy+1);
c=ix+1+cells_amount_max*(iy+1);
d=ix+1+cells_amount_max*iy;
indices.push(a,d,b);
indices.push(b,d,c);
}
}


let last_index=vertices.length/3-1;
vertices.push(0,-500,0);
let center=vertices.length/3-1;


for(iy=0;iy<cells_amount;iy++){
a=iy;
b=a+1;
indices.push(a,center,b);
c=iy+last_index-cells_amount;
d=c+1;
indices.push(d,center,c);
}


for(ix=0;ix<cells_amount;ix++){
a=ix*cells_amount_max;
b=a+cells_amount_max;
indices.push(b,center,a);
c=a+cells_amount;
d=b+cells_amount;
indices.push(c,center,d);
}


for(ix=0;ix<cells_amount;ix++){
a=ix;
b=a+1;
indices.push(a,center,b);
c=iy+last_index-cells_amount;
d=c+1;
indices.push(d,center,c);
}


let geometry=new THREE.BufferGeometry();
geometry.setIndex(indices);
geometry.setAttribute("position",new THREE.Float32BufferAttribute(vertices,3));
geometry.boundingSphere=new THREE.Sphere();
geometry.boundingSphere.center.set(0,0,0);
geometry.boundingSphere.radius=-1;


name="waterline_"+name;


mat[name]=new THREE.ShaderMaterial({
uniforms:{
time:{value:0},
move:{value:[0,0,0]},
gerstner_waves:{value:item.gerstner_waves},	
gerstner_waves_speed:item.gerstner_waves_speed,	
},
defines:{
use_waves:item.use_waves,
waves_amount:item.gerstner_waves.length
},
vertexShader:vs["waterline"],
fragmentShader:fs["waterline"],
wireframe:water_debug,
side:THREE.DoubleSide
});


let object=mesh[name]=new THREE.Mesh(geometry,mat[name]);
object.frustumCulled=false;
object.matrixAutoUpdate=false;
object.updateMatrixWorld=function(){};
object.matrixWorld.elements[13]=item.position.y;
if(water_debug){ scene.add(object); }


if(water_stats){
console.log("["+((performance.now()-start)/1000).toFixed(6)+"s] "+name+" WATERLINE TRIANGLES: "+geometry.index.count/3);
}


}// ____________________ MICRO ____________________


let voice_recorder;
let voice_chunks=[];
let voice_enabled=0;
let voice_send=[];


function voice_setup(){


if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia){


navigator.mediaDevices.getUserMedia({audio:true})




.then(function(stream){


let audio_types=["audio/webm\;codecs=opus","audio/webm"];
let audio_types_found="no";


for(let n in audio_types) {
if(MediaRecorder.isTypeSupported(audio_types[n])){
voice_recorder=new MediaRecorder(stream,{audioBitsPerSecond:16000,mimeType:audio_types[n]});
audio_types_found=1;
break;
}
}




if(audio_types_found!="no"){
voice_recorder.ondataavailable=function(e){
voice_chunks.push(e.data);
}
voice_recorder.onstop=function(e){
voice_send.push(new Blob(voice_chunks,{"type":audio_types[audio_types_found]}));
voice_chunks=[];
}
voice_enabled=1;
document.getElementById("voice_status").innerHTML="MICRO ON";
}


})




.catch(function(err){
document.getElementById("voice_status").innerHTML="MICRO OFF";
console.log('getUserMedia error: '+err);
});


}
else{
document.getElementById("voice_status").innerHTML="MICRO ABSCENT";
}


}


function voice_start(){
if(voice_recorder.state=="inactive"){
voice_recorder.start();
console.log(voice_recorder.state);
}
}


function voice_stop(){
if(voice_recorder.state=="recording"){
voice_recorder.stop();
console.log(voice_recorder.state);
}
}


voice_setup();
let ajax=new XMLHttpRequest();
let ajax_timeout;


function ajax_send(){


let me2=me;
me='';
let ajax_form=new FormData();
ajax_form.append("me",me2);
if(voice_send.length>0){
ajax_form.append("voice_file",voice_send[0]);
}


ajax.onreadystatechange=function(){
if(ajax.readyState==4){
clearTimeout(ajax_timeout);
ajax_timeout=setTimeout("ajax_send();",2000);
if(ajax.status==200){


if(voice_send.length>0){
voice_send.splice(0,1);
}


try{ eval(ajax.responseText); }
catch(e){}


}
}
}
//ajax.open("POST","ajax.php",true);
//ajax.send(ajax_form);
}
function loop(){


if(mat["terrain"].uniforms!==undefined && mat["terrain"].uniforms.shadowGroundMap!==undefined){
// ЧТОБЫ НЕ БЫЛО СКАЧКА FPS ПРИ ПЕРВОМ ПЕРЕХОДЕ ПО СЕКТОРУ
if(shadow_ground_2_updated!=0){
shadow_ground_2_updated++;
}
if(shadow_ground_2_updated==60){
shadow_ground_2_updated=0;

tex["shadow_ground_2"].needsUpdate=true;
}
}


let total_frame_time_start=performance.now();
let loop_js_time=performance.now();


requestAnimationFrame(loop); // СТАВИМ В НАЧАЛО ФУНКЦИИ, ЧТОБЫ СРАБОТАЛО ДАЖЕ ПРИ ОШИБКЕ


stats.update();


delta=clock.getDelta();


let max_mixers=mixers.length;


for(let n=0;n<max_mixers;n++){
mixers[n].update(delta);
}


time=Date.now()-start_time;


p_section_100_x=Math.floor(camera.position.x/100);
p_section_100_z=Math.floor(camera.position.z/100);

let bbb=0;
if(p_section_100_x!=section_100_x || p_section_100_z!=section_100_z){ bbb=1; instances_section_pass(); }


// СОЗДАЁМ ТЕНИ ПО СЕКТОРАМ
//shadow_ground_f[shadow_ground_m]();


let mini=2; // ЕСЛИ НАДО УМЕНЬШИТЬ СЕКТОР, ЧТОБЫ ЧАЩЕ РИСОВАЛО ТЕНИ И ОНИ НЕ РАСТЯГИВАЛИСЬ ВДАЛИ (АРТЕФАКТ), ТО СТАВИМ 2
let shadow_cell_size_1=62.5/mini;
let shadow_cell_size_2=shadow_cell_size_1/mini;


shadow_ground_nx=Math.floor(camera.position.x/shadow_cell_size_1);
shadow_ground_nz=Math.floor(camera.position.z/shadow_cell_size_1);


let shadow_ground_w=0;


if(camera.position.x>shadow_ground_px*shadow_cell_size_1+shadow_cell_size_1+shadow_cell_size_2){ shadow_ground_w=1; }
if(camera.position.z<shadow_ground_pz*shadow_cell_size_1-shadow_cell_size_2){ shadow_ground_w=2; }
if(camera.position.x<shadow_ground_px*shadow_cell_size_1-shadow_cell_size_1){ shadow_ground_w=3; }
if(camera.position.z>shadow_ground_pz*shadow_cell_size_1+shadow_cell_size_1){ shadow_ground_w=4; }
if(shadow_ground_w>0 || bbb==1){


document.getElementById("shadow_ground_text_1").innerHTML=performance.now()+" "+shadow_ground_w;


shadow_ground_px=shadow_ground_nx;
shadow_ground_pz=shadow_ground_nz;


mesh["pseudo"].geometry.attributes.position=new THREE.BufferAttribute();
mesh["pseudo"].geometry.attributes.position.copy(mesh["instance_grass_long"].geometry.attributes.offset);
mesh["pseudo"].geometry.attributes.position.setUsage(THREE.DynamicDrawUsage);
mesh["pseudo"].geometry.attributes.position.needsUpdate=true;


/*
shadow_ground_nx=Math.floor(camera.position.x/shadow_cell_size_1);
shadow_ground_nz=Math.floor(camera.position.z/shadow_cell_size_1);
mat["terrain"].uniforms.shadowGroundOffset.value[0]=-shadow_ground_nx*(0.125/mini)+0.5;
mat["terrain"].uniforms.shadowGroundOffset.value[1]=-shadow_ground_nz*(0.125/mini)+0.375;
mat["pseudo"].uniforms.offset.value[0]=500.0*mat["terrain"].uniforms.shadowGroundOffset.value[0];
mat["pseudo"].uniforms.offset.value[1]=500.0*(-shadow_ground_nz*(0.125/mini)-0.625);
*/

renderer.setRenderTarget(rtt_shadow);
renderer.clear();
renderer.render(mesh["pseudo"],camera);
renderer.render(mesh["pseudo2"],camera);
renderer.setRenderTarget(null);
//mesh["home001"].material=new THREE.MeshBasicMaterial({map:rtt_shadow.texture});


//mat["terrain"].uniforms.shadowGroundMap.value=rtt_shadow.texture;


}


document.getElementById("my_pos_x").innerHTML=player.position.x.toFixed(2);
document.getElementById("my_pos_y").innerHTML=player.position.y.toFixed(2);
document.getElementById("my_pos_z").innerHTML=player.position.z.toFixed(2);


player.velocity.y-=9.8*2*delta;


go_half=0;


if(go_left==1){ go_half++; }
if(go_right==1){ go_half++; }
if(go_up==1){ go_half++; }
if(go_down==1){ go_half++; }


if(go_half>1){ go_half=0.68; }


let dd=delta/0.017;


if(go_left==1){ player.position.x-=go_lrc*go_half*dd; player.position.z+=go_lrs*go_half*dd; }
if(go_right==1){ player.position.x+=go_lrc*go_half*dd; player.position.z-=go_lrs*go_half*dd; }
//if(go_up==1){ player.position.x+=go_udc*go_half*dd; player.position.z-=go_uds*go_half*dd; }
//if(go_down==1){  player.position.x-=go_udc*go_half*dd; player.position.z+=go_uds*go_half*dd; }


//220325 ЭТО ДЛЯ ПОЛЁТА

if(go_up==1){
player.position.x+=player.direction.x*player.speed;
player.position.y+=player.direction.y*player.speed;
player.position.z+=player.direction.z*player.speed;
}
if(go_down==1){
player.position.x-=player.direction.x*player.speed;
player.position.y-=player.direction.y*player.speed;
player.position.z-=player.direction.z*player.speed;
}


if(go_up || go_down || go_left || go_right){
hand_go_time+=1;
hand_go_intensity+=0.11;
}
else{
hand_go_time+=1*hand_go_intensity;
}

hand_go_intensity-=0.05;
hand_go_intensity=Math.min(Math.max(hand_go_intensity,0),1);
hand_sway_intensity-=0.05;
hand_sway_intensity=Math.min(Math.max(hand_sway_intensity,0),1);


// С ЛАНДШАФТОМ


/*
ray_b={x:player.position.x,y:player.position.y,z:player.position.z};
ray_e={x:player.position.x,y:player.position.y-2,z:player.position.z};
for(let n=0;n<100;n++){
ray_st([mesh["terrain"].geometry.attributes,mesh["Box002"].geometry.attributes]);
}


if(ray_i.hit==1){
player.position.x=ray_i.point.x;
player.position.y=ray_i.point.y+2;
player.position.z=ray_i.point.z;
jump_can=1;
jump_n=0.16;
}
*/


// С ОБЪЕКТАМИ


/*
ray_b={x:player.position.x,y:player.position.y,z:player.position.z};
ray_e={x:player.position.x,y:player.position.y,z:player.position.z};
for(let n=0;n<1;n++){
walk([mesh["terrain"].geometry.attributes,mesh["Box002"].geometry.attributes,mesh["home001"].geometry.attributes,mesh["home"].geometry.attributes,mesh["box"].geometry.attributes,mesh["Cylinder_014"].geometry.attributes,mesh["Cylinder"].geometry.attributes,mesh["pinetree001"].geometry.attributes]);
}


if(ray_i.hit==1){
let inter_ang=Math.atan2(player.position.z-ray_i.point.z,player.position.x-ray_i.point.x)/radian;
player.position.x=ray_i.point.x+Math.cos(inter_ang*radian)*0.2;
player.position.z=ray_i.point.z+Math.sin(inter_ang*radian)*0.2;
jump_can=1;
jump_n=0.16;
}
*/


let raycast_ms=performance.now();


/*
directionX=0;
directionY=-1;
directionZ=0;
originX=player.position.x;
originY=player.position.y;
originZ=player.position.z;
*/


direction.x=0;
direction.y=-1;
direction.z=0;


if(gravity==1){
player.position.y+=player.velocity.y*delta;
}

let result=0;
for(let n=0;n<1;n++){
result=intersection_ray_triangle(player.position,direction,1.7,[mesh["terrain"].geometry.attributes]);
//result=intersection_ray_triangle(player.position,{x:player.position.x,y:player.position.y-1.7,z:player.position.z},Infinity,[mesh["terrain"].geometry.attributes]);
}


document.getElementById("raycast").innerHTML=(performance.now()-raycast_ms).toFixed(3)+"ms";


if(result!=0){
player.position.x+=direction.x*result;
player.position.y+=direction.y*result+1.7;
player.position.z+=direction.z*result;
jump_can=1;
player.velocity.y=0;
}
else{
// ЧТОБЫ НЕ СМОГ СДЕЛАТЬ ПРЫЖОК В ВОЗДУХЕ ВО ВРЕМЯ ПАДЕНИЯ
jump_can=0;
}

/*
if(result!=0){
player.position.x=result.x;
player.position.y=result.y+1.7;
player.position.z=result.z;
jump_can=1;
jump_n=0.16;
}
*/


/*
ray_floor.ray.origin.copy(player.position);
ray_floor.ray.origin.y-=1.3;
let hits=ray_floor.intersectObjects([mesh["terrain"]]);
if(hits.length>0 && hits[0].face.normal.y>0 && hits[0].distance<=0.27){
player.position.y=hits[0].point.y+1.7;
jump_can=1;
jump_n=0.16;
}
*/


camera.position.set(player.position.x,player.position.y,player.position.z);


mesh["mbox"].position.x=30;
mesh["mbox"].position.y=1;
mesh["mbox"].position.z=70


mat["sprite"].uniforms.cameraDirection.value=player.direction;


mat["sprite"].uniforms.time.value=time;
mat["sprite"].uniforms.cameraAngle.value=[-player.angle.z*radian,-player.angle.y*radian];


let sprites_ms_1=performance.now();
particles_update();
let sprites_ms_2=(performance.now()-sprites_ms_1).toFixed(3);
document.getElementById("sprites").innerHTML="["+particles.length+"] "+sprites_ms_2+"ms";


movePoint();


let started=performance.now();
result=closest_point(camera.position,5,[pclose_g_1]);
let end=(performance.now()-started).toFixed(3);
if(end>cmax){ cmax=end; }
document.getElementById("closest_point").innerHTML=end+" "+cmax;


if(result!=0){


mesh["green_cone"].position.set(0,0,0);
mesh["green_cone"].lookAt(result.nx,result.ny,result.nz);
mesh["green_cone"].position.set(result.x,result.y,result.z);


if(result.t==0 && result.d<0.3){
/*
let cyl_d=Math.sqrt(Math.pow(player.position.x-result.x,2)+Math.pow(player.position.z-result.z,2));
let cyl_a=Math.atan2(player.position.z-result.z,player.position.x-result.x);
player.position.x=result.x+Math.cos(cyl_a)*0.27;
player.position.z=result.z+Math.sin(cyl_a)*0.27;
*/


}


if(result.t==1 && result.d<0.2 && result.ny==0 && (result.nx!=0 || result.nz!=0)){
/*
let inter_ang=Math.atan2(player.position.z-result.z,player.position.x-result.x)/radian;
player.position.x=result.x+Math.cos(inter_ang*radian)*0.2;
player.position.z=result.z+Math.sin(inter_ang*radian)*0.2;
*/
//player.position.x=result.x+result.nx*0.66+(player.direction.x-result.nx)*(0.06);
//player.position.z=result.z+result.nz*0.66+(player.direction.z-result.nz)*(0.06);
}


}


result=intersection_ray_triangle(player.position,player.direction,Infinity,[mesh["terrain"].geometry.attributes,mesh["home"].geometry.attributes,mesh["home001"].geometry.attributes,mesh["Box002"].geometry.attributes,mesh["wall_001"].geometry.attributes,mesh["wall_002"].geometry.attributes,mesh["wall_003"].geometry.attributes]);


if(result!=0){
mesh["object_i_ray_triangle"].position.set(player.position.x+player.direction.x*result,player.position.y+player.direction.y*result,player.position.z+player.direction.z*result);
}


started=performance.now();
result=intersection_ray_sphere(player.position,player.direction,50,[mesh["object_i_ray_sphere_1"],mesh["object_i_ray_sphere_2"]]);
end=(performance.now()-started).toFixed(3);
if(result==0){ document.getElementById("status_i_ray_sphere").innerHTML="no"; }
else{
mesh["status_i_ray_sphere"].position.set(player.position.x+player.direction.x*result,player.position.y+player.direction.y*result,player.position.z+player.direction.z*result);
document.getElementById("status_i_ray_sphere").innerHTML="Distance="+result+"<br>x:"+(player.position.x+player.direction.x*result)+"<br>y:"+(player.position.y+player.direction.y*result)+"<br>z:"+(player.position.z+player.direction.z*result)+"<br>time: "+end+"ms";
}


started=performance.now();
result=intersection_ray_AABB(player.position,player.direction,50,[mesh["home"],mesh["home001"]]);
end=(performance.now()-started).toFixed(3);
if(result==0){ document.getElementById("status_i_ray_AABB").innerHTML="no"; }
else{
mesh["status_i_ray_AABB"].position.set(player.position.x+player.direction.x*result,player.position.y+player.direction.y*result,player.position.z+player.direction.z*result);
document.getElementById("status_i_ray_AABB").innerHTML="Distance="+result+"<br>x:"+(player.position.x+player.direction.x*result)+"<br>y:"+(player.position.y+player.direction.y*result)+"<br>z:"+(player.position.z+player.direction.z*result)+"<br>time: "+end+"ms";
}


rzh();


mesh["big_box_8"].rotation.z=-time*0.002;


mesh["big_box_6"].position.y=-1+Math.sin(time*0.004)*0.02;
mesh["big_box_6"].rotation.x=Math.sin(time*0.004)*0.01;
mesh["big_box_6"].rotation.z=Math.sin(time*0.003)*0.014;


mesh["jetski"].position.y=-1.3+Math.sin(time*0.004)*0.02;
mesh["jetski"].rotation.x=-1.57+Math.sin(time*0.004)*0.01;
mesh["jetski"].rotation.z=-2+Math.sin(time*0.003)*0.014;


mesh["gull_fly_1"].position.x=40+Math.sin(time*0.0005)*20;
mesh["gull_fly_1"].position.y=10+Math.sin(time*0.0002)*10;
mesh["gull_fly_1"].position.z=130+Math.cos(time*0.0005)*20;
mesh["gull_fly_1"].lookAt(40+Math.sin((time+1)*0.0005)*20,10+Math.sin((time+1)*0.0002)*10,130+Math.cos((time+1)*0.0005)*20);


mesh["gull_fly_2"].position.x=50+Math.sin(time*0.0004)*20;
mesh["gull_fly_2"].position.y=15+Math.sin(time*0.0002)*15;
mesh["gull_fly_2"].position.z=150+Math.cos(time*0.0004)*30;
mesh["gull_fly_2"].lookAt(50+Math.sin((time+1)*0.0004)*20,15+Math.sin((time+1)*0.0002)*15,150+Math.cos((time+1)*0.0004)*30);


document.getElementById("loop_js_time").innerHTML=(performance.now()-loop_js_time).toFixed(4);


updateWeaponSway();


particles_other_a[26].offset[2]=1.5+Math.sin(time*0.002)*15;
particles_other_a[29].offset[2]=6+Math.sin(time*0.01)*15;


let loop_render_time=performance.now();

/*
renderer.info.reset();
renderer.clear(); // ОЧИЩАЕМ ПОЛНОСТЬЮ
renderer.render(scene,camera); // ОСНОВНАЯ СЦЕНА
renderer_stats_update(0);
renderer.clearDepth(); // УБИРАЕМ ГЛУБИНУ ОТ ПРОШЛОЙ СЦЕНЫ, ТО ЕСТЬ ЛИШНЕЕ
renderer.render(scene_hud,camera_hud); // HUD СЦЕНА
renderer_stats_update(1);
*/


sun_position_update();
mesh["weapon"].updateMatrixWorld();


gpuPanel_shader_name="";


if(gpuPanel_shader_name==""){ gpuPanel.startQuery(); }


water_render();
renderer_stats_update(0);
renderer.info.reset();


/*
renderer.info.reset();
renderer.clear(); // ОЧИЩАЕМ ПОЛНОСТЬЮ
renderer.render(scene,camera); // ОСНОВНАЯ СЦЕНА
renderer_stats_update(0);
renderer.clearDepth(); // УБИРАЕМ ГЛУБИНУ ОТ ПРОШЛОЙ СЦЕНЫ, ТО ЕСТЬ ЛИШНЕЕ
renderer.render(scene_hud,camera_hud); // HUD СЦЕНА
renderer_stats_update(1);
*/


composer.render();
renderer_stats_update(1);
renderer.info.reset();
renderer.clearDepth(); // УБИРАЕМ ГЛУБИНУ ОТ ПРОШЛОЙ СЦЕНЫ, ТО ЕСТЬ ЛИШНЕЕ
renderer.render(scene_hud,camera_hud); // HUD СЦЕНА
//renderer.render(mesh["overlay_damage_blood"],camera_hud); // HUD СЦЕНА
renderer_stats_update(2);
renderer.info.reset();


if(gpuPanel_shader_name==""){ gpuPanel.endQuery(); }


let loop_render_time_end=String(performance.now()-loop_render_time).replace(/(\..{4}).*/,'$1');
if(loop_render_time_end>=loop_render_time_max){ loop_render_time_max=loop_render_time_end; }
if(loop_render_time_end<loop_render_time_min){ loop_render_time_min=loop_render_time_end; }
if(loop_render_time_elapsed>5){ loop_render_time_elapsed=0; loop_render_time_max=loop_render_time_end; loop_render_time_min=loop_render_time_end; }
loop_render_time_elapsed+=delta;
document.getElementById("loop_render").innerHTML="now "+loop_render_time_end+"<br> max "+loop_render_time_max+"<br> min "+loop_render_time_min;


let total_frame_time_end=Number((performance.now()-total_frame_time_start).toFixed(3));
if(total_frame_time_end>=total_frame_time_max){ total_frame_time_max=total_frame_time_end; }
if(total_frame_time_elapsed>0.5){ total_frame_time_elapsed=0; total_frame_time_max=total_frame_time_end; total_frame_time_min=total_frame_time_end; }
total_frame_time_elapsed+=delta;
document.getElementById("total_frame").innerHTML="now "+total_frame_time_end+"<br>  max "+total_frame_time_max+"<br>  min "+total_frame_time_min;


}

function instance_set(){


dummy["instance"]=new THREE.Object3D();


for(let i=0;i<50;i++){
for(let j=0;j<10;j++){

instance_gen(-50+i*100,0,-50+j*100,100,50,1.50,"grass","grass_long","grass_long_1");
//instance_gen(-2500+i*100,0,-500+j*100,100,5000,1.50,"grass","grass_long","grass_long_1");


//instance_gen(-50+i*100,0,-50+j*100,100,2000,1.50,"grass","grass_long","grass_long_1");
}
}
//instance_gen(50,0,0,100,400,1.50,"grass","grass_long","grass_long_1");
//instance_gen(50,0,50,100,400,1.50,"grass","grass_long","grass_long_1");


}


let total_grass=0;


function instance_gen(ix,iy,iz,is,iamount,iwh,ishader,imesh,itex){


let ray_instance=new THREE.Raycaster();
ray_instance.ray.direction.set(0,-1,0);


let bufferGeometry=mesh[imesh].geometry;
let geometry=new THREE.InstancedBufferGeometry();
geometry.attributes.position=bufferGeometry.attributes.position;
geometry.attributes.uv=bufferGeometry.attributes.uv;
geometry.attributes.normal=bufferGeometry.attributes.normal;


let scale=[];
let offset=[];
let orientation=[];
let color=[];
let x,y,z;
let average={x:0,y:0,z:0};
let i_real_amount=0;


for(let i=0;i<iamount;i++){
x=Number(((Math.random()-0.5)*is+ix).toFixed(2));
//x=(i%3)*5+20;
y=iy+0;
z=Number(((Math.random()-0.5)*is+iz).toFixed(2));
//z=-i*3+10;
let normal=new THREE.Vector3(0,0,1);

//x=22;
//z=-11;




ray_instance.ray.origin.set(x,300,z);
let ray_instance_hits=ray_instance.intersectObjects([mesh["terrain"]]);


if(ray_instance_hits.length==0 || ray_instance_hits[0].face.normal.y<=0){
continue;
}


let shadow_ground_x=Math.floor(x*shadow_ground_pixel);
let shadow_ground_z=Math.floor(z*shadow_ground_pixel);


let ins_cell=Math.floor(x/62.5)+"_"+Math.floor(z/62.5);
if(shadow_ground_cell[ins_cell]==undefined){ shadow_ground_cell[ins_cell]=[]; }
//shadow_ground_cell[ins_cell].push(shadow_ground_x-6,shadow_ground_z-6,13);
shadow_ground_cell[ins_cell].push(shadow_ground_x,shadow_ground_z,1);


i_real_amount++;
total_grass++;


y=ray_instance_hits[0].point.y;
normal=ray_instance_hits[0].face.normal;
//normal=new THREE.Vector3().crossVectors(normal,new THREE.Vector3(0,0,1));
//normal.normalize();


dummy["instance"].lookAt(normal);
//dummy["instance"].lookAt(0,1,0);
dummy["instance"].rotateX(1.57);
dummy["instance"].rotateY(Math.random()*6.28);


offset.push(x,y,z);
//orientation.push(0.4,Math.random()*2-1,0,1);
orientation.push(dummy["instance"].quaternion.x,dummy["instance"].quaternion.y,dummy["instance"].quaternion.z,dummy["instance"].quaternion.w);
scale.push(Math.floor(Math.random()*10)/15+0.5);
//scale.push(Math.floor(Math.random()*20)+30);
//scale.push(1);


let cc_rand=Math.random()/5+0.9;
let cc_r=0.42*cc_rand;
let cc_g=0.47*cc_rand;
let cc_b=0.12*cc_rand;


cc_r=1+Math.random()/5-0.1;
cc_g=1+Math.random()/5-0.1;
cc_b=0.12+Math.random()/10-0.1;


color.push(cc_r,cc_g,cc_b);


average.x+=x;
average.y+=y;
average.z+=z;
}


let i_center={x:Math.floor(average.x/i_real_amount),y:Math.floor(average.y/i_real_amount),z:Math.floor(average.z/i_real_amount)};


let i_radius=0;
for(let i=0;i<i_real_amount;i++){
let i_dist_to_center=Math.sqrt(Math.pow((offset[i*3]-i_center.x),2)+Math.pow((offset[i*3+1]-i_center.y),2)+Math.pow((offset[i*3+2]-i_center.z),2));
if(i_dist_to_center>i_radius){ i_radius=i_dist_to_center; }
}
i_radius=Math.ceil(i_radius);


geometry.setAttribute('offset',new THREE.InstancedBufferAttribute(new Float32Array(offset),3));
geometry.setAttribute('orientation',new THREE.InstancedBufferAttribute(new Float32Array(orientation),4));
geometry.setAttribute('scale',new THREE.InstancedBufferAttribute(new Float32Array(scale),1));
geometry.setAttribute('color',new THREE.InstancedBufferAttribute(new Float32Array(color),3));


let material;


if(ishader=="grass"){
material=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex[itex]},
time:{value:0},
sun_direction:{value:sun_direction},
},
vertexShader:vs["grass"],
fragmentShader:fs["grass"],
side:THREE.DoubleSide,
transparent:true,
});
}


if(ishader=="tree_basic"){
material=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex[itex]},
pos:{value:{x:i_center.x,y:i_center.y,z:i_center.z}},
sun_direction:{value:sun_direction},
},
vertexShader:vs["tree_basic"],
fragmentShader:fs["tree_basic"],
});
}


if(ishader=="tree_sprite"){
material=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex[itex]},
pos:{value:{x:i_center.x,y:i_center.y,z:i_center.z}},
sun_direction:{value:sun_direction},
},
vertexShader:vs["tree_sprite"],
fragmentShader:fs["tree_sprite"],
});
}


let ins_cell=Math.floor(ix/100)+"_"+Math.floor(iz/100);
if(section_100_objects[ins_cell]==undefined){ section_100_objects[ins_cell]=[]; }


let num=Math.floor((section_100_objects[ins_cell].length+1)/2)+1;


let instance_name="instance_"+itex+"_"+ins_cell+"_"+num;
mesh[instance_name]=new THREE.Mesh(geometry,material);
mesh[instance_name].renderOrder=-2; // ЧТОБЫ ЧАСТИЦЫ ПРАВИЛЬНО ОТОБРАЖАЛИСЬ СКВОЗЬ И ПЕРЕД ЭТИМ ПРОЗРАЧНЫМ ОБЪЕКТОМ. Т.К. У ОЗЕРА -1, ТО СТАВИМ -2
mesh[instance_name].geometry.boundingSphere=new THREE.Sphere({x:0,y:0,z:0},i_radius+iwh);
mesh[instance_name].matrixAutoUpdate=false;
mesh[instance_name].updateMatrixWorld=function(){};
//scene.add(mesh[instance_name]);


section_100_objects[ins_cell].push(instance_name);

/*
mesh["instance_sphere_"+ins_cell+"_"+num]=new THREE.Mesh(new THREE.SphereBufferGeometry(i_radius+iwh,9,9),new THREE.MeshBasicMaterial({color:0xffff00,wireframe:true}));
mesh["instance_sphere_"+ins_cell+"_"+num].position.set(i_center.x,i_center.y,i_center.z);
mesh["instance_sphere_"+ins_cell+"_"+num].updateMatrixWorld();
mesh["instance_sphere_"+ins_cell+"_"+num].matrixAutoUpdate=false;
mesh[instance_name].updateMatrixWorld=function(){};
scene.add(mesh["instance_sphere_"+ins_cell+"_"+num]);
section_100_objects[ins_cell].push("instance_sphere_"+ins_cell+"_"+num);
*/

}


function instances_section_pass(){


let started_1=performance.now();
let started_2=performance.now();


/*
for(let i=0;i<25;i++){
let cell_name=(section_100_x+ways_25[i][0])+"_"+(section_100_z+ways_25[i][1]);
if(section_100_objects[cell_name]!=undefined){
let max_section_100_objects=section_100_objects[cell_name].length;
for(let n=0;n<max_section_100_objects;n++){
scene.remove(mesh[section_100_objects[cell_name][n]]);
}
}
}
*/


let count=0;


for(let i=0;i<25;i++){


let cell_name=(p_section_100_x+ways_25[i][0])+"_"+(p_section_100_z+ways_25[i][1]);


if(section_100_objects[cell_name]==undefined){ continue; }


let max_objects=section_100_objects[cell_name].length;


for(let n=0;n<max_objects;n++){


let item=mesh[section_100_objects[cell_name][n]].geometry.attributes;


if(item.scale==undefined){ continue; }
count+=item.scale.array.length;


}


}


let scale=new Float32Array(count);
let offset=new Float32Array(count*3);
let orientation=new Float32Array(count*4);
let color=new Float32Array(count*3);


let one_c=0;
let three_c=0;
let four_c=0;


for(let i=0;i<25;i++){


let cell_name=(p_section_100_x+ways_25[i][0])+"_"+(p_section_100_z+ways_25[i][1]);


if(section_100_objects[cell_name]==undefined){ continue; }


let max_objects=section_100_objects[cell_name].length;


for(let n=0;n<max_objects;n++){


let item=mesh[section_100_objects[cell_name][n]].geometry.attributes;


if(item.scale==undefined){ continue; }


let i_scale=item.scale.array;
let i_offset=item.offset.array;
let i_color=item.color.array;
let i_orientation=item.orientation.array;


let max_one_elements=i_scale.length;


for(let j=0;j<max_one_elements;j++){


scale[j+one_c]=i_scale[j];


let j_zero=j*3;
let p=j_zero+three_c;
let p_one=p+1;
let p_two=p+2;
let j_one=j_zero+1;
let j_two=j_zero+2;
offset[p]=i_offset[j_zero];
offset[p_one]=i_offset[j_one];
offset[p_two]=i_offset[j_two];
color[p]=i_color[j_zero];
color[p_one]=i_color[j_one];
color[p_two]=i_color[j_two];


j_zero=j*4;
p=j_zero+four_c;
orientation[p]=i_orientation[j_zero];
orientation[p+1]=i_orientation[j_zero+1];
orientation[p+2]=i_orientation[j_zero+2];
orientation[p+3]=i_orientation[j_zero+3];
}


one_c+=max_one_elements;
three_c=one_c*3;
four_c=one_c*4;


//scene.add(mesh[section_100_objects[cell_name][n]]);
//mesh["instance_grass_long"].geometry.attributes.offset.
}
}


started_2=(performance.now()-started_2).toFixed(3);


let started_3=performance.now();


let item=mesh["instance_grass_long"].geometry.attributes;
item.scale=new THREE.InstancedBufferAttribute(scale,1).setUsage(THREE.DynamicDrawUsage);
item.offset=new THREE.InstancedBufferAttribute(offset,3).setUsage(THREE.DynamicDrawUsage);
item.orientation=new THREE.InstancedBufferAttribute(orientation,4).setUsage(THREE.DynamicDrawUsage);
item.color=new THREE.InstancedBufferAttribute(color,3).setUsage(THREE.DynamicDrawUsage);


mesh["instance_grass_long"].geometry._maxInstanceCount=count;


section_100_x=p_section_100_x;
section_100_z=p_section_100_z;
document.getElementById("section_100_x").innerHTML=section_100_x;
document.getElementById("section_100_z").innerHTML=section_100_z;


document.getElementById("section_pass").innerHTML="SECTION PASS TOTAL: "+(performance.now()-started_1).toFixed(3)+" FIRST: "+started_2+" SECOND: "+(performance.now()-started_3).toFixed(3)+" GRASS: "+count;


}
let maxanisotropy=renderer.capabilities.getMaxAnisotropy();
let vegetation_anisotropy=4;
if(vegetation_anisotropy>maxanisotropy){ vegetation_anisotropy=maxanisotropy; }


let tex=[];
let texture_loader=new THREE.TextureLoader(loadingManager);
let RGBELoader=new THREE_RGBELoader.RGBELoader(loadingManager);
let UltraHDRLoader=new THREE_UltraHDRLoader.UltraHDRLoader(loadingManager);
UltraHDRLoader.setDataType(THREE.FloatType);


tex["sky"]=RGBELoader.load("./images/sky/pizzo_pernice_puresky_1k.hdr");
tex["sky"].mapping=THREE.EquirectangularReflectionMapping;
environment_main=tex["sky"];


tex["shadow"]=texture_loader.load("./images/shadow.png");

tex["shadow_tree"]=texture_loader.load("./images/shadow_tree.png");

tex["crosshair"]=texture_loader.load("./images/crosshair.png");


tex["overlay_damage_blood"]=texture_loader.load("./images/effects/overlay_damage_blood.png");
tex["overlay_damage_blood"].colorSpace=THREE.SRGBColorSpace;


tex["ground_1_diffuse"]=texture_loader.load("./images/ground/ground_1_diffuse.jpg");
tex["ground_1_diffuse"].wrapS=tex["ground_1_diffuse"].wrapT=THREE.RepeatWrapping;
tex["ground_1_diffuse"].repeat.set(50,50);
tex["ground_1_diffuse"].colorSpace=THREE.SRGBColorSpace;
tex["ground_1_normal"]=texture_loader.load("./images/ground/ground_1_normal.png");
tex["ground_1_normal"].wrapS=tex["ground_1_normal"].wrapT=THREE.RepeatWrapping;
tex["ground_1_normal"].repeat.set(50,50);
tex["ground_1_roughness"]=texture_loader.load("./images/ground/ground_1_roughness.jpg");
tex["ground_1_roughness"].wrapS=tex["ground_1_roughness"].wrapT=THREE.RepeatWrapping;
tex["ground_1_roughness"].repeat.set(50,50);
//tex["ground_1_ao"]=texture_loader.load("./images/ground/ground_1_ao.jpg");
//tex["ground_1_ao"].wrapS=tex["ground_1_ao"].wrapT=THREE.MirroredRepeatWrapping;
//tex["ground_1_ao"].repeat.set(0.2,0.2);


tex["bb_diffuse"]=texture_loader.load("./images/rock/bb_diffuse.png");
tex["bb_diffuse"].wrapS=tex["bb_diffuse"].wrapT=THREE.RepeatWrapping;
tex["bb_diffuse"].repeat.set(10,10);
tex["bb_normal"]=texture_loader.load("./images/rock/bb_normal.png");
tex["bb_normal"].wrapS=tex["bb_normal"].wrapT=THREE.RepeatWrapping;


tex["terrain_grass"]=texture_loader.load("./images/ground/ground_grass.png");
tex["terrain_grass"].wrapS=tex["terrain_grass"].wrapT=THREE.RepeatWrapping;


tex["terrain_dirt"]=texture_loader.load("./images/crosshair.png");
tex["terrain_dirt"].wrapS=tex["terrain_dirt"].wrapT=THREE.RepeatWrapping;


tex["terrain_noise"]=texture_loader.load("./images/ground/terrain_noise.png");
tex["terrain_noise"].wrapS=tex["terrain_noise"].wrapT=THREE.RepeatWrapping;


tex["terrain_noise_2"]=texture_loader.load("./images/ground/terrain_noise_2.png");
tex["terrain_noise_2"].wrapS=tex["terrain_noise_2"].wrapT=THREE.RepeatWrapping;


tex["terrain_grass_normal"]=texture_loader.load("./images/crosshair.png");
tex["terrain_grass_normal"].wrapS=tex["terrain_grass_normal"].wrapT=THREE.RepeatWrapping;


tex["dirt"]=texture_loader.load("./images/ground/dirt.jpg");
tex["dirt"].wrapS=tex["dirt"].wrapT=THREE.RepeatWrapping;
tex["dirt"].colorSpace=THREE.SRGBColorSpace;


tex["stone_2_d"]=texture_loader.load("./images/rock/bb_diffuse.png");
tex["stone_2_d"].wrapS=tex["stone_2_d"].wrapT=THREE.RepeatWrapping;
tex["stone_2_d"].repeat.set(8,8);
tex["stone_2_d"].colorSpace=THREE.SRGBColorSpace;
tex["stone_2_n"]=texture_loader.load("./images/rock/bb_normal.png");
tex["stone_2_n"].wrapS=tex["stone_2_n"].wrapT=THREE.RepeatWrapping;
tex["stone_2_n"].repeat.set(8,8);


tex["grass_n"]=texture_loader.load("./images/ground/grass_46.png");
tex["grass_n"].wrapS=tex["grass_n"].wrapT=THREE.RepeatWrapping;


tex["ground_22"]=texture_loader.load("./images/ground/ground_22.png");
tex["ground_22"].wrapS=tex["ground_22"].wrapT=THREE.RepeatWrapping;
tex["ground_24"]=texture_loader.load("./images/ground/ground_22.png");
tex["ground_24"].wrapS=tex["ground_24"].wrapT=THREE.RepeatWrapping;
tex["ground_23"]=texture_loader.load("./images/ground/ground_23.png");
tex["ground_23"].wrapS=tex["ground_23"].wrapT=THREE.RepeatWrapping;


tex["wall_237"]=texture_loader.load("./images/wall/wall_237.png");
tex["wall_237"].colorSpace=THREE.SRGBColorSpace;
tex["wall_238_n"]=texture_loader.load("./images/wall/wall_238_n.png");
tex["wall_237"].wrapS=tex["wall_237"].wrapT=THREE.RepeatWrapping;
tex["wall_238_n"].wrapS=tex["wall_238_n"].wrapT=THREE.RepeatWrapping;


tex["ground_63"]=texture_loader.load("./images/ground/ground_63.png");
tex["ground_63"].wrapS=tex["ground_63"].wrapT=THREE.RepeatWrapping;


tex["wall_277"]=texture_loader.load("./images/wall/wall_277.png");
tex["wall_277"].colorSpace=THREE.SRGBColorSpace;
tex["wall_278"]=texture_loader.load("./images/wall/wall_278.png");
tex["wall_279"]=texture_loader.load("./images/wall/wall_279.png");


tex["smoke"]=texture_loader.load("./images/sprite/smoke.png");
tex["cloud"]=texture_loader.load("./images/sprite/cloud.png");
tex["cloud"].flipY=false;
tex["cloud"].needsUpdate=true;
tex["fire"]=texture_loader.load("./images/sprite/fire.png");
tex["sprite_yellow"]=texture_loader.load("./images/sprite/sprite_yellow.png");
tex["beam"]=texture_loader.load("./images/sprite/beam.png");
tex["flare_blue"]=texture_loader.load("./images/sprite/flare_blue.jpg");
tex["glass_1"]=texture_loader.load("./images/sprite/glass_1.jpg");
tex["window"]=texture_loader.load("./images/sprite/window.png");
tex["spark"]=texture_loader.load("./images/sprite/spark.png");
tex["shot"]=texture_loader.load("./images/sprite/shot.png");
tex["water_drop"]=texture_loader.load("./images/sprite/water_drop.png");
tex["water_drop"].wrapS=tex["water_drop"].wrapT=THREE.RepeatWrapping;
tex["homer"]=texture_loader.load("./images/sprite/homer.png");
tex["avatar"]=texture_loader.load("./images/sprite/avatar.png");
tex["tracer"]=texture_loader.load("./images/sprite/tracer.png");
tex["water_splash"]=texture_loader.load("./images/sprite/water_splash.png");


tex["ocean_holes"]=texture_loader.load("./images/water/ocean_holes.png");
tex["ocean_holes"].format=THREE.RedFormat; // УБИРАЕМ ЛИШНИИ ЦВЕТА И ЗАОДНО УМЕНЬШАЕМ ЗАНИМАЕМОЕ МЕСТО НА ВИДЕОКАРТЕ
tex["ocean_holes"].minFilter=tex["ocean_holes"].magFilter=THREE.NearestFilter; // ЧТОБЫ НЕ БЫЛО ДЕФЕКТОВ НА РАССТОЯНИИ
tex["water_foam"]=texture_loader.load("./images/water/water_foam.png");
tex["water_foam"].wrapS=tex["water_foam"].wrapT=THREE.RepeatWrapping;
tex["water_foam"].colorSpace=THREE.SRGBColorSpace;
tex["water_normal"]=texture_loader.load("./images/water/water_normal.png");
tex["water_normal"].wrapS=tex["water_normal"].wrapT=THREE.RepeatWrapping;
tex["water_caustic"]=texture_loader.load("./images/water/water_caustic.png");
tex["water_caustic"].wrapS=tex["water_caustic"].wrapT=THREE.RepeatWrapping;
tex["water_caustic"].colorSpace=THREE.SRGBColorSpace;
tex["underwater_ripples"]=texture_loader.load("./images/water/underwater_ripples.png");
tex["underwater_ripples"].wrapS=tex["underwater_ripples"].wrapT=THREE.RepeatWrapping;
tex["underwater_eyes"]=texture_loader.load("./images/water/underwater_eyes.png");
tex["underwater_eyes"].wrapS=tex["underwater_eyes"].wrapT=THREE.RepeatWrapping;


tex["bump_normal"]=texture_loader.load("./images/bump_normal.png");


tex["env_sunny"]=texture_loader.load("./images/env_sunny.jpg");
tex["env_sunny"].mapping=THREE.EquirectangularRefractionMapping;
tex["env_sunny"].colorSpace=THREE.SRGBColorSpace;


tex["jetski"]=texture_loader.load("./models/jetski/jetski.jpg");
tex["jetski"].colorSpace=THREE.SRGBColorSpace;


tex["ammo_d"]=texture_loader.load("./models/ammo/ammo_d.png");
tex["ammo_d"].colorSpace=THREE.SRGBColorSpace;
tex["ammo_ao"]=texture_loader.load("./models/ammo/ammo_ao.png");
tex["ammo_items"]=texture_loader.load("./models/ammo/ammo_items.png");
tex["ammo_items"].colorSpace=THREE.SRGBColorSpace;
tex["ammo_ms"]=texture_loader.load("./models/ammo/ammo_ms.jpg");
tex["ammo_n"]=texture_loader.load("./models/ammo/ammo_n.png");


tex["soldier_body_d"]=texture_loader.load("./models/soldier/soldier_body_d.png");
tex["soldier_body_d"].colorSpace=THREE.SRGBColorSpace;
tex["soldier_body_d"].wrapS=tex["soldier_body_d"].wrapT=THREE.RepeatWrapping;
tex["soldier_body_n"]=texture_loader.load("./models/soldier/soldier_body_n.png");
tex["soldier_body_s"]=texture_loader.load("./models/soldier/soldier_body_s.png");
tex["soldier_head_d"]=texture_loader.load("./models/soldier/soldier_head_d.png");
tex["soldier_head_d"].colorSpace=THREE.SRGBColorSpace;
tex["soldier_head_n"]=texture_loader.load("./models/soldier/soldier_head_n.png");
tex["soldier_head_s"]=texture_loader.load("./models/soldier/soldier_head_s.png");


tex["gun_ao"]=texture_loader.load("./models/gun/gun_ao.png");
tex["gun_d"]=texture_loader.load("./models/gun/gun_d.png");
tex["gun_d"].colorSpace=THREE.SRGBColorSpace;
tex["gun_m"]=texture_loader.load("./models/gun/gun_m.png");
tex["gun_n"]=texture_loader.load("./models/gun/gun_n.png");
tex["gun_r"]=texture_loader.load("./models/gun/gun_r.png");


tex["uaz_d"]=texture_loader.load("./models/uaz/uaz_d.jpg");
tex["uaz_d"].colorSpace=THREE.SRGBColorSpace;
tex["uaz_n"]=texture_loader.load("./models/uaz/uaz_n.jpg");
tex["uaz_s"]=texture_loader.load("./models/uaz/uaz_s.jpg");
tex["uaz_m"]=texture_loader.load("./models/uaz/uaz_m.jpg");
tex["uaz_ao"]=texture_loader.load("./models/uaz/uaz_ao.jpg");
tex["uaz_o"]=texture_loader.load("./models/uaz/uaz_o.jpg");


tex["uaz_glass_d"]=texture_loader.load("./models/uaz/uaz_glass_d.jpg");
tex["uaz_glass_d"].colorSpace=THREE.SRGBColorSpace;
tex["uaz_glass_n"]=texture_loader.load("./models/uaz/uaz_glass_n.jpg");
tex["uaz_glass_s"]=texture_loader.load("./models/uaz/uaz_glass_s.jpg");
tex["uaz_glass_m"]=texture_loader.load("./models/uaz/uaz_glass_m.jpg");
tex["uaz_glass_ao"]=texture_loader.load("./models/uaz/uaz_glass_ao.jpg");
tex["uaz_glass_o"]=texture_loader.load("./models/uaz/uaz_glass_o.jpg");


tex["wolf"]=texture_loader.load("./models/wolf/STANDARD_WOLF_C.png");
tex["wolf"].colorSpace=THREE.SRGBColorSpace;


tex["gull_d"]=texture_loader.load("./models/gull/gull_d.jpg");
tex["gull_d"].colorSpace=THREE.SRGBColorSpace;


tex["wall_118"]=texture_loader.load("./images/wall/wall_118.jpg");
tex["wall_118"].colorSpace=THREE.SRGBColorSpace;
tex["wall_118"].wrapS=tex["wall_118"].wrapT=THREE.RepeatWrapping;


tex["grass_long_1"]=texture_loader.load("./images/grass/grass_150.png");
tex["grass_long_1"].anisotropy=vegetation_anisotropy;
tex["grass_long_1"].colorSpace=THREE.SRGBColorSpace;


tex["grass_color"]=texture_loader.load("./images/ground/grass_color.png");


tex["wind"]=texture_loader.load("./images/wind.png");
tex["wind"].wrapS=tex["wind"].wrapT=THREE.RepeatWrapping;




tex["wall_108"]=texture_loader.load("./images/wall/wall_108.jpg");
tex["wall_108"].wrapS=tex["wall_108"].wrapT=THREE.RepeatWrapping;
tex["wall_108"].colorSpace=THREE.SRGBColorSpace;
tex["wall_276"]=texture_loader.load("./images/wall/wall_276.jpg");
tex["wall_276"].colorSpace=THREE.SRGBColorSpace;
tex["home_roof"]=texture_loader.load("./images/home/home_roof.jpg");
tex["home_roof"].wrapS=tex["home_roof"].wrapT=THREE.RepeatWrapping;
tex["home_roof"].colorSpace=THREE.SRGBColorSpace;


tex["pinetree"]=texture_loader.load("./images/tree/pinetree.png");
tex["pinetree"].colorSpace=THREE.SRGBColorSpace;


tex["017_color"]=texture_loader.load("./images/tiles/017_color.jpg");
tex["017_color"].wrapS=tex["017_color"].wrapT=THREE.RepeatWrapping;
tex["017_color"].repeat.set(200,200);
tex["017_normal"]=texture_loader.load("./images/tiles/017_normal.png");
tex["017_normal"].wrapS=tex["017_normal"].wrapT=THREE.RepeatWrapping;


tex["specular_test"]=texture_loader.load("./images/specular_test.png");
tex["specular_test"].wrapS=tex["specular_test"].wrapT=THREE.RepeatWrapping;


tex["stoneVRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/stoneVRayRawTotalLightingMap.hdr");
tex["boxVRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/boxVRayRawTotalLightingMap.hdr");
tex["Cylinder_014VRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/Cylinder_014VRayRawTotalLightingMap.hdr");
tex["home001VRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/home001VRayRawTotalLightingMap.hdr");
tex["pinetree001VRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/pinetree001VRayRawTotalLightingMap.hdr");
tex["homeVRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/homeVRayRawTotalLightingMap.hdr");
tex["wall_001VRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/wall_001VRayRawTotalLightingMap.hdr");
tex["wall_002VRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/wall_002VRayRawTotalLightingMap.hdr");
tex["wall_003VRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/wall_003VRayRawTotalLightingMap.hdr");
tex["Box002VRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/Box002VRayRawTotalLightingMap.hdr");
tex["Box003VRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/Box003VRayRawTotalLightingMap.hdr");
tex["terrainVRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/terrainVRayRawTotalLightingMap.hdr");
tex["Box004VRayRawTotalLightingMap"]=RGBELoader.load("./images/lightmap/Box004VRayRawTotalLightingMap.hdr");


// https://github.com/MONOGRID/gainmap-js/
// https://gainmap-creator.monogrid.com/
tex["bbb"]=UltraHDRLoader.load("./images/lightmap/Box002VRayRawTotalLightingMap.jpg");



let OBJLoader=new THREE_OBJLoader.OBJLoader(loadingManager);
OBJLoader.mat=mat;
let FBXLoader=new THREE_FBXLoader.FBXLoader(loadingManager);
mat["wall_237"]=new THREE.MeshStandardMaterial({
});


mat["terrain"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["terrain_grass"]},
dirt:{value:tex["terrain_dirt"]},
noise:{value:tex["terrain_noise"]},
lightMap:{value:null},
fogColor:{value:fogColor},
},
vertexShader:vs["terrain_triplanar"],
fragmentShader:fs["terrain_triplanar"],
});


mat["stone"]=new THREE.MeshStandardMaterial({
map:tex["stone_2_d"],
normalMap:tex["stone_2_n"],
roughness:0.6,
metalness:0.3,
});


mat["rock_23"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["stone_2_d"]},
lightMap:{value:null},
},
vertexShader:vs["basic_ao"],
fragmentShader:fs["basic_ao"],
});


mat["wall_118"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["wall_118"]},
lightMap:{value:null},
shadow_map:{value:tex["wall_118"]},
},
vertexShader:vs["basic_ao"],
fragmentShader:fs["basic_ao"],
});


mat["wall_108"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["wall_108"]},
lightMap:{value:null},
},
vertexShader:vs["basic_ao"],
fragmentShader:fs["basic_ao"],
});


mat["wall_276"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["wall_276"]},
lightMap:{value:null},
},
vertexShader:vs["basic_ao"],
fragmentShader:fs["basic_ao"],
});


mat["home_roof"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["home_roof"]},
lightMap:{value:null},
},
vertexShader:vs["basic_ao"],
fragmentShader:fs["basic_ao"],
});


mat["pinetree"]=new THREE.ShaderMaterial({
uniforms:{
map:{value:tex["pinetree"]},
lightMap:{value:null},
},
vertexShader:vs["basic_ao"],
fragmentShader:fs["basic_ao"],
side:THREE.DoubleSide,
});


OBJLoader.load("./models/common.obj",function(object){


while(object.children.length){


let name=object.children[0].name;


mesh[name]=object.children[0];


if(name=="stone"){


mesh["stone_2"]=mesh["stone"].clone();


mesh["stone_2"].material=new THREE.MeshStandardMaterial({
map:tex["stone_2_d"],
normalMap:tex["stone_2_n"],
roughness:0.6,
metalness:0.3,
});

mesh["stone_2"].castShadow=true;
mesh["stone_2"].receiveShadow=true;
mesh["stone_2"].position.set(0,0,-40);
mesh["stone_2"].scale.set(4,4,4);
mesh["stone_2"].updateMatrixWorld();
mesh["stone_2"].matrixAutoUpdate=false;
mesh["stone_2"].updateMatrixWorld=function(){};
scene.add(mesh["stone_2"]);


}


// ДЛЯ СТАТИЧНЫХ ОБЪЕКТОВ, ЧТОБЫ ПРИ КАЖДОЙ ОТРИСОВКЕ НЕ ПЕРЕРАСЧИТЫВАЛ


mesh[name].matrixAutoUpdate=false;
mesh[name].updateMatrixWorld=function(){};


scene.add(mesh[name]);


}


mesh["home"].geometry.computeBoundingBox();
scene.add(new THREE.BoxHelper(mesh["home"]));


mesh["home001"].geometry.computeBoundingBox();
scene.add(new THREE.BoxHelper(mesh["home001"]));


});
// ____________________ LIGHTMAP ____________________


OBJLoader.load("./models/lightmap.obj",function(object){


let show_names=0; 
let text="\r\n";
let was=[];


while(object.children.length){


let tex_name=object.children[0].name+"VRayRawTotalLightingMap";
lightMap.push_uv([object.children[0].name,tex_name,new THREE.Float32BufferAttribute(object.children[0].geometry.attributes.uv.array,2)]);


if(show_names && was[tex_name]==undefined){
was[tex_name]=1;
//text+="tex[\""+tex_name+"\"]=texture_loader.load(\"images/lightmap/"+tex_name+".png\");\r\n";
//text+="tex[\""+tex_name+"\"].colorSpace=THREE.SRGBColorSpace;\r\n";
text+="tex[\""+tex_name+"\"]=RGBELoader.load(\"images/lightmap/"+tex_name+".hdr\");\r\n";
}


object.children.splice(0,1);


}


if(show_names){
console.log(text);
}


});
mat["jetski"]=new THREE.MeshStandardMaterial({
envMap:scene.background,
map:tex["jetski"],
metalness:0.7,
roughness:0.2,
});


OBJLoader.load("./models/jetski/jetski.obj",function(object){


while(object.children.length){


let name=object.children[0].name;


mesh[name]=object.children[0];


mesh[name].position.set(30,-1.3,140);
mesh["jetski"].rotation.x=-1.57;
mesh["jetski"].rotation.z=-2;
mesh[name].scale.set(0.3,0.3,0.3);
mesh[name].castShadow=true;
mesh[name].receiveShadow=true;
mesh[name].material=mat["jetski"];


scene.add(mesh[name]);
scene_2.children.push(mesh[name]);


}


});
mat["soldier_body"]=new THREE.MeshStandardMaterial({
map:tex["soldier_body_d"],
normalMap:tex["soldier_body_n"],
normalScale:{x:1,y:1},
//roughnessMap:tex["soldier_body_s"],
//roughness:1,
});


mat["soldier_head"]=new THREE.MeshStandardMaterial({
map:tex["soldier_head_d"],
normalMap:tex["soldier_head_n"],
normalScale:{x:1,y:1},
//roughnessMap:tex["soldier_head_s"],
//roughness:2.2,
});


FBXLoader.load('./models/soldier/soldier.fbx',function(object){


mesh["soldier"]=object;
mesh["soldier"].children[2].material=mat["soldier_body"];
mesh["soldier"].children[3].material[0]=mat["soldier_body"];
mesh["soldier"].children[3].material[1]=mat["soldier_head"];


mesh["soldier"].traverse(function(child){
if(child.isBone){ child.visible=false; }
});


mesh["soldier"].traverse(function(child){
if(child.isMesh){
child.castShadow=true;
child.receiveShadow=true;
}
});


});
mat["gun"]=new THREE.MeshStandardMaterial({
map:tex["gun_d"],
normalMap:tex["gun_n"],
normalScale:{x:2,y:2},
aoMap:tex["gun_ao"],
metalnessMap:tex["gun_m"],
metalness:0.4,
roughnessMap:tex["gun_r"],
roughness:1.2,
});


// ____________________ GUN ____________________


OBJLoader.load("./models/gun/gun.obj",function(object){


while(object.children.length){


let name=object.children[0].name;


mesh[name]=object.children[0];


mesh[name].position.set(0,0,0);
mesh[name].scale.set(100,100,100);
mesh[name].castShadow=true;
mesh[name].receiveShadow=true;


scene.add(mesh[name]);


}


});mat["ammo_crate"]=new THREE.MeshStandardMaterial({
map:tex["ammo_d"],
normalMap:tex["ammo_n"],
normalScale:{x:2,y:2},
aoMap:tex["ammo_ao"],
metalnessMap:tex["ammo_ms"],
metalness:0.4,
roughnessMap:tex["ammo_ms"],
roughness:1.2,
side:THREE.DoubleSide,
});


mat["ammo_items"]=new THREE.MeshStandardMaterial({
map:tex["ammo_items"],
});


OBJLoader.load("./models/ammo/ammo.obj",function(object){


while(object.children.length){


let name=object.children[0].name;


mesh[name]=object.children[0];


mesh[name].position.set(0,0,-8.25);
mesh[name].castShadow=true;
mesh[name].receiveShadow=true;


scene.add(mesh[name]);


}


});
mat["uaz_body"]=new THREE.MeshStandardMaterial({
map:tex["uaz_d"],
envMap:environment_main,
envMapIntensity:0.5,
normalMap:tex["uaz_n"],
aoMap:tex["uaz_ao"],
aoMapIntensity:1.0,
metalnessMap:tex["uaz_m"],
metalness:1.0,
roughnessMap:tex["uaz_s"],
roughness:0.6,
});


mat["uaz_glass"]=new THREE.MeshStandardMaterial({
map:tex["uaz_glass_d"],
envMap:environment_main,
normalMap:tex["uaz_glass_n"],
aoMap:tex["uaz_glass_ao"],
aoMapIntensity:0.8,
metalnessMap:tex["uaz_glass_m"],
metalness:1,
roughnessMap:tex["uaz_glass_s"],
roughness:1,
transparent:true,
opacity:0.2
});


OBJLoader.load("./models/uaz/uaz-452.obj",function(object){


while(object.children.length){


let name=object.children[0].name;


mesh[name]=object.children[0];


mesh[name].position.set(-5,0,0);
mesh[name].castShadow=true;
mesh[name].receiveShadow=true;


mesh[name].frustumCulled=false;
mesh[name].onAfterRender=function(){
this.frustumCulled=true;
this.onAfterRender=function(){};
}


scene.add(mesh[name]);


}


});
mat["ship_cruise_1"]=new THREE.MeshStandardMaterial({
color:0xffffff,
envMap:environment_main,
envMapIntensity:0.5,
metalness:0.2,
roughness:0.8,
side:2
});


mat["ship_cruise_2"]=new THREE.MeshStandardMaterial({
color:0xa0a0a0,
envMap:environment_main,
envMapIntensity:0.5,
metalness:1.0,
roughness:0.6,
side:2
});


mat["ship_cruise_3"]=new THREE.MeshStandardMaterial({
color:0x00a0a0,
envMap:environment_main,
envMapIntensity:0.5,
metalness:1.0,
roughness:0.6,
});


OBJLoader.load("./models/ship_cruise/ship_cruise.obj",function(object){


while(object.children.length){


let name=object.children[0].name;


mesh[name]=object.children[0];


mesh[name].position.set(0,-10,750);
mesh[name].rotation.y=0.5;
mesh[name].scale.set(0.2,0.2,0.2);
mesh[name].castShadow=true;
mesh[name].receiveShadow=true;


mesh[name].frustumCulled=false;
mesh[name].onAfterRender=function(){
this.frustumCulled=true;
this.onAfterRender=function(){};
}


scene.add(mesh[name]);


}


});
let wolf_tail=[];
let wolf_eye_bone;
let wolf_tail_bone;
let wolf_vector=new THREE.Vector3();



FBXLoader.load('./models/wolf/STANDARD_WOLF.fbx',function(object){
mixer["wolf"]=new THREE.AnimationMixer(object);
action["wolf"]=mixer["wolf"].clipAction(object.animations[0]);
action["wolf"].fadeIn(0.5);
action["wolf"].play();
mixers.push(mixer["wolf"]);
object.traverse(function(child) {


if(child.isMesh){
child.material=new THREE.MeshStandardMaterial({
map:tex["wolf"],
});
child.castShadow=true;
}





if(child.isBone){
child.visible=false;
if(child.name=="STANDARD_WOLF__Neck2"){
wolf_eye_bone=child;
}
if(child.name=="STANDARD_WOLF__Tail4"){
wolf_tail_bone=child;
}
}


});
mesh["wolf"]=object;
mesh["wolf"].position.set(13,0,0);


scene.add(mesh["wolf"]);


mesh["eye_1"]=new THREE.Mesh(new THREE.SphereGeometry(0.02,16,16,16),new THREE.MeshLambertMaterial({color:0xffff00}));
mesh["eye_1"].position.x=0.38;
mesh["eye_1"].position.z=-0.12;
wolf_eye_bone.add(mesh["eye_1"]);


mesh["eye_2"]=new THREE.Mesh(new THREE.SphereGeometry(0.02,16,16,16),new THREE.MeshLambertMaterial({color:0xffff00}));
mesh["eye_2"].position.x=0.38;
mesh["eye_2"].position.z=0.12;
wolf_eye_bone.add(mesh["eye_2"]);


mesh["tail"]=new THREE.Mesh(new THREE.SphereGeometry(0.14,16,16,16),new THREE.MeshBasicMaterial({color:0xffff00}));
mesh["tail"].position.x=0.2;
wolf_tail_bone.add(mesh["tail"]);


dummy["bone"]=new THREE.Object3D();
dummy["bone"].position.x=0.2;
dummy["bone"].matrix.compose(dummy["bone"].position,dummy["bone"].quaternion,dummy["bone"].scale);


wolf_tail.push([dummy["bone"].matrixWorld,wolf_tail_bone.matrixWorld,dummy["bone"].matrix,dummy["bone"].matrixWorld.elements]);


});
// ____________________ GULL ____________________


mat["gull"]=new THREE.MeshStandardMaterial({
map:tex["gull_d"],
});


FBXLoader.load('./models/gull/gull.fbx',function(object){


mesh["gull"]=object;
mesh["gull"].children[1].material=mat["gull"];


mesh["gull"].traverse(function(child){
if(child.isBone){ child.visible=false; }
});


mesh["gull"].traverse(function(child){
if(child.isMesh){
child.castShadow=true;
child.receiveShadow=true;
}
});


mesh["gull_fly_1"]=SkeletonUtils.clone(mesh["gull"]);
mesh["gull_fly_1"].animations=mesh["gull"].animations;
mixer["gull_fly_1"]=new THREE.AnimationMixer(mesh["gull_fly_1"]);
action["gull_fly_1"]=THREE.AnimationUtils.subclip(mesh["gull_fly_1"].animations[0],'attack',0,13);
action["gull_fly_1"]=mixer["gull_fly_1"].clipAction(action["gull_fly_1"]);
action["gull_fly_1"].time=0;
action["gull_fly_1"].play();
mixers.push(mixer["gull_fly_1"]);
mesh["gull_fly_1"].animations=[];
mesh["gull_fly_1"].scale.set(0.04,0.04,0.04);
mesh["gull_fly_1"].position.set(40,20,130);
mesh["gull_fly_1"].rotation.y=0;
mesh["gull_fly_1"].children[1].frustumCulled=false;
mesh["gull_fly_1"].children[1].onAfterRender=function(){
this.frustumCulled=true;
this.onAfterRender=function(){};
}
scene.add(mesh["gull_fly_1"]);


mesh["gull_fly_2"]=SkeletonUtils.clone(mesh["gull"]);
mesh["gull_fly_2"].animations=mesh["gull"].animations;
mixer["gull_fly_2"]=new THREE.AnimationMixer(mesh["gull_fly_2"]);
action["gull_fly_2"]=THREE.AnimationUtils.subclip(mesh["gull_fly_2"].animations[0],'attack',0,13);
action["gull_fly_2"]=mixer["gull_fly_2"].clipAction(action["gull_fly_2"]);
action["gull_fly_2"].time=0;
action["gull_fly_2"].play();
mixers.push(mixer["gull_fly_2"]);
mesh["gull_fly_2"].animations=[];
mesh["gull_fly_2"].scale.set(0.04,0.04,0.04);
mesh["gull_fly_2"].position.set(2,0,-8);
mesh["gull_fly_2"].rotation.y=0;
mesh["gull_fly_2"].children[1].frustumCulled=false;
mesh["gull_fly_2"].children[1].onAfterRender=function(){
this.frustumCulled=true;
this.onAfterRender=function(){};
}
scene.add(mesh["gull_fly_2"]);


});
OBJLoader.load("./models/grass_long.obj",function(object){
mesh["grass_long"]=object.children[0];
});
</script>
</body>
</html>